#pragma once

////////////////////////////////////////////////////////////////////////////////
// autogenerated rjd.h
////////////////////////////////////////////////////////////////////////////////

#include <stdint.h>
#include <float.h>
#include <stddef.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>
#include <stdarg.h>
#include <xmmintrin.h> // SSE2
#include <pmmintrin.h> // SSE3

#if RJD_IMPL
	#include <stdlib.h>
	#include <stdio.h>
#endif

////////////////////////////////////////////////////////////////////////////////
// rjd_platform.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PLATFORM_H 1

// Platforms
#if _WIN32 || __CYGWIN__
	#define RJD_PLATFORM_WINDOWS 1
	#define RJD_PLATFORM_OSX 0
#elif __APPLE__ && __MACH__
	#define RJD_PLATFORM_OSX 1
	#define RJD_PLATFORM_WINDOWS 0
#else
	#error Unknown platform.
#endif

// Compilers
#ifdef _MSC_VER
	#define RJD_COMPILER_MSVC 1
#elif __clang__
	#define RJD_COMPILER_CLANG 1
#elif __GNUC__
	#define RJD_COMPILER_GCC 1
#else
	#error Unknown compiler.
#endif

#if RJD_COMPILER_MSVC
	#define RJD_FORCE_INLINE __forceinline
	#define RJD_FORCE_ALIGN(type, alignment) __declspec(align(alignment)) type
	#define restrict __restrict
#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
	#define RJD_FORCE_INLINE static inline __attribute__((always_inline))
	#define RJD_FORCE_ALIGN(type, alignment) type __attribute__((aligned(alignment)))
#else
	#error Unhandled compiler
#endif

#if RJD_COMPILER_MSVC
	#if defined(_M_X86) || defined(_M_X64)
		#define RJD_ARCH_64 1
	#elif defined(_M_IX86)
		#define RJD_ARCH_32 1
	#else
		#error Unknown architecture
	#endif
#elif RJD_COMPILER_GCC
	#if defined(__x86_64) || defined(__x86_64__)
		#define RJD_ARCH_64 1
	#elif defined(i386) || defined(__i386) || defined(__i386__)
		#define RJD_ARCH_32 1
	#else
		#error Unknown architecture
	#endif
#elif RJD_COMPILER_CLANG
    #if defined(__x86_64) || defined(__x86_64__)
        #define RJD_ARCH_64 1
    #elif defined(i386) || defined(__i386) || defined(__i386__)
        #define RJD_ARCH_32 1
    #else
        #error Unknown architecture
    #endif
#else
	#error Unhandled compiler
#endif

#if RJD_COMPILER_MSVC
	#define RJD_COMPILER_MSVC_ONLY(code) code
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code)
#elif RJD_COMPILER_GCC
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code) code
	#define RJD_COMPILER_CLANG_ONLY(code)
#elif RJD_COMPILER_CLANG
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code) code
#else
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code)
#endif

#if RJD_COMPILER_MSVC
	#pragma warning(disable:4204) // nonstandard extension used: non-constant aggregate initializer (this is ok in C99)
	#pragma warning(disable:4201) // nonstandard extension used: nameless struct/union (all major compilers support this)
#elif RJD_COMPILER_CLANG
	#pragma clang diagnostic ignored "-Wmissing-braces" // clang is paranoid about zero-init for nested structs
#endif

#define RJD_LANG_OBJECTIVEC defined(__OBJC__)
#define RJD_LANG_CPP defined(__cplusplus)

#if RJD_PLATFORM_WINDOWS && RJD_IMPL 
	#define WIN32_LEAN_AND_MEAN
	#define WIN32_EXTRA_LEAN
	#define NOMINMAX
	#include <windows.h>
	#undef near
	#undef far
#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_debug.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_DEBUG_H 1

enum rjd_log_verbosity
{
	RJD_LOG_VERBOSITY_LOW,
	RJD_LOG_VERBOSITY_MED,
	RJD_LOG_VERBOSITY_HIGH,
};

struct rjd_logchannel
{
	enum rjd_log_verbosity verbosity;
	bool enabled;
	const char* name;
	void (*hook)(const char* formatted, size_t length);
};

#if RJD_ENABLE_LOGGING
	#define RJD_LOG_CHANNEL(channel, verbosity, ...) rjd_log_impl(__FILE__, __LINE__, channel, verbosity, __VA_ARGS__)
	#define RJD_LOG(...) RJD_LOG_CHANNEL(g_rjd_global_logchannel, RJD_LOG_VERBOSITY_MED, __VA_ARGS__)
#else
	#define RJD_LOG_CHANNEL(channel, ...)
	#define RJD_LOG(...)
#endif

#define RJD_NAMEGEN2(a, b) a##b
#define RJD_NAMEGEN(a, b) RJD_NAMEGEN2(a, b)
#define RJD_STATIC_ASSERT(condition) typedef char RJD_NAMEGEN(rjd_staticassert_failure_, __COUNTER__)[(condition) ? 1 : -1]

#if RJD_COMPILER_MSVC
	#define RJD_TRAP() __debugbreak()
#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
	#define RJD_TRAP() __builtin_trap()
#endif

#if RJD_ENABLE_ASSERT
	#define RJD_ASSERT(condition) RJD_ASSERTMSG(condition, #condition)
	#define RJD_ASSERTMSG(condition, ...) if (!(condition)) { RJD_LOG(__VA_ARGS__); RJD_TRAP(); }
	#define RJD_ASSERTFAIL(...) { RJD_LOG(__VA_ARGS__); RJD_TRAP(); }
#else
	#define RJD_ASSERT(condition, ...) 
	#define RJD_ASSERTMSG(condition, ...) 
	#define RJD_ASSERTFAIL(...)
#endif

#define RJD_UNUSED_PARAM(param) ((void)(param))

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...);
void rjd_log_resetglobal(void);

extern const struct rjd_logchannel* g_rjd_global_logchannel;

#if RJD_IMPL

const struct rjd_logchannel rjd_global_logchannel = {
	.verbosity = RJD_LOG_VERBOSITY_MED,
	.enabled = true,
	.name = "Default Global",
};
const struct rjd_logchannel* g_rjd_global_logchannel = &rjd_global_logchannel;

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...)
{
	if (!channel || !channel->enabled) {
		return;
	}

	if (verbosity > channel->verbosity) {
		return;
	}

	va_list args;
	va_start(args, format);

	char rawMessage[4096];

	int written = vsnprintf(rawMessage, sizeof(rawMessage), format, args);
	va_end(args);

	if (written < 0)
	{
		printf("Failed to format message.\n");
		RJD_TRAP();
	}

	static const char* formattedLog = "%s(%u): %s\n";
	static const uint32_t logLength = sizeof("%s(%u): %s\n");
	
	char formatted[4096];

	if (sizeof(formatted) <= logLength + written)
	{
		printf("Static buffer not large enough.\n");
		RJD_TRAP();
	}

	const int size = sprintf(formatted, formattedLog, file, line, rawMessage);

	if (channel->hook) {
		channel->hook(formatted, size);
	} else {
		RJD_COMPILER_MSVC_ONLY(OutputDebugString(formatted));
		fwrite(formatted, 1, size, stdout);
		fflush(stdout);
	}
}

void rjd_log_resetglobal()
{
	g_rjd_global_logchannel = &rjd_global_logchannel;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_result.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESULT_H 1

struct rjd_result
{
	const char* error;
};

static inline struct rjd_result rjd_result_init(const char* message) {
	return (struct rjd_result){message};
}

static inline bool rjd_result_isok(struct rjd_result result) {
	return result.error == NULL;
}

// TODO static assert that message is a compile-time string
#define RJD_RESULT(message) rjd_result_init(message)
#define RJD_RESULT_OK() rjd_result_init(NULL)
#define RJD_RESULT_CHECK(validation_condition, message) if (!(validation_condition)) { return RJD_RESULT(message); }

////////////////////////////////////////////////////////////////////////////////
// rjd_enum.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ENUM_H 1

// TODO support RJD_ENABLE_ENUM_TYPEDEF

// To use these macros, you need to define an xmacro list, then the use the appropriate *DECLARE
// in a header and *DEFINE in source files. By using these macros, you get:
// * The enum definition (as if you defined it yourself)
// * A count of members in the enum named k_<enumname>_count
// * An enumname_tostring() function that takes the enum and returns a static string (no mem allocation)
// * An enumname_parse() function that takes a const char* and pointer to enum and returns success/fail
// * An array of the enum values' string representation
//
// For example, let's define a Result enum with the values Success and Fail. Note to not forget the 
// backslash for extending the macro in the real version.
//
//	#define MY_ENUM_LIST(macro)
//		macro(RESULT_FAIL)
//		macro(RESULT_SUCCESS)
//	RJD_ENUM_DECLARE(Result, MY_ENUM_LIST);
//	RJD_ENUM_DEFINE(Result, MY_ENUM_LIST);
//
//	The generated interface for the Result enum above would be:
//		enum Result { RESULT_FAIL, RESULT_SUCCESS };
//		enum { k_Result_count = 2 };
//		const char* Result_tostring(enum Result v);
//		bool Result_parse(const char* s, enum Result v);
//		const char* s_Result_strings[] = { "RESULT_FAIL", "RESULT_SUCCESS" };
//
//	You can also specify custom strings if you want to override the default tostring/parse:
//
//	#define MY_ENUM_LIST2(macro)
//		macro(MY_ENUM_LIST2_V1, "CustomStringRep1")
//		macro(MY_ENUM_LIST2_V2, "CustomStringRep2")
//		macro(MY_ENUM_LIST2_V3, "CustomStringRep3")
//	RJD_ENUM_DECLARE_WITH_STRINGS(CoolEnum, MY_ENUM_LIST);
//	RJD_ENUM_DEFINE_WITH_STRINGS(CoolEnum, MY_ENUM_LIST);
//

#define RJD_ENUM_IMPL_TOSTRING(name) name ## _tostring
#define RJD_ENUM_IMPL_COUNT(name) k_ ## name ## _count
#define RJD_ENUM_IMPL_PARSE(name) name ## _parse
#define RJD_ENUM_IMPL_STRINGS(name) s_ ## name ## _strings

#define RJD_ENUM_IMPL_MEMBER(item) item,
#define RJD_ENUM_IMPL_SUM(item) 1 +
#define RJD_ENUM_IMPL_TOSTRING_ITEM(item) #item,
#define RJD_ENUM_IMPL_TOSTRING_CASE(item) case item: return #item;

#define RJD_ENUM_IMPL_MEMBER_WITH_STRING(item, str) item,
#define RJD_ENUM_IMPL_SUM_WITH_STRING(item, str) 1 +
#define RJD_ENUM_IMPL_WITH_STRING_ITEM(item, str) str,
#define RJD_ENUM_IMPL_WITH_STRING_CASE(item, str) case item: return str;

#define RJD_ENUM_DECLARE(name, macrolist)											\
	enum name {																		\
		macrolist(RJD_ENUM_IMPL_MEMBER)												\
	};																				\
	enum { RJD_ENUM_IMPL_COUNT(name) = macrolist(RJD_ENUM_IMPL_SUM) 0 };			\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v);							\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out);					\
	extern const char* RJD_ENUM_IMPL_STRINGS(name)[]

#define RJD_ENUM_DEFINE(name, macrolist)											\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v) {							\
		switch(v) {																	\
			macrolist(RJD_ENUM_IMPL_TOSTRING_CASE)									\
		}																			\
		return "invalid value";														\
	}																				\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out) {					\
		RJD_ASSERT(out);															\
		for (size_t i = 0; i < RJD_ENUM_IMPL_COUNT(name); ++i) {					\
			if (!strcmp(RJD_ENUM_IMPL_STRINGS(name)[i], s)) {						\
				*out = (enum name)i;												\
				return true;														\
			}																		\
		}																			\
		return false;																\
	}																				\
	const char* RJD_ENUM_IMPL_STRINGS(name)[] = {									\
		macrolist(RJD_ENUM_IMPL_TOSTRING_ITEM)										\
	}

#define RJD_ENUM_DECLARE_WITH_STRINGS(name, macrolist)								\
	enum name {																		\
		macrolist(RJD_ENUM_IMPL_MEMBER_WITH_STRING)									\
	};																				\
	enum { RJD_ENUM_IMPL_COUNT(name) = macrolist(RJD_ENUM_IMPL_SUM_WITH_STRING) 0 };\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v);							\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out);					\
	extern const char* RJD_ENUM_IMPL_STRINGS(name)[]

#define RJD_ENUM_DEFINE_WITH_STRINGS(name, macrolist)								\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v) {							\
		switch(v) {																	\
			macrolist(RJD_ENUM_IMPL_WITH_STRING_CASE)								\
		}																			\
		return "invalid value";														\
	}																				\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out) {					\
		RJD_ASSERT(out);															\
		for (size_t i = 0; i < RJD_ENUM_IMPL_COUNT(name); ++i) {					\
			if (!strcmp(RJD_ENUM_IMPL_STRINGS(name)[i], s)) {						\
				*out = (enum name)i;												\
				return true;														\
			}																		\
		}																			\
		return false;																\
	}																				\
	const char* RJD_ENUM_IMPL_STRINGS(name)[] = {									\
		macrolist(RJD_ENUM_IMPL_WITH_STRING_ITEM)									\
	}


////////////////////////////////////////////////////////////////////////////////
// rjd_hash.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_HASH_H 1

typedef struct {
	uint32_t value;
} rjd_hash32;

typedef struct {
	uint64_t value;
} rjd_hash64;

// You can pass -1 as the length to indicate a NULL-terminated buffer (e.g. c-style string)
rjd_hash32 rjd_hash32_data(const uint8_t* key, int length);
rjd_hash64 rjd_hash64_data(const uint8_t* key, int length);
bool rjd_hash32_valid(rjd_hash32 hash);
bool rjd_hash64_valid(rjd_hash64 hash);

#if RJD_IMPL

// Code derived from:
// Copyright (c) 2011 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//
// originally developed by Fowler, Noll and Vo
// http://isthe.com/chongo/tech/comp/fnv/
//
// prime/seed from http://isthe.com/chongo/tech/comp/fnv/

rjd_hash32 rjd_hash32_data(const uint8_t* key, int length)
{
	RJD_ASSERT(length >= -1);

	if (key == NULL || length == 0 || (length == -1 && *key == '\0')) {
		rjd_hash32 hash = {0};
		return hash;
	}

	const uint32_t PRIME = 16777619;
	const uint32_t SEED  = 2166136261;

	rjd_hash32 hash = { SEED };
	if (length == -1) {
		while (*key) {
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	} else {
		while (length > 0)
		{
			--length;
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	}
	return hash;
}

rjd_hash64 rjd_hash64_data(const uint8_t* key, int length)
{
	RJD_ASSERT(length >= -1);

	if (key == NULL || length == 0 || (length == -1 && *key == '\0')) {
		rjd_hash64 hash = {0};
		return hash;
	}

	const uint64_t PRIME = 1099511628211ull;
	const uint64_t SEED  = 14695981039346656037ull;

	rjd_hash64 hash = { SEED };
	if (length == -1) {
		while (*key) {
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	} else {
		while (length > 0)
		{
			--length;
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	}
	return hash;
}

bool rjd_hash32_valid(rjd_hash32 hash)
{
	return hash.value != 0;
}

bool rjd_hash64_valid(rjd_hash64 hash)
{
	return hash.value != 0;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_mem.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_MEM_H 1

struct rjd_mem_allocator_stats
{
	uint32_t total_size;
	struct {
		uint32_t used;
		uint32_t overhead;
		uint32_t peak;
		uint32_t unused;
		uint32_t allocs;
		uint32_t frees;
	} current;
	struct {
		uint32_t peak;
		uint32_t allocs;
		uint32_t frees;
		uint32_t resets;
	} lifetime;
};

// TODO realloc
typedef const char* (*rjd_mem_allocator_type_func)(void);
typedef void* (*rjd_mem_allocator_alloc_func)(size_t size, void* optional_heap);
typedef void (*rjd_mem_allocator_free_func)(void* memory);
typedef void (*rjd_mem_allocator_reset_func)(void* optional_heap);

struct rjd_mem_allocator
{
	rjd_mem_allocator_type_func type_func; // must return a static string
	rjd_mem_allocator_alloc_func alloc_func;
	rjd_mem_allocator_free_func free_func;
	rjd_mem_allocator_reset_func reset_func; // optional
	void* optional_heap;

	struct rjd_mem_allocator_stats stats;

	uint32_t debug_sentinel;
};

struct rjd_mem_allocator rjd_mem_allocator_init_default(void);
struct rjd_mem_allocator rjd_mem_allocator_init_linear(void* memblock, size_t size);

const char* rjd_mem_allocator_type(struct rjd_mem_allocator* allocator);
bool rjd_mem_allocator_reset(struct rjd_mem_allocator* allocator);
struct rjd_mem_allocator_stats rjd_mem_allocator_getstats(const struct rjd_mem_allocator* allocator);

void rjd_mem_free(const void* mem);
void rjd_mem_swap(void* restrict mem1, void* restrict mem2, size_t size);

#define rjd_mem_alloc(type, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type), (allocator), 8))
#define rjd_mem_alloc_aligned(type, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type), allocator, alignment))
#define rjd_mem_alloc_array(type, count, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, 8))
#define rjd_mem_alloc_array_aligned(type, count, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, alignment))

#define RJD_MEM_ISALIGNED(p, align) (((uintptr_t)(p) & ((align)-1)) == 0)
#define RJD_MEM_ALIGN(size, align) ((size) + (RJD_MEM_ISALIGNED(size, align) ? 0 : ((align) - ((size) & ((align)-1)))))

void* rjd_mem_alloc_impl(size_t size, struct rjd_mem_allocator* allocator, uint32_t alignment);

////////////////////////////////////////////////////////////////////////////////

#if RJD_IMPL

struct rjd_mem_heap_linear
{
	void* base;
	void* next;
	size_t size;
	uint32_t debug_sentinel;
};

struct rjd_mem_allocation_header
{
	struct rjd_mem_allocator* allocator;
	uint8_t offset_to_block_begin_from_user;
	uint32_t total_blocksize;
	uint32_t debug_sentinel;
};

static const char* rjd_mem_allocator_global_type(void);
static void* rjd_mem_allocator_global_alloc(size_t size, void* heap);
static void rjd_mem_allocator_global_free(void* mem);

static const char* rjd_mem_allocator_linear_type(void);
static void* rjd_mem_allocator_linear_alloc(size_t size, void* heap);
static void rjd_mem_allocator_linear_reset(void* heap);

const uint32_t RJD_MEM_DEBUG_DEFAULT_SENTINEL32 = 0xA7A7A7A7u;
const uint32_t RJD_MEM_DEBUG_LINEAR_SENTINEL32 = 0xA8A8A8A8u;
const uint32_t RJD_MEM_STATS_UNKNOWN_UPPERBOUND = UINT32_MAX;

struct rjd_mem_allocator rjd_mem_allocator_init_default()
{
	struct rjd_mem_allocator allocator = {
		.type_func = rjd_mem_allocator_global_type,
		.alloc_func = NULL,
		.free_func = NULL,
		.reset_func = NULL,
		.optional_heap = NULL,
		.stats = {
			.total_size = RJD_MEM_STATS_UNKNOWN_UPPERBOUND,
			.current = {
				.unused = RJD_MEM_STATS_UNKNOWN_UPPERBOUND,
			},
		},
		.debug_sentinel = RJD_MEM_DEBUG_DEFAULT_SENTINEL32,
	};

	// MSVC has a slightly different signature for malloc/free so to avoid platform-specific
	// code, we just wrap them for all platforms here
	allocator.alloc_func = rjd_mem_allocator_global_alloc;
	allocator.free_func = rjd_mem_allocator_global_free;

	return allocator;
}

struct rjd_mem_allocator rjd_mem_allocator_init_linear(void* memblock, size_t size)
{
	RJD_ASSERT(memblock);

	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)RJD_MEM_ALIGN((uintptr_t)memblock, 64);
	uint32_t usable_size = 0;
	{
		char* usable_memory_start = (char*)RJD_MEM_ALIGN((uintptr_t)heap + sizeof(struct rjd_mem_heap_linear), 64);
		char* usable_memory_end = (char*)memblock + size;
		RJD_ASSERTMSG(usable_memory_start < usable_memory_end, 
			"Given size was not large enough to make a heap. You need at least 128 bytes...");

		usable_size = (uint32_t)(usable_memory_end - usable_memory_start);

		struct rjd_mem_heap_linear copy = { 
			.base = usable_memory_start, 
			.next = usable_memory_start, 
			.size = usable_size, 
			.debug_sentinel = RJD_MEM_DEBUG_LINEAR_SENTINEL32 
		};
		*heap = copy;
	}

	struct rjd_mem_allocator allocator = {
		.type_func = rjd_mem_allocator_linear_type,
		.alloc_func = rjd_mem_allocator_linear_alloc,
		.free_func = NULL,
		.reset_func = rjd_mem_allocator_linear_reset,
		.optional_heap = heap,
		.stats = {
			.total_size = usable_size,
			.current = {
				.unused = usable_size,
			},
		},
		.debug_sentinel = RJD_MEM_DEBUG_LINEAR_SENTINEL32,
	};

	return allocator;
}

const char* rjd_mem_allocator_type(struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);
	return allocator->type_func();
}

bool rjd_mem_allocator_reset(struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);

	allocator->stats.current.used = 0;
	allocator->stats.current.overhead = 0;
	allocator->stats.current.peak = 0;
	allocator->stats.current.unused = allocator->stats.total_size;
	allocator->stats.current.allocs = 0;
	allocator->stats.current.frees = 0;
	++allocator->stats.lifetime.resets;

	if (allocator->reset_func) {
		allocator->reset_func(allocator->optional_heap);

		return true;
	}
	return false;
}

struct rjd_mem_allocator_stats rjd_mem_allocator_getstats(const struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);
	return allocator->stats;
}

void* rjd_mem_alloc_impl(size_t size, struct rjd_mem_allocator* allocator, uint32_t alignment)
{
	RJD_ASSERT(allocator);
    RJD_ASSERT(size >= 0)
	RJD_ASSERT(alignment >= 8);

	const uint32_t header_size = sizeof(struct rjd_mem_allocation_header);
    const uint32_t alignment_padding = alignment * 2;
	const uint32_t total_size = (uint32_t)size + header_size + alignment_padding;
    
   	char* raw = allocator->alloc_func(total_size, allocator->optional_heap);
	if (raw == NULL) {
		return raw;
	}

	uintptr_t aligned_user = RJD_MEM_ALIGN((uintptr_t)raw + alignment + header_size, alignment);

	struct rjd_mem_allocation_header* header = (void*)(aligned_user - header_size);
	header->allocator = allocator;
	header->total_blocksize = (uint32_t)total_size;
	header->offset_to_block_begin_from_user = aligned_user - (uintptr_t)raw;
	header->debug_sentinel = allocator->debug_sentinel;

	{
		uint32_t* current_used = &allocator->stats.current.used;
		uint32_t* current_peak = &allocator->stats.current.peak;
		uint32_t* lifetime_peak = &allocator->stats.lifetime.peak;
		*current_used += total_size;
		allocator->stats.current.overhead += total_size - size;
		*current_peak = (*current_peak < *current_used) ? *current_used : *current_peak;
		*lifetime_peak = (*lifetime_peak < *current_used) ? *current_used : *lifetime_peak;
		if (allocator->stats.current.unused != RJD_MEM_STATS_UNKNOWN_UPPERBOUND) {
			RJD_ASSERT(allocator->stats.current.unused >= total_size);
			allocator->stats.current.unused -= total_size;
		}
		++allocator->stats.current.allocs;
		++allocator->stats.lifetime.allocs;
	}

	return (void*)aligned_user;
}

void rjd_mem_free(const void* mem)
{
	if (!mem) {
		return;
	}

	char* raw = (void*)mem;
	struct rjd_mem_allocation_header* header = (void*)(raw - sizeof(struct rjd_mem_allocation_header));
	struct rjd_mem_allocator* allocator = header->allocator;

	RJD_ASSERTMSG(header->debug_sentinel == allocator->debug_sentinel, "This memory was not allocated with rjd_mem_alloc.");

	if (allocator->free_func) {
		RJD_ASSERT(allocator->stats.current.used >= header->total_blocksize);
		allocator->stats.current.used -= header->total_blocksize;
		if (allocator->stats.current.unused != RJD_MEM_STATS_UNKNOWN_UPPERBOUND) {
			allocator->stats.current.unused += header->total_blocksize;
		}
		++allocator->stats.current.frees;
		++allocator->stats.lifetime.frees;
        
        char* begin = raw - header->offset_to_block_begin_from_user;
        allocator->free_func(begin);
	}
}

void rjd_mem_swap(void* restrict mem1, void* restrict mem2, size_t size)
{
	uint8_t tmp[1024];
	RJD_ASSERTMSG(size < (uint32_t)sizeof(tmp), "Increase size of static buffer to at least %u", size);

	memcpy(tmp, mem1, size);
	memcpy(mem1, mem2, size);
	memcpy(mem2, tmp, size);
}

////////////////////////////////////////////////////////////////////////////////
// local helper definitions

const char* rjd_mem_allocator_global_type(void)
{
	return "rjd_global";
}

void* rjd_mem_allocator_global_alloc(size_t size, void* unused_heap)
{
	RJD_UNUSED_PARAM(unused_heap);

	return malloc(size);
}

void rjd_mem_allocator_global_free(void* mem)
{
	free(mem);
}

const char* rjd_mem_allocator_linear_type(void)
{
	return "rjd_linear";
}

void* rjd_mem_allocator_linear_alloc(size_t size, void* optional_heap)
{
	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)optional_heap;
	RJD_ASSERT(heap->debug_sentinel == RJD_MEM_DEBUG_LINEAR_SENTINEL32);

	size_t align_diff = size % 8;
	if (align_diff != 0) {
		size += align_diff;
	}

	if ((char*)heap->next + size <= (char*)heap->base + heap->size) 
	{
		void* mem = (char*)heap->next;
		heap->next = (char*)heap->next + size;

		return mem;
	}

	return NULL;
}

void rjd_mem_allocator_linear_reset(void* optional_heap)
{
	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)optional_heap;
	RJD_ASSERT(heap->debug_sentinel == RJD_MEM_DEBUG_LINEAR_SENTINEL32);

	heap->next = heap->base;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_rng.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RNG_H 1

struct rjd_rng
{
	uint64_t seed;
	uint64_t state;
};

struct rjd_rng rjd_rng_init(uint64_t seed);
uint64_t rjd_rng_next(struct rjd_rng* rng);
double rjd_rng_float(struct rjd_rng* rng);
int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive);

#if RJD_IMPL

struct rjd_rng rjd_rng_init(uint64_t seed)
{
	struct rjd_rng rng = { seed, seed };
	return rng;
}

uint64_t rjd_rng_next(struct rjd_rng* rng)
{
	rng->state ^= rng->state << 15;
	rng->state ^= rng->state >> 3;
	rng->state ^= rng->state << 52;
	return rng->state;
}

double rjd_rng_float(struct rjd_rng* rng)
{
	uint64_t next = rjd_rng_next(rng) % 1000001ull;
	return (double)next / 1000000.0;
}

int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive)
{
	if (max_exclusive < min_inclusive) {
		return max_exclusive;
	}

	int32_t range = max_exclusive - min_inclusive;
	if (range == 0) {
		return min_inclusive;
	}

	uint64_t next = rjd_rng_next(rng);
	return min_inclusive + (next % range);
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_array.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ARRAY_H 1

struct rjd_mem_allocator;

#if RJD_COMPILER_CLANG || RJD_COMPILER_GCC
	#define RJD_SAME_TYPE(a, b) (__builtin_types_compatible_p(__typeof__(a), __typeof__(b)))
	#define RJD_STATIC_ZERO(a) (sizeof(int[(a)?1:-1]) * 0)
	#define RJD_MUST_BE_ARRAY(a) (RJD_STATIC_ZERO(!RJD_SAME_TYPE((a), &(*a))))

	#define rjd_countof(buf) (sizeof(buf) / sizeof(*(buf)) + RJD_MUST_BE_ARRAY(buf))
#else
	#define rjd_countof(buf) (sizeof(buf) / sizeof(buf[0]))
#endif

#define rjd_array_alloc(type, capacity, alloc_context)	((type*)(rjd_array_alloc_impl((capacity), (alloc_context), sizeof(type))))
#define rjd_array_free(buf)								rjd_array_free_impl(buf)
#define rjd_array_capacity(buf) 						((buf)?(const uint32_t)(*rjd_array_capacity_impl(buf)):0)
#define rjd_array_count(buf) 							((buf)?(const uint32_t)(*rjd_array_count_impl(buf)):0)
#define rjd_array_clear(buf)							(*rjd_array_count_impl(buf) = 0)
#define rjd_array_reserve(buf, capacity)				(buf = rjd_array_reserve_impl((buf), capacity, sizeof(*(buf))))
#define rjd_array_resize(buf, size) 					(buf = rjd_array_resize_impl((buf), size, sizeof(*(buf))))
#define rjd_array_trim(buf)								(buf = rjd_array_trim_impl((buf), sizeof(*(buf))))
#define rjd_array_erase(buf, index) 					rjd_array_erase_impl((buf), index, sizeof(*(buf)))
#define rjd_array_erase_unordered(buf, index) 			rjd_array_erase_unordered_impl((buf), index, sizeof(*(buf)))
#define rjd_array_empty(buf) 							(rjd_array_count(buf) == 0)
#define rjd_array_full(buf) 							(rjd_array_count(buf) == rjd_array_capacity(buf))
#define rjd_array_push(buf, value) 						(buf = rjd_array_push_impl((buf), \
														sizeof(*(buf))), (buf)[rjd_array_count(buf) - 1] = value)
#define rjd_array_pop(buf)		 						(rjd_array_pop_impl(buf), 		\
														--*rjd_array_count_impl(buf), 	\
														*(buf + rjd_array_count(buf)))
#define rjd_array_get(buf, index)						(rjd_array_get_validate((buf), (index)), (buf)[(index)])
#define rjd_array_first(buf)							(rjd_array_get_validate((buf), 0), (buf)[0])
#define rjd_array_last(buf)								(rjd_array_get_validate((buf), 0), (buf)[rjd_array_count(buf) - 1])

// searching/sorting

typedef int32_t (*rjd_array_compare_predicate)(void* userdata, const void* left, const void* right);

enum { RJD_ARRAY_NOT_FOUND = -1 };

#define rjd_array_contains(buf, ptr)					rjd_array_contains_impl((buf), (ptr), sizeof(*(buf)), sizeof(*(ptr)))
#define rjd_array_find(buf, ptr)						rjd_array_find_linear_impl((buf), (ptr), sizeof(*(buf)), sizeof(*(ptr)))
#define rjd_array_find_sorted(buf, ptr, predicate, userdata)																		\
														rjd_array_find_sorted_impl((buf), (ptr), sizeof(*(buf)), sizeof(*(ptr)),	\
																					predicate, userdata)
#define rjd_array_sort(buf, predicate, userdata)		rjd_array_sort_impl((buf), sizeof(*(buf)), predicate, userdata)

// predicate helpers for the functional-style interface
#define rjd_array_sum_predicate(acc, element) 			(acc + element)

// functional-style helpers
#define rjd_array_filter(buf, predicate, userata)		for(int _i = (int)rjd_array_count(buf) - 1; _i >= 0; --_i) { 	 \
															if (!(predicate((buf)[_i]))) { rjd_array_erase((buf), _i); } \
														}
#define rjd_array_map(in, out, predicate)				rjd_array_resize((out), rjd_array_count(in)); 					\
														for (size_t _i = 0; _i < rjd_array_count(in); ++_i) {			\
															out[_i] = predicate(in[_i]); 								\
														}
#define rjd_array_reduce(buf, acc, predicate)			for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) {			\
															(acc) = predicate(acc, ((buf)[_i]));						\
														}
#define rjd_array_sum(buf, acc)							for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) {			\
															(acc) = rjd_array_sum_predicate((acc), ((buf)[_i]));		\
														}
#define rjd_array_reverse(buf)							rjd_array_reverse_impl(buf, sizeof(*buf))
#define rjd_array_sample(buf, rng)						((buf)[rjd_rng_range32(rng, 0, rjd_array_count(buf))])
#define rjd_array_shuffle(buf, rng)						rjd_array_shuffle_impl(buf, rng, sizeof(*buf))

struct rjd_rng;

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_mem_allocator* allocator, size_t sizeof_type);
void rjd_array_free_impl(const void* array);
uint32_t* rjd_array_capacity_impl(const void* array);
uint32_t* rjd_array_count_impl(const void* array);
void* rjd_array_reserve_impl(void* array, uint32_t newcapacity, size_t sizeof_type);
void* rjd_array_resize_impl(void* array, uint32_t newcount, size_t sizeof_type);
void* rjd_array_trim_impl(void* array, size_t sizeof_type);
void rjd_array_erase_impl(void* array, uint32_t index, size_t sizeof_type);
void rjd_array_erase_unordered_impl(void* array, uint32_t index, size_t sizeof_type);
void* rjd_array_push_impl(void* array, size_t sizeof_type);
void rjd_array_pop_impl(void* array);
void rjd_array_get_validate(void* array, uint32_t index);
int32_t rjd_array_find_linear_impl(const void* array, const void* search, size_t sizeof_type, size_t sizeof_value);
int32_t rjd_array_find_sorted_impl(const void* array, const void* search, size_t sizeof_type, size_t sizeof_value, rjd_array_compare_predicate compare, void* userdata);
bool rjd_array_contains_impl(const void* array, const void* search, size_t sizeof_type, size_t sizeof_value);
void rjd_array_sort_impl(void* array, size_t sizeof_type, rjd_array_compare_predicate predicate, void* userdata);
void rjd_array_shuffle_impl(void* array, struct rjd_rng* rng, size_t sizeof_type);
void rjd_array_reverse_impl(void* array, size_t sizeof_type);

#if RJD_IMPL

struct rjd_array_header
{
	struct rjd_mem_allocator* allocator;
	uint32_t capacity;
	uint32_t count;
	uint32_t debug_sentinel;
};

const uint32_t RJD_ARRAY_DEBUG_SENTINEL32 = 0xA7A7A7A7;

static struct rjd_array_header* rjd_array_getheader(void* array);
static struct rjd_mem_allocator* rjd_array_allocator(void* array);
static inline void rjd_array_validate(const void* array);

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_mem_allocator* allocator, size_t sizeof_type)
{
	RJD_ASSERT(capacity > 0);
	RJD_ASSERT(allocator);
	RJD_ASSERT(sizeof_type > 0);

	size_t rawsize = sizeof(struct rjd_array_header) + (sizeof_type * capacity);
	char* raw = rjd_mem_alloc_array(char, rawsize, allocator);

	struct rjd_array_header* header = (struct rjd_array_header*)raw;
	header->allocator = allocator;
	header->capacity = capacity;
	header->count = 0;
	header->debug_sentinel = RJD_ARRAY_DEBUG_SENTINEL32; 

	char* buf = raw + sizeof(struct rjd_array_header);
	return buf;
}

void rjd_array_free_impl(const void* array)
{
	if (!array) {
		return;
	}
	rjd_array_validate(array);

	char* raw = (char*)array;
	rjd_mem_free(raw - sizeof(struct rjd_array_header));
}

uint32_t* rjd_array_capacity_impl(const void* array)
{
	RJD_ASSERT(array);

	rjd_array_validate(array);

	struct rjd_array_header* header = rjd_array_getheader((void*)array);
	return &header->capacity;
}

uint32_t* rjd_array_count_impl(const void* array)
{
	RJD_ASSERT(array);

	rjd_array_validate(array);

	struct rjd_array_header* header = rjd_array_getheader((void*)array);
	return &header->count;
}

void* rjd_array_reserve_impl(void* array, uint32_t newcapacity, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	uint32_t oldcapacity = rjd_array_capacity(array);

	if (oldcapacity < newcapacity) {
		struct rjd_mem_allocator* allocator = rjd_array_allocator(array);
		char* newarray = rjd_array_alloc_impl(newcapacity, allocator, sizeof_type);

		uint32_t* count = rjd_array_count_impl(newarray);
		*count = rjd_array_count(array);

		memcpy(newarray, array, (*count * sizeof_type));

		rjd_array_free(array);
		return newarray;
	}

	return array;
}

void* rjd_array_resize_impl(void* array, uint32_t newcount, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	array = rjd_array_reserve_impl(array, newcount, sizeof_type);
	uint32_t* count = rjd_array_count_impl(array);

	// zero new members
	if (newcount > *count) {
		memset((char*)array + (*count * sizeof_type), 0, (newcount - *count) * sizeof_type);
	}

	*count = newcount;
	return array;
}

void* rjd_array_trim_impl(void* array, size_t sizeof_type)
{
	if (rjd_array_count(array) == rjd_array_capacity(array)) {
		return array;
	}

	void* newarray = rjd_array_alloc_impl(rjd_array_count(array), rjd_array_allocator(array), sizeof_type);
	memcpy(newarray, array, rjd_array_count(array) * sizeof_type);
	*rjd_array_count_impl(newarray) = rjd_array_count(array);

	rjd_array_free(array);

	return newarray;

}

void rjd_array_erase_impl(void* array, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(index < rjd_array_count(array));
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	char* raw = array;
	size_t toshift = rjd_array_count(array) - index - 1;
	if (toshift > 0) {
		memmove(raw + index * sizeof_type, raw + (index + 1) * sizeof_type, toshift * sizeof_type);
	}
	--*rjd_array_count_impl(array);
}

void rjd_array_erase_unordered_impl(void* array, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(index < rjd_array_count(array));
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	char* raw = array;

	uint32_t* count = rjd_array_count_impl(array);

	if (*count > 1) {
		char* erase = raw + index * sizeof_type;
		char* swap = raw + (*count - 1) * sizeof_type;
		memcpy(erase, swap, sizeof_type);
	}

	if (*count > 0) {
		--*rjd_array_count_impl(array);
	}
}

void* rjd_array_push_impl(void* array, size_t sizeof_type) {
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	uint32_t count = rjd_array_count(array);
	uint32_t capacity = rjd_array_capacity(array);
	if (count == capacity) {
		array = rjd_array_reserve_impl(array, capacity * 2, sizeof_type);
	}

	*rjd_array_count_impl(array) = count + 1;

	// skip init new element to 0 since it will be set in the push macro

	return array;
}

void rjd_array_pop_impl(void* array)
{
	RJD_ASSERT(rjd_array_count(array) > 0);
}

void rjd_array_get_validate(void* array, uint32_t index)
{
	rjd_array_validate(array);
	RJD_ASSERT(index < rjd_array_count(array));
}

int32_t rjd_array_find_linear_impl(const void* array, const void* search, size_t sizeof_type, size_t sizeof_value)
{
	RJD_ASSERT(sizeof_type == sizeof_value);

	rjd_array_validate(array);

	if (!array) {
		return false;
	}

	char* raw = (char*)array;
	for (int32_t i = 0; i < (int32_t)rjd_array_count(array); ++i) {
		if (!memcmp(raw + i * sizeof_type, search, sizeof_type)) {
			return i;
		}
	}
	return RJD_ARRAY_NOT_FOUND;
}

const void* rjd_array_find_sorted_internal(const void* array, int32_t length, const void* search, int32_t sizeof_value, rjd_array_compare_predicate compare, void* userdata)
{
	if (length == 0) {
		return NULL;
	}

	int32_t midpoint;
	int32_t next_length;

	if ((length % 2) == 1) {
		midpoint = (length / 2) + 1;
		next_length = (length / 2);
	} else {
		midpoint = (length / 2);
		next_length = (length / 2) + 1;
	}

	const void* value = (const char*)array + midpoint * sizeof_value;
	const int32_t compared_value = compare(userdata, value, search);
	if (compared_value < 0) {
		return rjd_array_find_sorted_internal(array, next_length, search, sizeof_value, compare, userdata);
	} else if (compared_value > 0) {
		const void* next_value = (const char*)value + sizeof_value;
		return rjd_array_find_sorted_internal(next_value, next_length, search, sizeof_value, compare, userdata);
	}

	return value;
}

int32_t rjd_array_find_sorted_impl(const void* array, const void* search, size_t sizeof_type, size_t sizeof_value, rjd_array_compare_predicate compare, void* userdata)
{
	RJD_ASSERT(sizeof_type == sizeof_value);

	rjd_array_validate(array);

	if (!array) {
		return false;
	}

	uint32_t length = rjd_array_count(array);
	const char* found = rjd_array_find_sorted_internal(array, length, search, sizeof_type, compare, userdata);
	if (found == NULL) {
		return RJD_ARRAY_NOT_FOUND;
	}

	const char* begin = array;
	ptrdiff_t diff = (found - begin) / sizeof_type;
	return (int32_t)diff / sizeof_type;
}

bool rjd_array_contains_impl(const void* array, const void* search, size_t sizeof_type, size_t sizeof_value)
{
	int32_t index = rjd_array_find_linear_impl(array, search, sizeof_type, sizeof_value);
	return index != RJD_ARRAY_NOT_FOUND;
}

void rjd_array_sort_impl(void* array, size_t sizeof_type, rjd_array_compare_predicate predicate, void* userdata)
{
	size_t length = rjd_array_count(array);
#if RJD_COMPILER_MSVC
	qsort_s(array, length, sizeof_type, userdata, predicate);
#else
	qsort_r(array, length, sizeof_type, userdata, predicate);
#endif
}

void rjd_array_shuffle_impl(void* array, struct rjd_rng* rng, size_t sizeof_type)
{
	if (!array) {
		return;
	}

	rjd_array_validate(array);

	char tmp[512];
	RJD_ASSERTMSG(sizeof_type <= sizeof(tmp), 
		"tmp (%u bytes) must be greater than or equal to sizeof_type (%u bytes)", 
		(unsigned) sizeof(tmp), (unsigned) sizeof_type);

	char* raw = (char*)array;
	for (uint32_t i = 0; i < rjd_array_count(array); ++i) {
		uint32_t k = rjd_rng_range32(rng, 0, rjd_array_count(array));
		if (i == k) {
			continue;
		}

		char* a = raw + (i * sizeof_type);
		char* b = raw + (k * sizeof_type);

		memcpy(tmp, a, sizeof_type);
		memcpy(a, b, sizeof_type);
		memcpy(b, tmp, sizeof_type);
	}
}

void rjd_array_reverse_impl(void* array, size_t sizeof_type)
{
	if (!array) {
		return;
	}
	rjd_array_validate(array);

	uint8_t* raw = array;
	for (uint8_t* begin = raw, *end = raw + (int32_t)sizeof_type * ((int32_t)rjd_array_count(array) - 1); 
		begin < end; 
		begin += sizeof_type, end -= sizeof_type)
	{
		rjd_mem_swap(begin, end, sizeof_type);
	}
}

static struct rjd_array_header* rjd_array_getheader(void* array)
{
	if (!array) {
		return NULL;
	}
	rjd_array_validate(array);

	char* raw = array;
	char* raw_header = raw - sizeof(struct rjd_array_header);
	return (struct rjd_array_header*) raw_header;
}

static struct rjd_mem_allocator* rjd_array_allocator(void* array)
{
	RJD_ASSERT(array);
	return rjd_array_getheader(array)->allocator;
}

static inline void rjd_array_validate(const void* array)
{
	RJD_ASSERT(array);
	const char* raw = array;
	const struct rjd_array_header* header = (struct rjd_array_header*)(raw - sizeof(struct rjd_array_header));
	RJD_ASSERTMSG(header->debug_sentinel == RJD_ARRAY_DEBUG_SENTINEL32, 
		"Debug sentinel was either corrupted by an underrun or this is not an rjd_array.");
	RJD_UNUSED_PARAM(header);
}

#endif //RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_math.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_MATH_H 1

#define RJD_MATH_PI (3.141592653589793238462643f)
#define RJD_MATH_EPSILON (0.000001)

////////////////////////////////////////////////////////////////////////////////
// utils

static inline uint32_t rjd_math_next_pow2(uint32_t v);
static inline int32_t rjd_math_pow32(int32_t v, uint32_t power);

#define RJD_MATH_DECLARE_SIGN_FUNC(name, type) static inline type name(type v);
#define RJD_MATH_DEFINE_SIGN_FUNC(name, type) static inline type name(type v) { return (v < 0) ? (type)-1 : (type)1; }
#define RJD_MATH_SIGN_FUNCS(xmacro)		\
	xmacro(rjd_math_sign32, int32_t)	\
	xmacro(rjd_math_sign, double)		\
	xmacro(rjd_math_signf, float)
RJD_MATH_SIGN_FUNCS(RJD_MATH_DECLARE_SIGN_FUNC)

#define RJD_MATH_DECLARE_ISEQUAL_FUNC(name, type) static inline bool name(type a, type b);
#define RJD_MATH_DEFINE_ISEQUAL_FUNC(name, type) static inline bool name(type a, type b) { return (type)fabs(a - b) < RJD_MATH_EPSILON; }
#define RJD_MATH_ISEQUAL_FUNCS(xmacro)	\
	xmacro(rjd_math_isequal, double)	\
	xmacro(rjd_math_isequalf, float)
RJD_MATH_ISEQUAL_FUNCS(RJD_MATH_DECLARE_ISEQUAL_FUNC)

#define RJD_MATH_DECLARE_MIN_FUNC(name, type) static inline type name(type a, type b);
#define RJD_MATH_DEFINE_MIN_FUNC(name, type) static inline type name(type a, type b) { return (a < b) ? a : b; }
#define RJD_MATH_MIN_FUNCS(xmacro)		\
	xmacro(rjd_math_min32, int32_t)		\
	xmacro(rjd_math_min64, int64_t)		\
	xmacro(rjd_math_minu32, uint32_t)	\
	xmacro(rjd_math_minu64, uint64_t)
RJD_MATH_MIN_FUNCS(RJD_MATH_DECLARE_MIN_FUNC)

#define RJD_MATH_DECLARE_MAX_FUNC(name, type) static inline type name(type a, type b);
#define RJD_MATH_DEFINE_MAX_FUNC(name, type) static inline type name(type a, type b) { return (a < b) ? b : a; }
#define RJD_MATH_MAX_FUNCS(xmacro)		\
	xmacro(rjd_math_max32, int32_t)		\
	xmacro(rjd_math_max64, uint64_t)	\
	xmacro(rjd_math_maxu64, int64_t)	\
	xmacro(rjd_math_maxu32, uint32_t)
RJD_MATH_MAX_FUNCS(RJD_MATH_DECLARE_MAX_FUNC)

#define RJD_MATH_DECLARE_CLAMP_FUNC(name, type) static inline type name(type v, type minv, type maxv);
#define RJD_MATH_DEFINE_CLAMP_FUNC(name, type) static inline type name(type v, type minv, type maxv) { return (v < minv) ? (minv) : (v > maxv ? maxv : v); }
#define RJD_MATH_CLAMP_FUNCS(xmacro)	\
	xmacro(rjd_math_clamp, double)		\
	xmacro(rjd_math_clampf, float)		\
	xmacro(rjd_math_clamp32, int32_t)	\
	xmacro(rjd_math_clamp64, int64_t)	\
	xmacro(rjd_math_clampu32, uint32_t)	\
	xmacro(rjd_math_clampu64, uint64_t)
RJD_MATH_CLAMP_FUNCS(RJD_MATH_DECLARE_CLAMP_FUNC)

#define RJD_MATH_DECLARE_TRUNCATE_FUNC(name, bigtype, smalltype) static inline smalltype name(bigtype v);
#define RJD_MATH_DEFINE_TRUNCATE_FUNC(name, bigtype, smalltype) static inline smalltype name(bigtype v) { RJD_ASSERT(v <= (smalltype)-1); return (smalltype)v; }
#define RJD_MATH_TRUNCATE_FUNCS(xmacro) 						\
	xmacro(rjd_math_truncate_u64_to_u32, uint64_t, uint32_t)	\
	xmacro(rjd_math_truncate_u64_to_u16, uint64_t, uint16_t)	\
	xmacro(rjd_math_truncate_u64_to_u8,  uint64_t, uint8_t)		\
	xmacro(rjd_math_truncate_u32_to_u16, uint32_t, uint16_t)	\
	xmacro(rjd_math_truncate_u32_to_u8,  uint32_t, uint8_t)		\
	xmacro(rjd_math_truncate_u16_to_u8,  uint16_t, uint8_t)
RJD_MATH_TRUNCATE_FUNCS(RJD_MATH_DECLARE_TRUNCATE_FUNC)

#define RJD_MATH_DECLARE_REMAP_FUNC(name, type) static inline type name(type v, type oldmin, type oldmax, type newmin, type newmax);
#define RJD_MATH_DEFINE_REMAP_FUNC(name, type) static inline type name(type v, type oldmin, type oldmax, type newmin, type newmax) { type oldrange = oldmax - oldmin; type newrange = newmax - newmin; return ((v - oldmin) * newrange) / oldrange + newmin; }
#define RJD_MATH_REMAP_FUNCS(xmacro)	\
	xmacro(rjd_math_remap, double)		\
	xmacro(rjd_math_remapf, float)
RJD_MATH_REMAP_FUNCS(RJD_MATH_DECLARE_REMAP_FUNC)

// vector structs

typedef union rjd_math_float2 {
	struct {
		float x;
		float y;
	};
	float v[2];
} rjd_math_float2;

typedef union rjd_math_float3 {
	struct {
		float x;
		float y;
		float z;
	};
	float v[3];
} rjd_math_float3;

typedef union rjd_math_float4 {
	struct {
		float x;
		float y;
		float z;
		float w;
	};
	float v[4];
} rjd_math_float4;

typedef struct rjd_math_float16 {
	float v[16];
} rjd_math_float16;

typedef struct rjd_math_vec3 {
	__m128 v;
} rjd_math_vec3;

typedef struct rjd_math_vec4 {
	__m128 v;
} rjd_math_vec4;

// column-major 4x4 matrix
typedef struct {
	rjd_math_vec4 m[4];
} rjd_math_mat4;

// float structs are mainly intended for convenience tranlations out of __m128 registers

static inline rjd_math_float2 rjd_math_float2_xy(float x, float y);
static inline rjd_math_float3 rjd_math_float3_xyz(float x, float y, float z);
static inline rjd_math_float4 rjd_math_float4_xyzw(float x, float y, float z, float w);

static inline rjd_math_vec3 rjd_math_float2_to_vec3(rjd_math_float2 f, float z);
static inline rjd_math_vec3 rjd_math_float3_to_vec3(rjd_math_float3 f);
static inline rjd_math_vec3 rjd_math_float4_to_vec3(rjd_math_float4 f);

static inline rjd_math_vec4 rjd_math_float2_to_vec4(rjd_math_float2 f, float z, float w);
static inline rjd_math_vec4 rjd_math_float3_to_vec4(rjd_math_float3 f, float w);
static inline rjd_math_vec4 rjd_math_float4_to_vec4(rjd_math_float4 f);

static inline rjd_math_float2 rjd_math_vec3_to_float2(rjd_math_vec3 v);
static inline rjd_math_float3 rjd_math_vec3_to_float3(rjd_math_vec3 v);
static inline rjd_math_float4 rjd_math_vec3_to_float4(rjd_math_vec3 v, float w);

static inline rjd_math_float2 rjd_math_vec4_to_float2(rjd_math_vec4 v);
static inline rjd_math_float3 rjd_math_vec4_to_float3(rjd_math_vec4 v);
static inline rjd_math_float4 rjd_math_vec4_to_float4(rjd_math_vec4 v);

static inline rjd_math_float16 rjd_math_mat4_to_float16(rjd_math_mat4 m);

// vec4

#define rjd_math_vec4_shuffle(v4, x, y, z, w) ((rjd_math_vec4){_mm_shuffle_ps((v4).v, (v4).v, _MM_SHUFFLE(w, z, y, x))})

static inline rjd_math_vec4 rjd_math_vec4_zero(void);
static inline rjd_math_vec4 rjd_math_vec4_xyzw(float x, float y, float z, float w);
static inline rjd_math_vec4 rjd_math_vec4_splat(float v);
static inline rjd_math_vec4 rjd_math_vec4_one(void);
static inline rjd_math_vec4 rjd_math_vec4_setx(rjd_math_vec4 v, float x);
static inline rjd_math_vec4 rjd_math_vec4_sety(rjd_math_vec4 v, float y);
static inline rjd_math_vec4 rjd_math_vec4_setz(rjd_math_vec4 v, float z);
static inline rjd_math_vec4 rjd_math_vec4_setw(rjd_math_vec4 v, float w);
static inline float 		rjd_math_vec4_x(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_y(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_z(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_w(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_sum(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_dot(rjd_math_vec4 a, rjd_math_vec4 b);
static inline float 		rjd_math_vec4_lengthsq(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_length(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_i(rjd_math_vec4 v, size_t index);
static inline float			rjd_math_vec4_hmin(rjd_math_vec4 v);
static inline float			rjd_math_vec4_hmax(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_normalize(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_scale(rjd_math_vec4 v, float s);
static inline rjd_math_vec4 rjd_math_vec4_neg(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_add(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_sub(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_mul(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_div(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_min(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_max(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_project(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_lerp(rjd_math_vec4 a, rjd_math_vec4 b, float t);
static inline bool			rjd_math_vec4_eq(rjd_math_vec4 a, rjd_math_vec4 b);
static inline bool			rjd_math_vec4_ge(rjd_math_vec4 a, rjd_math_vec4 b);
static inline float*		rjd_math_vec4_write(rjd_math_vec4 v, float* out);

// vec3

#define rjd_math_vec3_shuffle(v3, x, y, z) ((rjd_math_vec3){_mm_shuffle_ps((v3).v, (v3).v, _MM_SHUFFLE(3, z, y, x))})

static inline rjd_math_vec3 rjd_math_vec3_zero(void);
static inline rjd_math_vec3 rjd_math_vec3_xyz(float x, float y, float z);
static inline rjd_math_vec3 rjd_math_vec3_splat(float v);
static inline rjd_math_vec3 rjd_math_vec3_one(void);
static inline rjd_math_vec3 rjd_math_vec3_up(void);
static inline rjd_math_vec3 rjd_math_vec3_down(void);
static inline rjd_math_vec3 rjd_math_vec3_left(void);
static inline rjd_math_vec3 rjd_math_vec3_right(void);
static inline rjd_math_vec3 rjd_math_vec3_forward(void);
static inline rjd_math_vec3 rjd_math_vec3_back(void);
static inline rjd_math_vec3 rjd_math_vec3_yzx(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_zxy(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_setx(rjd_math_vec3 v, float x);
static inline rjd_math_vec3 rjd_math_vec3_sety(rjd_math_vec3 v, float y);
static inline rjd_math_vec3 rjd_math_vec3_setz(rjd_math_vec3 v, float z);
static inline float 		rjd_math_vec3_x(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_y(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_z(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_sum(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_dot(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float 		rjd_math_vec3_angle(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float 		rjd_math_vec3_lengthsq(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_length(rjd_math_vec3 v);
static inline float			rjd_math_vec3_hmin(rjd_math_vec3 v);
static inline float			rjd_math_vec3_hmax(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_normalize(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_scale(rjd_math_vec3 v, float s);
static inline rjd_math_vec3 rjd_math_vec3_neg(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_add(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_sub(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_mul(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_div(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_cross(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_min(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_max(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_project(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_reflect(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_lerp(rjd_math_vec3 a, rjd_math_vec3 b, float t);
static inline bool			rjd_math_vec3_eq(rjd_math_vec3 a, rjd_math_vec3 b);
static inline bool			rjd_math_vec3_ge(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float*		rjd_math_vec3_write(rjd_math_vec3 v, float* out);
static inline float*		rjd_math_vec3_writefast(rjd_math_vec3 v, float* out); // writes 4 floats to out

// mat4

static inline rjd_math_mat4 rjd_math_mat4_identity(void);
static inline rjd_math_mat4 rjd_math_mat4_translation(rjd_math_vec3 trans);
//static inline rjd_math_mat4 rjd_math_mat4_rotation(rjd_math_quat rot); // TODO quaternions
static inline rjd_math_mat4 rjd_math_mat4_angleaxis(float angle, rjd_math_vec3 axis);
static inline rjd_math_mat4 rjd_math_mat4_rotationx(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationy(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationz(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationbasis(rjd_math_vec3 x, rjd_math_vec3 y, rjd_math_vec3 z);
static inline rjd_math_mat4 rjd_math_mat4_scaling(float scale);
static inline rjd_math_mat4 rjd_math_mat4_scaling_nonuniform(rjd_math_vec3 scale);
static inline rjd_math_mat4 rjd_math_mat4_add(rjd_math_mat4 a, rjd_math_mat4 b);
static inline rjd_math_mat4 rjd_math_mat4_mul(rjd_math_mat4 a, rjd_math_mat4 b);
static inline rjd_math_vec3 rjd_math_mat4_mulv3(rjd_math_mat4 m, rjd_math_vec3 v);
static inline rjd_math_vec4 rjd_math_mat4_mulv4(rjd_math_mat4 m, rjd_math_vec4 v);
static inline rjd_math_mat4 rjd_math_mat4_inv(rjd_math_mat4 m);
static inline rjd_math_mat4 rjd_math_mat4_transpose(rjd_math_mat4 m);
static inline rjd_math_mat4 rjd_math_mat4_frustum(float left, float right, float top, float bot, float near, float far);
static inline rjd_math_mat4 rjd_math_mat4_ortho(float left, float right, float top, float bot, float near, float far);
static inline rjd_math_mat4 rjd_math_mat4_perspective(float y_fov, float aspect, float near, float far);
static inline rjd_math_mat4 rjd_math_mat4_lookat(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up);
static inline float*		rjd_math_mat4_write_colmajor(rjd_math_mat4 m, float* out);
static inline float*		rjd_math_mat4_write_rowmajor(rjd_math_mat4 m, float* out);

// implementation

RJD_MATH_SIGN_FUNCS(RJD_MATH_DEFINE_SIGN_FUNC)
RJD_MATH_ISEQUAL_FUNCS(RJD_MATH_DEFINE_ISEQUAL_FUNC)
RJD_MATH_MIN_FUNCS(RJD_MATH_DEFINE_MIN_FUNC)
RJD_MATH_MAX_FUNCS(RJD_MATH_DEFINE_MAX_FUNC)
RJD_MATH_CLAMP_FUNCS(RJD_MATH_DEFINE_CLAMP_FUNC)
RJD_MATH_TRUNCATE_FUNCS(RJD_MATH_DEFINE_TRUNCATE_FUNC)
RJD_MATH_REMAP_FUNCS(RJD_MATH_DEFINE_REMAP_FUNC)

static inline uint32_t rjd_math_next_pow2(uint32_t v) 
{
	--v;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;

	return v;
}

static inline int32_t rjd_math_pow32(int32_t v, uint32_t power)
{
	int32_t r = 1;
	while (power) {
		r *= v;
		--power;
	}
	return r;
}

// vec <-> float tranlations

static inline rjd_math_float2 rjd_math_float2_xy(float x, float y)
{
	return (rjd_math_float2){{ x, y }};
}
static inline rjd_math_float3 rjd_math_float3_xyz(float x, float y, float z)
{
	return (rjd_math_float3){{ x, y, z }};
}
static inline rjd_math_float4 rjd_math_float4_xyzw(float x, float y, float z, float w)
{
	return (rjd_math_float4){{ x, y, z, w }};
}

static inline rjd_math_vec3 rjd_math_float2_to_vec3(rjd_math_float2 f, float z)
{
	return rjd_math_vec3_xyz(f.x, f.y, z);
}
static inline rjd_math_vec3 rjd_math_float3_to_vec3(rjd_math_float3 f)
{
	return rjd_math_vec3_xyz(f.x, f.y, f.z);
}
static inline rjd_math_vec3 rjd_math_float4_to_vec3(rjd_math_float4 f)
{
	return rjd_math_vec3_xyz(f.x, f.y, f.z);
}

static inline rjd_math_vec4 rjd_math_float2_to_vec4(rjd_math_float2 f, float z, float w)
{
	return rjd_math_vec4_xyzw(f.x, f.y, z, w);
}
static inline rjd_math_vec4 rjd_math_float3_to_vec4(rjd_math_float3 f, float w)
{
	return rjd_math_vec4_xyzw(f.x, f.y, f.z, w);
}
static inline rjd_math_vec4 rjd_math_float4_to_vec4(rjd_math_float4 f)
{
	return rjd_math_vec4_xyzw(f.x, f.y, f.z, f.w);
}

static inline rjd_math_float2 rjd_math_vec3_to_float2(rjd_math_vec3 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec3_writefast(v, f.v);
	return (rjd_math_float2){ .x = f.x, .y = f.y };
}
static inline rjd_math_float3 rjd_math_vec3_to_float3(rjd_math_vec3 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec3_writefast(v, f.v);
	return (rjd_math_float3){ .x = f.x, .y = f.y, .z = f.z };
}
static inline rjd_math_float4 rjd_math_vec3_to_float4(rjd_math_vec3 v, float w)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec3_writefast(v, f.v);
	f.w = w;
	return f;
}

static inline rjd_math_float2 rjd_math_vec4_to_float2(rjd_math_vec4 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec4_write(v, f.v);
	return (rjd_math_float2){ .x = f.x, .y = f.y };
}
static inline rjd_math_float3 rjd_math_vec4_to_float3(rjd_math_vec4 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec4_write(v, f.v);
	return (rjd_math_float3){ .x = f.x, .y = f.y, .z = f.z };
}
static inline rjd_math_float4 rjd_math_vec4_to_float4(rjd_math_vec4 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec4_write(v, f.v);
	return f;
}

static inline rjd_math_float16 rjd_math_mat4_to_float16(rjd_math_mat4 m)
{
	RJD_FORCE_ALIGN(rjd_math_float16, 16) f;
	rjd_math_mat4_write_colmajor(m, f.v);
	return f;
}

// vec3 <-> vec4 conversion helpers

static inline rjd_math_vec4 rjd_math_vec3to4(rjd_math_vec3 v3) {
	rjd_math_vec4 v4 = { v3.v };
	return v4;
}

static inline rjd_math_vec3 rjd_math_vec4to3(rjd_math_vec4 v4) {
	rjd_math_vec3 v3 = { v4.v };
	return v3;
}

static inline rjd_math_vec4 rjd_math_vec3to4w(rjd_math_vec3 v3, float w) {
	rjd_math_vec4 v4 = rjd_math_vec3to4(v3);
	return rjd_math_vec4_setw(v4, w);
}

static inline rjd_math_vec3 rjd_math_vec4to3w(rjd_math_vec4 v4) {
	v4 = rjd_math_vec4_setw(v4, 0);
	return rjd_math_vec4to3(v4);
}

// vec4

static inline rjd_math_vec4 rjd_math_vec4_zero(void) {
	rjd_math_vec4 v = { _mm_setzero_ps() };
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_xyzw(float x, float y, float z, float w) {
	rjd_math_vec4 v = { _mm_set_ps(w, z, y, x) }; 
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_splat(float f) {
	rjd_math_vec4 v = { _mm_set1_ps(f) };
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_one(void) {
	return rjd_math_vec4_splat(1);
}
static inline rjd_math_vec4 rjd_math_vec4_setx(rjd_math_vec4 v, float x) {
	v.v = _mm_move_ss(v.v, rjd_math_vec4_splat(x).v);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_sety(rjd_math_vec4 v, float y) {
	v = rjd_math_vec4_shuffle(v, 1, 0, 2, 3);
	v = rjd_math_vec4_setx(v, y);
	v = rjd_math_vec4_shuffle(v, 1, 0, 2, 3);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_setz(rjd_math_vec4 v, float z) {
	v = rjd_math_vec4_shuffle(v, 2, 1, 0, 3);
	v = rjd_math_vec4_setx(v, z);
	v = rjd_math_vec4_shuffle(v, 2, 1, 0, 3);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_setw(rjd_math_vec4 v, float w) {
	v = rjd_math_vec4_shuffle(v, 3, 1, 2, 0);
	v = rjd_math_vec4_setx(v, w);
	v = rjd_math_vec4_shuffle(v, 3, 1, 2, 0);
	return v;
}
static inline float rjd_math_vec4_x(rjd_math_vec4 v) {
	return _mm_cvtss_f32(v.v);
}
static inline float rjd_math_vec4_y(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 1, 0, 2, 3));
}
static inline float rjd_math_vec4_z(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 2, 1, 0, 3));
}
static inline float rjd_math_vec4_w(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 3, 1, 2, 0));
}
static inline float rjd_math_vec4_sum(rjd_math_vec4 v) {
	v.v = _mm_hadd_ps(v.v, v.v);
	v.v = _mm_hadd_ps(v.v, v.v);
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_dot(rjd_math_vec4 a, rjd_math_vec4 b) {
	rjd_math_vec4 product = rjd_math_vec4_mul(a,b);
	return rjd_math_vec4_sum(product);
}
static inline float rjd_math_vec4_lengthsq(rjd_math_vec4 v) {
	return rjd_math_vec4_dot(v, v);
}
static inline float rjd_math_vec4_length(rjd_math_vec4 v) {
	return sqrtf(rjd_math_vec4_lengthsq(v));
}
static inline float rjd_math_vec4_hmin(rjd_math_vec4 v) {
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,1,1,2,3));
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,2,1,2,3));
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,3,1,2,3));
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_hmax(rjd_math_vec4 v) {
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,1,1,2,3));
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,2,1,2,3));
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,3,1,2,3));
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_i(rjd_math_vec4 v, size_t index) {
	switch(index) {
		case 0:	v = rjd_math_vec4_shuffle(v,0,0,0,0); break;
		case 1:	v = rjd_math_vec4_shuffle(v,1,1,1,1); break;
		case 2:	v = rjd_math_vec4_shuffle(v,2,2,2,2); break;
		case 3:	v = rjd_math_vec4_shuffle(v,3,3,3,3); break;
		default:
			RJD_ASSERTFAIL("index must be between 0 and 3");
			break;
	}
	return rjd_math_vec4_x(v);
}
static inline rjd_math_vec4 rjd_math_vec4_normalize(rjd_math_vec4 v) {
	float length = rjd_math_vec4_length(v);
	RJD_ASSERT(length != 0);
	rjd_math_vec4 l = rjd_math_vec4_splat(length);
	return rjd_math_vec4_div(v, l);
}
static inline rjd_math_vec4 rjd_math_vec4_scale(rjd_math_vec4 v, float s) {
	rjd_math_vec4 scales = rjd_math_vec4_splat(s);
	return rjd_math_vec4_mul(v, scales);
}
static inline rjd_math_vec4 rjd_math_vec4_neg(rjd_math_vec4 v) {
	return rjd_math_vec4_scale(v, -1);
}
static inline rjd_math_vec4 rjd_math_vec4_add(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_add_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_sub(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_sub_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_mul(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_mul_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_div(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_div_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_min(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_min_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_max(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_max_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_project(rjd_math_vec4 a, rjd_math_vec4 b) {
	float dot = rjd_math_vec4_dot(a, b);
	float lb = rjd_math_vec4_length(b);
	return rjd_math_vec4_scale(b, dot / lb);
}
static inline rjd_math_vec4 rjd_math_vec4_lerp(rjd_math_vec4 a, rjd_math_vec4 b, float t) {
	rjd_math_vec4 v = rjd_math_vec4_sub(b, a);
	v = rjd_math_vec4_scale(v, t);
	v = rjd_math_vec4_add(v, a);
	return v;
}
static inline bool rjd_math_vec4_eq(rjd_math_vec4 a, rjd_math_vec4 b) {
	return (_mm_movemask_ps(_mm_cmpeq_ps(a.v, b.v)) & 0xF) == 0xF;
}
static inline bool rjd_math_vec4_ge(rjd_math_vec4 a, rjd_math_vec4 b) {
	return (_mm_movemask_ps(_mm_cmpge_ps(a.v, b.v)) & 0xF) == 0xF;
}
static inline float* rjd_math_vec4_write(rjd_math_vec4 v, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out,  v.v);
	return out + 4;
}

// vec3

static inline rjd_math_vec3 rjd_math_vec3_zero(void) { 
	return rjd_math_vec4to3(rjd_math_vec4_zero());
}
static inline rjd_math_vec3 rjd_math_vec3_xyz(float x, float y, float z) {
	return rjd_math_vec4to3(rjd_math_vec4_xyzw(x,y,z,0));
}
static inline rjd_math_vec3 rjd_math_vec3_splat(float v) { return rjd_math_vec3_xyz(v,v,v); }
static inline rjd_math_vec3 rjd_math_vec3_one(void) { return rjd_math_vec3_xyz(1,1,1); }
static inline rjd_math_vec3 rjd_math_vec3_up(void) { return rjd_math_vec3_xyz(0,1,0); }
static inline rjd_math_vec3 rjd_math_vec3_down(void) { return rjd_math_vec3_xyz(0,-1,0); }
static inline rjd_math_vec3 rjd_math_vec3_left(void) { return rjd_math_vec3_xyz(-1,0,0); }
static inline rjd_math_vec3 rjd_math_vec3_right(void) { return rjd_math_vec3_xyz(1,0,0); }
static inline rjd_math_vec3 rjd_math_vec3_forward(void) { return rjd_math_vec3_xyz(0,0,1); }
static inline rjd_math_vec3 rjd_math_vec3_back(void) { return rjd_math_vec3_xyz(0,0,-1); }
static inline rjd_math_vec3 rjd_math_vec3_yzx(rjd_math_vec3 v) {
	return rjd_math_vec3_shuffle(v, 1, 2, 0);
}
static inline rjd_math_vec3 rjd_math_vec3_zxy(rjd_math_vec3 v) {
	return rjd_math_vec3_shuffle(v, 2, 0, 1);
}
static inline rjd_math_vec3 rjd_math_vec3_setx(rjd_math_vec3 v, float x) {
	v.v = _mm_move_ss(v.v, rjd_math_vec3_splat(x).v);
	return v;
}
static inline rjd_math_vec3 rjd_math_vec3_sety(rjd_math_vec3 v, float y) {
	return rjd_math_vec4to3(rjd_math_vec4_sety(rjd_math_vec3to4(v), y));
}
static inline rjd_math_vec3 rjd_math_vec3_setz(rjd_math_vec3 v, float z) {
	return rjd_math_vec4to3(rjd_math_vec4_setz(rjd_math_vec3to4(v), z));
}
static inline float rjd_math_vec3_x(rjd_math_vec3 v) {
	return rjd_math_vec4_x(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_y(rjd_math_vec3 v) {
	return rjd_math_vec4_y(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_z(rjd_math_vec3 v) {
	return rjd_math_vec4_z(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_sum(rjd_math_vec3 v) {
	return rjd_math_vec4_sum(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_dot(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4_dot(rjd_math_vec3to4(a), rjd_math_vec3to4(b));
}
static inline float rjd_math_vec3_angle(rjd_math_vec3 a, rjd_math_vec3 b) {
	float dot = rjd_math_vec3_dot(a, b);
	float la = rjd_math_vec3_length(a);
	float lb = rjd_math_vec3_length(b);
	return acosf(dot / (la * lb));
}
static inline float rjd_math_vec3_lengthsq(rjd_math_vec3 v) {
	return rjd_math_vec4_lengthsq(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_length(rjd_math_vec3 v) {
	return rjd_math_vec4_length(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_hmin(rjd_math_vec3 v) {
	v = rjd_math_vec3_min(v, rjd_math_vec3_shuffle(v,1,1,2));
	v = rjd_math_vec3_min(v, rjd_math_vec3_shuffle(v,2,1,2));
	return rjd_math_vec3_x(v);
}
static inline float rjd_math_vec3_hmax(rjd_math_vec3 v) {
	v = rjd_math_vec3_max(v, rjd_math_vec3_shuffle(v,1,1,2));
	v = rjd_math_vec3_max(v, rjd_math_vec3_shuffle(v,2,1,2));
	return rjd_math_vec3_x(v);
}
static inline rjd_math_vec3 rjd_math_vec3_normalize(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_normalize(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_scale(rjd_math_vec3 v, float s) {
	return rjd_math_vec4to3(rjd_math_vec4_scale(rjd_math_vec3to4(v), s));
}
static inline rjd_math_vec3 rjd_math_vec3_neg(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_neg(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_add(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_add(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_sub(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_sub(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_mul(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_mul(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_div(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_div(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_cross(rjd_math_vec3 a, rjd_math_vec3 b) {
	rjd_math_vec3 ap = rjd_math_vec3_mul(rjd_math_vec3_yzx(a), rjd_math_vec3_zxy(b));
	rjd_math_vec3 bp = rjd_math_vec3_mul(rjd_math_vec3_zxy(a), rjd_math_vec3_yzx(b));
	return rjd_math_vec3_sub(ap, bp);
}
static inline rjd_math_vec3 rjd_math_vec3_min(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_min(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_max(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_max(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_project(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_project(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_reflect(rjd_math_vec3 v, rjd_math_vec3 n) {
	RJD_ASSERT(rjd_math_vec3_eq(n, rjd_math_vec3_normalize(n)));
	rjd_math_vec3 projected = rjd_math_vec3_scale(n, 2 * rjd_math_vec3_dot(v, n));
	return rjd_math_vec3_sub(v, projected);
}
static inline rjd_math_vec3 rjd_math_vec3_lerp(rjd_math_vec3 a, rjd_math_vec3 b, float t) {
	return rjd_math_vec4to3(rjd_math_vec4_lerp(rjd_math_vec3to4(a), rjd_math_vec3to4(b), t));
}
static inline bool rjd_math_vec3_eq(rjd_math_vec3 a, rjd_math_vec3 b) {
	return (_mm_movemask_ps(_mm_cmpeq_ps(a.v, b.v)) & 7) == 7; // 7 is the platform-independent version of 0b111
}
static inline bool rjd_math_vec3_ge(rjd_math_vec3 a, rjd_math_vec3 b) {
	return (_mm_movemask_ps(_mm_cmpge_ps(a.v, b.v)) & 7) == 7;
}
static inline float* rjd_math_vec3_write(rjd_math_vec3 v, float* out) {
	RJD_FORCE_ALIGN(float, 16) tmp[4];
	_mm_stream_ps(tmp, v.v);
	memcpy(out, tmp, sizeof(float) * 3);
	return out + 3;
}
static inline float* rjd_math_vec3_writefast(rjd_math_vec3 v, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out, v.v);
	return out + 3;
}

// mat4

static inline rjd_math_mat4 rjd_math_mat4_identity(void) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(1,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,1,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,1,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_translation(rjd_math_vec3 trans) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(1,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,1,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,1,0);
	m.m[3] = rjd_math_vec3to4w(trans, 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_angleaxis(float angle, rjd_math_vec3 axis) {
	rjd_math_mat4 m;

	// TODO optimize
	float c = cosf(angle);
	float k = 1 - c;
	float s = sinf(angle);

	float x = rjd_math_vec3_x(axis);
	float y = rjd_math_vec3_y(axis);
	float z = rjd_math_vec3_z(axis);

	//rjd_math_vec4 axis4 = rjd_math_vec3to4w(axis,1); // x,y,z,1
	//rjd_math_vec4 tmp1 = rjd_math_vec4_mul(axis4, rjd_math_vec4_xyzw(s,s,s,c)); // x*s, y*s, z*s, c
	//rjd_math_vec4 vk = rjd_math_vec4_splat(k);

	//rjd_math_vec4 v0 = rjd_math_vec4_mul(axis4, rjd_math_vec4_shuffle(axis4,0,0,0,3));
	//v0 = rjd_math_vec4_mul(v0, vk);

	//v0 = rjd_math_vec4_add(v0, rjd_math_vec4_shuffle(tmp1,3,2,1));

	//m.m[0] = 


	//vec3 diagonal = rjd_math_vec3_mul(axis, axis);
	//diagonal = rjd_math_vec3_mul(diagonal, veck);
	//diagonal = rjd_math_vec3_add(diagonal, rjd_math_vec3_splat(c));
	
	float m00 = k*x*x + c;
	float m10 = k*x*y + z*s;
	float m20 = k*x*z - y*s;

	float m01 = k*x*y - z*s;
	float m11 = k*y*y + c;
	float m21 = k*y*z + x*s;

	float m02 = k*x*z + y*s;
	float m12 = k*y*z - x*s;
	float m22 = k*z*z + c;

	m.m[0] = rjd_math_vec4_xyzw(m00, m10, m20, 0);
	m.m[1] = rjd_math_vec4_xyzw(m01, m11, m21, 0);
	m.m[2] = rjd_math_vec4_xyzw(m02, m12, m22, 0);
	m.m[3] = rjd_math_vec4_xyzw(  0,   0,   0, 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_rotationx(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_right());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationy(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_up());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationz(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_forward());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationbasis(rjd_math_vec3 x, rjd_math_vec3 y, rjd_math_vec3 z) {
	rjd_math_vec4 xx = rjd_math_vec3to4(x);
	rjd_math_vec4 yy = rjd_math_vec3to4(y);
	rjd_math_vec4 zz = rjd_math_vec3to4(z);
	rjd_math_mat4 m = { { xx, yy, zz, rjd_math_vec4_xyzw(0,0,0,1) } };
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_scaling(float s) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(s,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,s,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,s,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_scaling_nonuniform(rjd_math_vec3 scale) {
	float x = rjd_math_vec3_x(scale);
	float y = rjd_math_vec3_y(scale);
	float z = rjd_math_vec3_z(scale);

	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(x,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,y,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,z,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_add(rjd_math_mat4 a, rjd_math_mat4 b) {
    rjd_math_mat4 m = {0};
	for (size_t i = 0; i < rjd_countof(m.m); ++i) {
		m.m[i] = rjd_math_vec4_add(a.m[i], b.m[i]);
	}
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_mul(rjd_math_mat4 a, rjd_math_mat4 b) {
	rjd_math_mat4 t = rjd_math_mat4_transpose(a);
    rjd_math_mat4 m = {0};
	for (size_t i = 0; i < rjd_countof(m.m); ++i) {
		m.m[i] = rjd_math_mat4_mulv4(t, b.m[i]);
	}
	return m;
}
static inline rjd_math_vec3 rjd_math_mat4_mulv3(rjd_math_mat4 m, rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_mat4_mulv4(m, rjd_math_vec3to4w(v, 1)));
}
static inline rjd_math_vec4 rjd_math_mat4_mulv4(rjd_math_mat4 m, rjd_math_vec4 v) {
	// TODO optimize
	float x = rjd_math_vec4_dot(m.m[0], v);
	float y = rjd_math_vec4_dot(m.m[1], v);
	float z = rjd_math_vec4_dot(m.m[2], v);
	float w = rjd_math_vec4_dot(m.m[3], v);
	return rjd_math_vec4_xyzw(x, y, z, w);
}
static inline rjd_math_mat4 rjd_math_mat4_inv(rjd_math_mat4 m) {
	rjd_math_mat4 t = rjd_math_mat4_transpose(m);
	rjd_math_vec4 t0 = t.m[0];
	rjd_math_vec4 t1 = t.m[1];
	rjd_math_vec4 t2 = t.m[2];
	rjd_math_vec4 t3 = t.m[3];
	
	rjd_math_mat4 inv;
	rjd_math_vec4 term;

	// first column
	//inv0.x = m11m22m33 + m12m23m31 + m13m21m32 - m11m23m32 - m12m21m33 - m13m22m31;
	//inv0.y = m10m23m32 + m12m20m33 + m13m22m30 - m10m22m33 - m12m23m30 - m13m20m32;
	//inv0.z = m10m21m31 + m11m23m30 + m13m20m31 - m10m23m30 - m11m20m33 - m13m21m30;
	//inv0.w = m10m22m31 + m11m20m32 + m12m21m30 - m10m21m32 - m11m22m30 - m12m20m31;
	//																		x		  y			z		  w
	term = rjd_math_vec4_shuffle(t1,1,0,0,0);							// m11,		 m10,      m10,      m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); 	// m11m22,   m10m23,   m10m21,   m10m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,1,1)); 	// m11m22m33,m10m23m32,m10m21m31,m10m22m31
	inv.m[0] = term;

	term = rjd_math_vec4_shuffle(t1,2,2,1,1);							// m12,      m12,      m11,      m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); 	// m12m23,   m12m20,   m11m23,   m11m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); 	// m12m23m31,m12m20m33,m11m23m30,m11m20m32
	inv.m[0] = rjd_math_vec4_add(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,3,3,3,2);							// m13,      m13,      m13,      m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); 	// m13m21,   m13m22,   m13m20,   m12m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,1,1)); 	// m13m21m32,m13m22m30,m13m20m31,m12m21m30
	inv.m[0] = rjd_math_vec4_add(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,1,0,0,0);							// m11,      m10,      m10,      m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); 	// m11m23,   m10m22,   m10m23,   m10m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,0,2)); 	// m11m23m32,m10m22m33,m10m23m30,m10m21m32
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,2,2,1,1);							// m12,      m12,      m11,      m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); 	// m12m21,   m12m23,   m11m20,   m11m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); 	// m12m21m33,m12m23m30,m11m20m33,m11m22m30
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,3,3,3,2);							// m13,      m13,      m13,      m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); 	// m13m22,   m13m20,   m13m21,   m12m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,2,0,1)); 	// m13m22m31,m13m20m32,m13m21m30,m12m20m31
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	// second column
	// inv.m[1].x = m01m23m32 + m02m21m33 + m03m22m31 - m01m22m33 - m02m23m31 - m03m21m32
	// inv.m[1].y = m00m22m33 + m02m23m30 + m03m20m30 - m00m23m32 - m02m20m33 - m03m22m30
	// inv.m[1].z = m00m23m31 + m01m20m33 + m03m21m30 - m00m21m33 - m01m23m30 - m03m20m31
	// inv.m[1].w = m00m21m32 + m01m22m30 + m02m20m31 - m00m22m31 - m01m20m32 - m02m21m30
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                         // m01,      m00,      m00,      m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); // m01m23,   m00m22,   m00m23,   m00m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,1,2)); // m01m23m32,m00m22m33,m00m23m31,m00m21m32
	inv.m[1] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                         // m02,      m02,      m01,      m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); // m02m21,   m02m23,   m01m20,   m01m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); // m02m21m33,m02m23m30,m01m20m33,m01m22m30
	inv.m[1] = rjd_math_vec4_add(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                         // m03,      m03,      m03,      m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); // m03m22,   m03m20,   m03m21,   m02m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,0,0,1)); // m03m22m31,m03m20m30,m03m21m30,m02m20m31
	inv.m[1] = rjd_math_vec4_add(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                         // m01,      m00,      m00,      m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); // m01m22,   m00m23,   m00m21,   m00m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,3,1)); // m01m22m33,m00m23m32,m00m21m33,m00m22m31
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                         // m02,      m02,      m01,      m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); // m02m23,   m02m20,   m01m23,   m01m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); // m02m23m31,m02m20m33,m01m23m30,m01m20m32
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                         // m03,      m03,      m03,      m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,2,0,1)); // m03m21,   m03m22,   m03m20,   m02m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,0,1,0)); // m03m21m32,m03m22m30,m03m20m31,m02m21m30
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	// third column
	// inv.m[2].x = m01m12m33 + m02m13m31 + m03m11m32 - m01m13m32 - m02m11m33 - m03m12m31
	// inv.m[2].y = m00m13m32 + m02m10m33 + m03m12m30 - m00m12m33 - m02m13m30 - m03m10m32
	// inv.m[2].z = m00m11m33 + m01m13m30 + m03m10m31 - m00m13m31 - m01m10m33 - m01m11m30
	// inv.m[2].w = m00m12m31 + m01m10m32 + m02m11m30 - m00m11m32 - m01m12m30 - m02m10m31
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01       m00       m00       m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,3,1,2)); // m01m12    m00m13    m00m11    m00m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,3,1)); // m01m12m33 m00m13m32 m00m11m33 m00m12m31
	inv.m[2] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02       m02       m01       m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,0,3,0)); // m02m13    m02m10    m01m13    m01m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); // m02m13m31 m02m10m33 m01m13m30 m01m10m32
	inv.m[2] = rjd_math_vec4_add(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03       m03       m03       m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,2,0,1)); // m03m11    m03m12    m03m10    m02m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,0,1,0)); // m03m11m32 m03m12m30 m03m10m31 m02m11m30
	inv.m[2] = rjd_math_vec4_add(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01       m00       m00       m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,2,3,1)); // m01m13    m00m12    m00m13    m00m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,1,2)); // m01m13m32 m00m12m33 m00m13m31 m00m11m32
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02       m02       m01       m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,3,0,2)); // m02m11    m02m13    m01m10    m01m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); // m02m11m33 m02m13m30 m01m10m33 m01m12m30
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,3,3,1,2);                          // m03       m03       m01       m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,0,1,0)); // m03m12    m03m10    m01m11    m02m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,2,0,1)); // m03m12m31 m03m10m32 m01m11m30 m02m10m31
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);	

	// fourth column
	// inv.m[3].x = m01m13m22 + m02m11m23 + m03m12m21 - m01m12m23 - m02m13m21 - m03m11m22
	// inv.m[3].y = m00m12m23 + m02m13m20 + m03m10m22 - m00m13m22 - m02m10m23 - m03m12m20
	// inv.m[3].z = m00m13m21 + m01m13m23 + m03m11m20 - m00m11m23 - m01m13m20 - m03m10m21
	// inv.m[3].w = m00m11m22 + m01m12m20 + m02m10m21 - m00m12m21 - m01m10m22 - m02m11m20
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01 m00 m00 m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,2,3,1)); // m01m13 m00m12 m00m13 m00m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); // m01m13m22 m00m12m23 m00m13m21 m00m11m22
	inv.m[3] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02 m02 m01 m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,3,3,2)); // m02m11 m02m13 m01m13 m01m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); // m02m11m23 m02m13m20 m01m13m23 m01m12m20
	inv.m[3] = rjd_math_vec4_add(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03 m03 m03 m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,0,1,0)); // m03m12 m03m10 m03m11 m02m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,2,0,1)); // m03m12m21 m03m10m22 m03m11m20 m02m10m21
	inv.m[3] = rjd_math_vec4_add(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01 m00 m00 m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,3,1,2)); // m01m12 m00m13 m00m11 m00m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); // m01m12m23 m00m13m22 m00m11m23 m00m12m21
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02 m02 m01 m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,0,3,0)); // m02m13 m02m10 m01m13 m01m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); // m02m13m21 m02m10m23 m01m13m20 m01m10m22
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03 m03 m03 m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,2,0,1)); // m03m11 m03m12 m03m10 m02m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); // m03m11m22 m03m12m20 m03m10m21 m02m11m20
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	rjd_math_mat4 trans = rjd_math_mat4_transpose(inv);
	rjd_math_vec4 det = rjd_math_vec4_mul(trans.m[0], m.m[0]);

	det.v = _mm_hadd_ps(det.v, det.v);
	det.v = _mm_hadd_ps(det.v, det.v);
	det = rjd_math_vec4_shuffle(det,0,0,0,0);

	RJD_ASSERTMSG(!rjd_math_isequalf(rjd_math_vec4_x(det), 0), "Matrix is not invertible - if you're not sure, check rjd_math_mat4_det() == 0 beforehand");

	rjd_math_vec4 det_reciprocal = {_mm_rcp_ps(det.v)};

    rjd_math_mat4 out = {0};
	for (size_t i = 0; i < rjd_countof(out.m); ++i) {
		out.m[i] = rjd_math_vec4_mul(det_reciprocal, inv.m[i]);
	}

	// NOTE that intel's implementation is 82 intrinsics while this is at least 140(cofactor) + 9(determinant) + 
	// 		12(transpose) + 12(transpose), but this implementation is more straightforward

	return out;
}
static inline rjd_math_mat4 rjd_math_mat4_transpose(rjd_math_mat4 m) {
	_MM_TRANSPOSE4_PS(m.m[0].v, m.m[1].v, m.m[2].v, m.m[3].v);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_frustum(float left, float right, float top, float bot, float near, float far) {
	RJD_UNUSED_PARAM(left);
	RJD_UNUSED_PARAM(right);
	RJD_UNUSED_PARAM(top);
	RJD_UNUSED_PARAM(bot);
	RJD_UNUSED_PARAM(near);
	RJD_UNUSED_PARAM(far);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_ortho(float left, float right, float top, float bot, float near, float far) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(2 / (right - left), 0, 0, 0);
	m.m[1] = rjd_math_vec4_xyzw(0, 2 / (top - bot), 0, 0);
	m.m[2] = rjd_math_vec4_xyzw(0, 0, -2 / (far - near), 0);
	m.m[3] = rjd_math_vec4_xyzw(-(right+left)/(right-left), -(top+bot)/(top-bot), -(far+near)/(far-near), 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_perspective(float y_fov, float aspect, float near, float far) {
	RJD_UNUSED_PARAM(y_fov);
	RJD_UNUSED_PARAM(aspect);
	RJD_UNUSED_PARAM(near);
	RJD_UNUSED_PARAM(far);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_lookat(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up) {
	rjd_math_vec3 forward = rjd_math_vec3_normalize(rjd_math_vec3_sub(target, eye));
	rjd_math_vec3 left = rjd_math_vec3_normalize(rjd_math_vec3_cross(forward, up));
	up = rjd_math_vec3_normalize(rjd_math_vec3_cross(left, forward));

	rjd_math_mat4 rot = rjd_math_mat4_rotationbasis(left, up, rjd_math_vec3_neg(forward));
	rjd_math_mat4 trans = rjd_math_mat4_translation(rjd_math_vec3_neg(eye));
	return rjd_math_mat4_mul(trans, rjd_math_mat4_transpose(rot));
}
static inline float* rjd_math_mat4_write_colmajor(rjd_math_mat4 m, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out + 0,  m.m[0].v);
	_mm_stream_ps(out + 4,  m.m[1].v);
	_mm_stream_ps(out + 8,  m.m[2].v);
	_mm_stream_ps(out + 12, m.m[3].v);
	return out + 16;
}
static inline float* rjd_math_mat4_write_rowmajor(rjd_math_mat4 m, float* out) {
	rjd_math_mat4 transpose = rjd_math_mat4_transpose(m);
	return rjd_math_mat4_write_colmajor(transpose, out);
}


////////////////////////////////////////////////////////////////////////////////
// rjd_geo.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_GEO_H 1

typedef struct {
	rjd_math_vec4 minmax; // xy is the min, zw is the max
} rjd_geo_rect;

typedef struct {
	rjd_math_vec3 xyr; // z is the radius
} rjd_geo_circle;

typedef struct {
	rjd_math_vec3 min;
	rjd_math_vec3 max;
} rjd_geo_box;

typedef struct {
	rjd_math_vec4 xyzr; // w is the radius
} rjd_geo_sphere;

typedef struct {
	rjd_math_vec3 p;
	rjd_math_vec3 d;
} rjd_geo_ray;

rjd_geo_rect rjd_geo_rect_minmax(float minx, float miny, float maxx, float maxy);
rjd_geo_circle rjd_geo_circle_xyr(float x, float y, float r);
rjd_geo_box rjd_geo_box_minmax(rjd_math_vec3 min,  rjd_math_vec3 max);
rjd_geo_sphere rjd_geo_sphere_xyzr(float x, float y, float z, float r);
rjd_geo_ray rjd_geo_ray_pd(rjd_math_vec3 p,  rjd_math_vec3 d);

bool rjd_geo_point_rect(rjd_math_vec3 p, rjd_geo_rect r);
bool rjd_geo_point_box(rjd_math_vec3 p, rjd_geo_box b);
bool rjd_geo_point_circle(rjd_math_vec3 p, rjd_geo_circle c);
bool rjd_geo_point_sphere(rjd_math_vec3 p, rjd_geo_sphere s);
bool rjd_geo_circle_circle(rjd_geo_circle c1, rjd_geo_circle c2);
bool rjd_geo_circle_rect(rjd_geo_circle c, rjd_geo_rect r);
bool rjd_geo_rect_rect(rjd_geo_rect a, rjd_geo_rect b);
bool rjd_geo_sphere_sphere(rjd_geo_sphere b, rjd_geo_sphere a);
bool rjd_geo_sphere_box(rjd_geo_sphere s, rjd_geo_box b);
bool rjd_geo_box_box(rjd_geo_box a, rjd_geo_box b);
bool rjd_geo_ray_point(rjd_geo_ray r, rjd_math_vec3 p, float* t_out);
bool rjd_geo_ray_sphere(rjd_geo_ray r, rjd_geo_sphere s, float* t_out);
bool rjd_geo_ray_box(rjd_geo_ray r, rjd_geo_box b, float* t_out);
bool rjd_geo_ray_boxfast(rjd_math_vec3 ray_pos, rjd_math_vec3 ray_inv_dir, rjd_geo_box b, float* t_out);

#if RJD_IMPL

rjd_geo_rect rjd_geo_rect_minmax(float minx, float miny, float maxx, float maxy) {
	RJD_ASSERT(minx <= maxx);
	RJD_ASSERT(miny <= maxy);
	rjd_geo_rect r = { rjd_math_vec4_xyzw(minx, miny, maxx, maxy) };
	return r;
}

rjd_geo_circle rjd_geo_circle_xyr(float x, float y, float r) {
	rjd_geo_circle c = { rjd_math_vec3_xyz(x,y,r) };
	return c;
}

rjd_geo_box rjd_geo_box_minmax(rjd_math_vec3 min, rjd_math_vec3 max) {
	rjd_geo_box b = { min, max };
	return b;
}

rjd_geo_sphere rjd_geo_sphere_xyzr(float x, float y, float z, float r) {
	rjd_geo_sphere s = { rjd_math_vec4_xyzw(x,y,z,r) };
	return s;
}

rjd_geo_ray rjd_geo_ray_pd(rjd_math_vec3 p, rjd_math_vec3 d) {
	rjd_geo_ray r = { p, d };
	return r;
}

bool rjd_geo_point_rect(rjd_math_vec3 p, rjd_geo_rect r) {
	rjd_math_vec4 pp = rjd_math_vec3to4(p);
	pp = rjd_math_vec4_shuffle(pp,0,1,0,1); // { x,y,x,y }

	rjd_math_vec4 a = { _mm_unpackhi_ps(pp.v, r.minmax.v) }; // { x maxx y maxy }
	rjd_math_vec4 b = { _mm_unpacklo_ps(pp.v, r.minmax.v) }; // { x minx y miny }
	b = rjd_math_vec4_shuffle(b,1,0,3,2);						 // { minx x miny y }
	
	return rjd_math_vec4_ge(a,b); // { x >= minx, maxx >= x, y >= miny, maxy >= y }
}

bool rjd_geo_point_box(rjd_math_vec3 p, rjd_geo_box b) {
	return rjd_math_vec3_ge(p, b.min) && rjd_math_vec3_ge(b.max, p);
}

bool rjd_geo_point_circle(rjd_math_vec3 p, rjd_geo_circle c) {
	rjd_math_vec3 v = rjd_math_vec3_sub(p, rjd_math_vec3_setz(c.xyr,0));
	return rjd_math_vec3_lengthsq(v) <= powf(rjd_math_vec3_z(c.xyr), 2);
}

bool rjd_geo_point_sphere(rjd_math_vec3 p, rjd_geo_sphere s) {
	rjd_math_vec4 pp = rjd_math_vec3to4(p);
	rjd_math_vec4 v = rjd_math_vec4_sub(pp, rjd_math_vec4_setw(s.xyzr, 0));
	return rjd_math_vec4_lengthsq(v) <= powf(rjd_math_vec4_w(s.xyzr), 2);
}

bool rjd_geo_circle_circle(rjd_geo_circle c1, rjd_geo_circle c2) {
	rjd_math_vec3 v = rjd_math_vec3_setz(rjd_math_vec3_sub(c1.xyr, c2.xyr), 0);
	rjd_math_vec3 added = rjd_math_vec3_add(c1.xyr, c2.xyr);
	rjd_math_vec3 squared = rjd_math_vec3_mul(added, added);
	return rjd_math_vec3_lengthsq(v) <= rjd_math_vec3_z(squared);
}

bool rjd_geo_circle_rect(rjd_geo_circle c, rjd_geo_rect r) {
	rjd_math_vec3 min = rjd_math_vec4to3(r.minmax);
	rjd_math_vec3 max = { _mm_movehl_ps(r.minmax.v, r.minmax.v) };

	rjd_math_vec3 center = rjd_math_vec3_setz(c.xyr, 0);
	rjd_math_vec3 p = rjd_math_vec3_max(min, rjd_math_vec3_min(max, center));
	p = rjd_math_vec3_setz(p, 0);
	return rjd_geo_point_circle(p, c);
}

bool rjd_geo_rect_rect(rjd_geo_rect a, rjd_geo_rect b) {
	rjd_math_vec4 min = { _mm_unpacklo_ps(a.minmax.v, b.minmax.v) }; // a.x, b.x, a.y, b.y
	rjd_math_vec4 max = { _mm_unpackhi_ps(a.minmax.v, b.minmax.v) }; // a.x, b.x, a.y, b.y
	max = rjd_math_vec4_shuffle(max,1,0,3,2); // b.x, a.x, b.y, a.y

	return rjd_math_vec4_ge(max, min);
}

bool rjd_geo_sphere_sphere(rjd_geo_sphere a, rjd_geo_sphere b) {
	rjd_math_vec4 v = rjd_math_vec4_setw(rjd_math_vec4_sub(a.xyzr, b.xyzr), 0);
	rjd_math_vec4 squared = rjd_math_vec4_mul(a.xyzr, b.xyzr);
	return rjd_math_vec4_lengthsq(v) <= rjd_math_vec4_w(squared);
}

bool rjd_geo_sphere_box(rjd_geo_sphere s, rjd_geo_box b) {
	rjd_math_vec3 center = rjd_math_vec4to3w(s.xyzr);
	rjd_math_vec3 p = rjd_math_vec3_max(b.min, rjd_math_vec3_min(b.max, center));
	return rjd_geo_point_sphere(p, s);
}

bool rjd_geo_box_box(rjd_geo_box a, rjd_geo_box b) {
	return rjd_math_vec3_ge(a.max, b.min) && rjd_math_vec3_ge(b.max, a.min);
}

bool rjd_geo_ray_point(rjd_geo_ray r, rjd_math_vec3 p, float* t_out) {
	rjd_math_vec3 to_p = rjd_math_vec3_sub(r.p, p);
	rjd_math_vec3 to_p_normalized = rjd_math_vec3_normalize(to_p);
	if (rjd_math_isequalf(rjd_math_vec3_dot(to_p_normalized, r.d), 1)) {
		return false;
	}

	if (t_out) {
		*t_out = rjd_math_vec3_length(to_p);
	}

	return true;
}

bool rjd_geo_ray_sphere(rjd_geo_ray r, rjd_geo_sphere s, float* t_out) {
	rjd_math_vec3 center = rjd_math_vec4to3w(s.xyzr);
	rjd_math_vec3 r_to_s = rjd_math_vec3_sub(center, r.p);
	float dot = rjd_math_vec3_dot(r.d, r_to_s);
	if (dot < 0) {
		return false;
	}

	rjd_math_vec3 p = rjd_math_vec3_scale(r.d, dot);
	rjd_math_vec3 s_to_p = rjd_math_vec3_sub(p, center);
	bool colliding = rjd_math_vec3_lengthsq(s_to_p) <= powf(rjd_math_vec4_w(s.xyzr), 2);
	if (colliding && t_out) {
		*t_out = dot;
	}

	return colliding;
}

bool rjd_geo_ray_box(rjd_geo_ray r, rjd_geo_box b, float* t_out) {
	rjd_math_vec3 inv_dir = rjd_math_vec3_div(rjd_math_vec3_one(), r.d);

	float t_dummy = FLT_MAX;
	if (!t_out) {
		t_out = &t_dummy;
	}

	return rjd_geo_ray_boxfast(r.p, inv_dir, b, t_out);
}

bool rjd_geo_ray_boxfast(rjd_math_vec3 ray_pos, rjd_math_vec3 ray_inv_dir, rjd_geo_box b, float* t_out) {
	rjd_math_vec3 v0 = rjd_math_vec3_mul(rjd_math_vec3_sub(b.min, ray_pos), ray_inv_dir);
	rjd_math_vec3 v1 = rjd_math_vec3_mul(rjd_math_vec3_sub(b.max, ray_pos), ray_inv_dir);

	rjd_math_vec3 min = rjd_math_vec3_min(v0, v1);
	rjd_math_vec3 max = rjd_math_vec3_max(v0, v1);

	float tmin = rjd_math_vec3_hmax(min);
	float tmax = rjd_math_vec3_hmax(max);

	bool colliding = (tmax >= 0) && (tmax >= tmin) && (tmin <= *t_out);
	if (colliding) {
		*t_out = tmin;
	}
	return colliding;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_easing.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_EASING_H 1

enum rjd_ease_type
{
	RJD_EASE_TYPE_LINE, // linear
	RJD_EASE_TYPE_SINE, // sine
	RJD_EASE_TYPE_CUBE, // cubic
	RJD_EASE_TYPE_QUAD, // quadratic
	RJD_EASE_TYPE_QUAR, // quartic
	RJD_EASE_TYPE_QUIN, // quintic
	RJD_EASE_TYPE_EXPO, // exponential
	RJD_EASE_TYPE_CIRC, // circular
	RJD_EASE_TYPE_BACK, // back
	RJD_EASE_TYPE_ELAS, // elastic
	RJD_EASE_TYPE_BOUN, // bounce
	RJD_EASE_TYPE_MAX,
};

enum rjd_ease_dir
{
	RJD_EASE_DIR_INOUT,
	RJD_EASE_DIR_IN,
	RJD_EASE_DIR_OUT,
	RJD_EASE_DIR_MAX,
};

typedef float (*rjd_ease_func)(float t);

static inline float rjd_ease(float t, enum rjd_ease_type type, enum rjd_ease_dir dir);
static inline float rjd_ease_between(float t, float min, float max, rjd_ease_func f);
static inline float rjd_ease_line(float t);
static inline float rjd_ease_in_sine(float t);
static inline float rjd_ease_in_quad(float t);
static inline float rjd_ease_in_cube(float t);
static inline float rjd_ease_in_quar(float t);
static inline float rjd_ease_in_quin(float t);
static inline float rjd_ease_in_expo(float t);
static inline float rjd_ease_in_circ(float t);
static inline float rjd_ease_in_back(float t);
static inline float rjd_ease_in_elas(float t);
static inline float rjd_ease_in_boun(float t);
static inline float rjd_ease_out_sine(float t);
static inline float rjd_ease_out_quad(float t);
static inline float rjd_ease_out_cube(float t);
static inline float rjd_ease_out_quar(float t);
static inline float rjd_ease_out_quin(float t);
static inline float rjd_ease_out_expo(float t);
static inline float rjd_ease_out_circ(float t);
static inline float rjd_ease_out_back(float t);
static inline float rjd_ease_out_elas(float t);
static inline float rjd_ease_out_boun(float t);
static inline float rjd_ease_inout_sine(float t);
static inline float rjd_ease_inout_quad(float t);
static inline float rjd_ease_inout_cube(float t);
static inline float rjd_ease_inout_quar(float t);
static inline float rjd_ease_inout_quin(float t);
static inline float rjd_ease_inout_expo(float t);
static inline float rjd_ease_inout_circ(float t);
static inline float rjd_ease_inout_back(float t);
static inline float rjd_ease_inout_elas(float t);
static inline float rjd_ease_inout_boun(float t);

// impl

static inline float rjd_ease(float t, enum rjd_ease_type type, enum rjd_ease_dir dir)
{
	switch (dir) {
		case RJD_EASE_DIR_IN: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_in_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_in_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_in_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_in_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_in_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_in_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_in_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_in_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_in_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_in_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		case RJD_EASE_DIR_OUT: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_inout_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_inout_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_inout_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_inout_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_inout_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_inout_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_inout_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_inout_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_inout_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_inout_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		case RJD_EASE_DIR_INOUT: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_inout_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_inout_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_inout_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_inout_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_inout_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_inout_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_inout_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_inout_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_inout_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_inout_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		default: break;
	}

	RJD_ASSERTFAIL("type (%d) or dir (%d) was invalid.\n", type, dir);
	return 0;
}

static inline float rjd_ease_between(float t, float min, float max, rjd_ease_func f) {
	return f(t) * (max - min) + min;
}

static inline float rjd_ease_line(float t) {
	return t;
}

static inline float rjd_ease_in_sine(float t) {
	return sinf((t - 1) * RJD_MATH_PI/2.0f) + 1;
}

static inline float rjd_ease_in_quad(float t) {
	return t*t;
}

static inline float rjd_ease_in_cube(float t) {
	return t*t*t;
}

static inline float rjd_ease_in_quar(float t) {
	return t*t*t*t;
}

static inline float rjd_ease_in_quin(float t) {
	return t*t*t*t*t;
}

static inline float rjd_ease_in_expo(float t) {
	return t == 0 ? t : powf(2, 10*(t - 1));
}

static inline float rjd_ease_in_circ(float t) {
	return -sqrtf(1-t*t) + 1;
}

static inline float rjd_ease_in_back(float t) {
	return t * t * t - t * sinf(t * RJD_MATH_PI);
}

static inline float rjd_ease_in_elas(float t) {
	return sinf(13.0f * RJD_MATH_PI / 2.0f * t) * powf(2, 10 * (t - 1));
}

static inline float rjd_ease_in_boun(float t) {
	return 1 - rjd_ease_out_boun(1 - t);
}

static inline float rjd_ease_out_sine(float t) {
	return sinf(t*RJD_MATH_PI/2.0f);
}

static inline float rjd_ease_out_quad(float t) {
	float tt = t - 1;
	return 1 - (tt * tt);
}

static inline float rjd_ease_out_cube(float t) {
	float tt = t - 1;
	return tt * tt * tt + 1;
}

static inline float rjd_ease_out_quar(float t) {
	float tt = t - 1;
	return 1 - (tt * tt * tt * tt);
}

static inline float rjd_ease_out_quin(float t) {
	float tt = t - 1;
	return tt * tt * tt * tt * tt + 1;
}

static inline float rjd_ease_out_expo(float t) {
	return t == 1 ? t : -powf(2, -10*t) + 1;
}

static inline float rjd_ease_out_circ(float t) {
	float tt = t - 1;
	return sqrtf(1 - tt * tt);
}

static inline float rjd_ease_out_back(float t) {
	float tt = 1 - t;
	return 1 - (tt*tt*tt - tt*sinf(tt*RJD_MATH_PI));
}

static inline float rjd_ease_out_elas(float t) {
	return sinf(-13.0f * RJD_MATH_PI / 2.0f * (t + 1)) * powf(2, -10 * t) + 1;
}

static inline float rjd_ease_out_boun(float t) {
	if (t < 4.0f/11.0f) {
		return 121 * t * t / 16.0f;
	} else if (t < 8.0f/11.0f) {
		return 363.0f/40.0f*t*t - 99.0f/10.0f*t + 17.0f/5.0f;
	} else if (t < 9.0f/10.0f) {
		return 4356.0f/361.0f*t*t - 35442.0f/1805.0f*t + 16061.0f/1805.0f;
	} else {
		return 54.0f/5.0f*t*t - 513.0f/25.0f*t + 268.0f/25.0f;
	}
}

static inline float rjd_ease_inout_sine(float t) {
	return sinf(t*RJD_MATH_PI - RJD_MATH_PI/2.0f) / 2.0f + 0.5f;
}

static inline float rjd_ease_inout_quad(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quad(tt) : rjd_ease_out_quad(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_cube(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_cube(tt) : rjd_ease_out_cube(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_quar(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quar(tt) : rjd_ease_out_quar(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_quin(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quin(tt) : rjd_ease_out_quin(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_expo(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_expo(tt) : rjd_ease_out_expo(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_circ(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_circ(tt) : rjd_ease_out_circ(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_back(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_back(tt) : rjd_ease_out_back(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_elas(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_elas(tt) : rjd_ease_out_elas(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_boun(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_boun(tt) : rjd_ease_out_boun(tt - 1) + 1) / 2;
}

////////////////////////////////////////////////////////////////////////////////
// rjd_strbuf.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_STRBUF_H 1

#ifndef RJD_STRBUF_STATIC_SIZE
	#define RJD_STRBUF_STATIC_SIZE 512
#endif

RJD_STATIC_ASSERT(RJD_STRBUF_STATIC_SIZE > 0);

struct rjd_mem_allocator;

struct rjd_strbuf
{
	struct rjd_mem_allocator* allocator;
	uint32_t length;
	char* heap;
	char stack[RJD_STRBUF_STATIC_SIZE];
};

struct rjd_strbuf rjd_strbuf_init(struct rjd_mem_allocator* allocator);
uint32_t rjd_strbuf_length(const struct rjd_strbuf* buf);
const char* rjd_strbuf_str(const struct rjd_strbuf* buf);
void rjd_strbuf_append(struct rjd_strbuf* buf, const char* format, ...);
void rjd_strbuf_appendv(struct rjd_strbuf* buf, const char* format, va_list args);
void rjd_strbuf_appendl(struct rjd_strbuf* buf, const char* str, uint32_t length);
void rjd_strbuf_free(struct rjd_strbuf* buf);

#define RJD_STRBUF_SCOPED(buffername, allocator, scope)				\
	{																\
		struct rjd_strbuf buffername = rjd_strbuf_init(allocator);	\
		{scope}														\
		rjd_strbuf_free(&buffername);								\
	}

#if RJD_IMPL

static void rjd_strbuf_grow(struct rjd_strbuf* buf, uint32_t format_length);

struct rjd_strbuf rjd_strbuf_init(struct rjd_mem_allocator* allocator)
{
	struct rjd_strbuf buf;
	buf.length = 0;
	buf.heap = 0;
	buf.stack[0] = 0;
	buf.allocator = allocator;

	return buf;
}

const char* rjd_strbuf_str(const struct rjd_strbuf* buf)
{
	RJD_ASSERT(buf);
	return buf->heap ? buf->heap : buf->stack;
}

void rjd_strbuf_append(struct rjd_strbuf* buf, const char* format, ...)
{
	RJD_ASSERT(buf);

	if (!format || *format == '\0') {
		return;
	}

	va_list args;
	va_start(args, format);
		rjd_strbuf_appendv(buf, format, args);
	va_end(args);
}

void rjd_strbuf_appendv(struct rjd_strbuf* buf, const char* format, va_list args)
{
	RJD_ASSERT(buf);

	if (!format || *format == '\0') {
		return;
	}

	uint32_t capacity = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t remaining = capacity - buf->length;
	uint32_t format_length = (uint32_t)strlen(format);

	if (remaining < format_length + 1) {
		rjd_strbuf_grow(buf, format_length);
		remaining = rjd_array_capacity(buf->heap) - buf->length;
	}

	char* str = buf->heap ? buf->heap : buf->stack;
	int written = vsnprintf(str + buf->length, remaining, format, args);
	while (written < 0) {
		rjd_strbuf_grow(buf, 1);
		str = buf->heap;
		written = vsnprintf(str + buf->length, remaining, format, args);
	}

	buf->length += written;
}

void rjd_strbuf_appendl(struct rjd_strbuf* buf, const char* format, uint32_t length)
{
	RJD_ASSERT(buf);
	RJD_ASSERT(format + length <= format + strlen(format));

	if (format == NULL || *format == '\0') {
		return;
	}

	uint32_t capacity = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t remaining = capacity - buf->length;

	if (remaining < length) {
		rjd_strbuf_grow(buf, length);
		remaining = rjd_array_capacity(buf->heap) - buf->length;
	}

	char* str = buf->heap ? buf->heap : buf->stack;
	memcpy(str + buf->length, format, length);
	buf->length += length;
	str[buf->length] = '\0';
}

void rjd_strbuf_free(struct rjd_strbuf* buf)
{
	RJD_ASSERT(buf);

	rjd_array_free(buf->heap);
	buf->length = 0;
	buf->heap = 0;
	buf->stack[0] = '\0';
}

static void rjd_strbuf_grow(struct rjd_strbuf* buf, uint32_t format_length)
{
	RJD_ASSERT(buf);
	RJD_ASSERT(buf->allocator);

	uint32_t current = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t min = current + format_length + 1;
	uint32_t next = rjd_math_next_pow2(min);

	if (!buf->heap) {
		buf->heap = rjd_array_alloc(char, next, buf->allocator);
		rjd_array_resize(buf->heap, next);

		strcpy(buf->heap, buf->stack);
	}
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_profiler.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PROFILER_H 1

struct rjd_timer
{
	double timestamp;
};

struct rjd_timer rjd_timer_init(void);
void rjd_timer_reset(struct rjd_timer* timer);
double rjd_timer_elapsed(const struct rjd_timer* timer);
double rjd_timer_global(void);

#define RJD_PROFILE_SCOPE(name, scope) {									\
		struct rjd_timer _timer##name = rjd_timer_init(); 					\
		{scope}																\
		RJD_LOG("Elapsed %s: %.4fms", #name, rjd_timer_elapsed(&_timer##name));	\
	}

#if RJD_IMPL

struct rjd_timer rjd_timer_init(void)
{
	struct rjd_timer timer;
	rjd_timer_reset(&timer);
	return timer;
}

void rjd_timer_reset(struct rjd_timer* timer)
{
	timer->timestamp = rjd_timer_global();
}

double rjd_timer_elapsed(const struct rjd_timer* timer)
{
	return rjd_timer_global() - timer->timestamp;
}
#if RJD_PLATFORM_WINDOWS
	static double RJD_QPC_FREQUENCY = 0;
	
	double rjd_timer_global(void)
	{
		if (RJD_QPC_FREQUENCY == 0) {
			LARGE_INTEGER frequency = {.QuadPart = 1};
			if (!QueryPerformanceFrequency(&frequency))
			{
				RJD_LOG("Failed to get QueryPerformanceFrequency: %d", GetLastError());
			}
			RJD_QPC_FREQUENCY = (double)frequency.QuadPart;
		}

		LARGE_INTEGER time = { .QuadPart = 0 };
		if (!QueryPerformanceCounter(&time))
		{
			RJD_LOG("Failed to get QueryPerformanceCounter. Time will be incorrect. Error: %d", GetLastError());
		}

		return (time.QuadPart * 1000LL) / RJD_QPC_FREQUENCY;
	}
#endif //RJD_PLATFORM_WINDOWS

#if RJD_PLATFORM_OSX
	#include <mach/mach.h>
	#include <mach/mach_time.h>

	static mach_timebase_info_data_t RJD_MACH_TIMEBASE_INFO;
	double rjd_timer_global(void)
	{
		if (RJD_MACH_TIMEBASE_INFO.denom == 0) {
			int ok = mach_timebase_info(&RJD_MACH_TIMEBASE_INFO);
			if (ok != KERN_SUCCESS) {
				RJD_LOG("Failed to get mach timebase info: %d", ok);
			}
		}

		double time = (double)mach_absolute_time();
		return time * ((double)RJD_MACH_TIMEBASE_INFO.numer / ((double)RJD_MACH_TIMEBASE_INFO.denom)) / 1000000;
	}
#endif // 

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_cmd.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_CMD_H 1

struct rjd_mem_allocator;

struct rjd_cmd_argv
{
	const char* shortname;
	const char* longname;
	const char* argname;
	const char* description;
};

struct rjd_cmd
{
	int argc;
	const char** argv;

	struct rjd_cmd_argv* opts;
	struct rjd_cmd_argv* reqs;

	struct rjd_mem_allocator* allocator;
};

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_mem_allocator* allocator);
void rjd_cmd_free(struct rjd_cmd* cmd);
void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description);
void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description);
bool rjd_cmd_ok(const struct rjd_cmd* cmd);
void rjd_cmd_usage(const struct rjd_cmd* cmd);
void rjd_cmd_help(const struct rjd_cmd* cmd);

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* shortname, int _default);
unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* shortname, unsigned _default);
double rjd_cmd_float(const struct rjd_cmd* cmd, const char* shortname, double _default);
bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* shortname);
const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* shortname);

#if RJD_IMPL

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_mem_allocator* allocator)
{
	struct rjd_cmd cmd = {argc, argv, NULL, NULL, allocator};
	cmd.opts = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);
	cmd.reqs = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);

	rjd_cmd_add_opt(&cmd, "-h", "--help", NULL, "Prints help");
	return cmd;
}

void rjd_cmd_free(struct rjd_cmd* cmd)
{
	rjd_array_free(cmd->opts);
	rjd_array_free(cmd->reqs);
}

void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(shortname);
	RJD_ASSERT(longname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv opt = { shortname, longname, argname, description };
	rjd_array_push(cmd->opts, opt);
}

void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(argname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv req = { NULL, NULL, argname, description };
	rjd_array_push(cmd->reqs, req);
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv);
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd);
static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname);

bool rjd_cmd_ok(const struct rjd_cmd* cmd)
{
	RJD_ASSERT(cmd);

	int count = rjd_array_count(cmd->reqs);
	if (cmd->argc - 1 < count) {
		return false;
	}

	const int firstreq = rjd_cmd_firstreq(cmd);

	for (int i = 1; i < firstreq; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);

		if (!opt) {
			return false;
		}

		if (opt->argname) {
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				// since we're expecting an argument, this shouldn't match any other options
				if (rjd_cmd_matchopt(cmd, cmd->argv[i+1])) {
					return false;
				}
			} else {
				const char* eq = strstr(cmd->argv[i], "=");
				if (!eq) {
					return false;
				}
				const char* arg = eq + 1;
				if (*arg == 0) {
					return false;
				}
			}
			++i;
		}
	}
	
	return (cmd->argc - 1 - firstreq) == (int) rjd_array_count(cmd->reqs);
}

void rjd_cmd_usage(const struct rjd_cmd* cmd)
{
	// TODO rjd_stringbuilder

	size_t offset = 0;

	char optString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		offset += snprintf(optString + offset, sizeof(optString) - offset, "%s", cmd->opts[i].shortname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(optString + offset, sizeof(optString) - offset, " ");
		}
	}
	optString[offset] = 0;

	offset = 0;

	char reqString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		offset += snprintf(reqString + offset, sizeof(reqString) - offset, "%s", cmd->reqs[i].argname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(reqString + offset, sizeof(reqString) - offset, " ");
		}
	}
	reqString[offset] = 0;

	printf("Usage: %s [%s] %s\n", cmd->argv[0], optString, reqString);
}

void rjd_cmd_help(const struct rjd_cmd* cmd) 
{
	rjd_cmd_usage(cmd);

	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		printf("%s\n\t%s\n", cmd->reqs[i].argname, cmd->reqs[i].description);
	}

	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const struct rjd_cmd_argv* arg = cmd->opts + i;
		if (arg->argname) {
			printf("%s %s, %s=%s\n\t%s\n", arg->shortname, arg->argname, arg->longname, arg->argname, arg->description);
		} else {
			printf("%s, %s\n\t%s\n", arg->shortname, arg->longname, arg->description);
		}
	}
}

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* name, int _default)
{
	return (int)rjd_cmd_float(cmd, name, _default);
}

unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* name, unsigned _default)
{
	double v = rjd_cmd_float(cmd, name, _default);
	if (v < 0) {
		return _default;
	}
	return (unsigned)v;
}

double rjd_cmd_float(const struct rjd_cmd* cmd, const char* name, double _default)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return _default;
	}

	char* end = NULL;
	double v = strtod(str, &end);
	if (v == 0 && end != NULL) {
		return _default;
	}
	return v;
}

bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* name)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return false;
	}

	if (!strcmp(str, "true")) {
		return true;
	} else if (!strcmp(str, "false")) {
		return false;
	}

	const struct rjd_cmd_argv* opt = rjd_cmd_getopt(cmd, name);
	return opt && !strcmp(opt->shortname, name);
}

const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* name)
{
	const char* opt = rjd_cmd_findopt(cmd, name);
	if (opt) {
		return opt;
	}

	const char* req = rjd_cmd_findreq(cmd, name);
	if (req) {
		return req;
	}

	return NULL;
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv)
{
	if (!argv) {
		return NULL;
	}

	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const char* shortname = cmd->opts[i].shortname;
		const char* longname = cmd->opts[i].longname;
		if (!strcmp(shortname, argv)) {
			return cmd->opts + i;
		}
		if (strstr(argv, longname) == argv) {
			return cmd->opts + i;
		}
	}

	return NULL;
}
	
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd)
{
	int index = 0;
	for (int i = 1; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt) {
			// skip the argument (assuming the format is ok)
			if (!strcmp(cmd->argv[i], opt->shortname) && opt->argname) {
				++i;
			}
			index = i;
		} else {
			break;
		}
	}

	return index + 1;
}

static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		if (!strcmp(cmd->opts[i].shortname, shortname)) {
			return cmd->opts + i;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (int i = 0; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt && !strcmp(opt->shortname, shortname)) {
			if (!opt->argname) {
				return cmd->argv[i];
			}
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				return cmd->argv[i + 1];
			}
			const char* eq = strstr(cmd->argv[i], "=");
			if (eq) {
				return eq + 1;
			}
			break;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname) 
{
	int reqindex = -1;
	for (int i = 0; i < (int)rjd_array_count(cmd->reqs); ++i) {
		if (!strcmp(cmd->reqs[i].argname, argname)) {
			reqindex = i;
			break;
		}
	}

	if (reqindex == -1) {
		return NULL;
	}

	int optindex = rjd_cmd_firstreq(cmd) - 1; // -1 to get to first opt index

	int argvindex = optindex + reqindex + 1; // +1 to skip exe arg
	RJD_ASSERT(argvindex < cmd->argc);

	return cmd->argv[argvindex];
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_dict.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_DICT_H 1

struct rjd_mem_allocator;

struct rjd_dict
{
	uint32_t count;
	rjd_hash64* hashes;
	void** values;
	struct rjd_mem_allocator* allocator;
};

struct rjd_dict rjd_dict_init(struct rjd_mem_allocator* allocator, size_t initial_capacity);
void rjd_dict_insert(struct rjd_dict* dict, rjd_hash64 hash, void* item);
void* rjd_dict_erase(struct rjd_dict* dict, rjd_hash64 hash);
void* rjd_dict_get(const struct rjd_dict* dict, rjd_hash64 hash);
bool rjd_dict_has(const struct rjd_dict* dict, rjd_hash64 hash);
void rjd_dict_free(struct rjd_dict* dict);

static inline void rjd_dict_insert_hashstr(struct rjd_dict* dict, const char* key, void* item);
static inline void* rjd_dict_erase_hashstr(struct rjd_dict* dict, const char* key);
static inline void* rjd_dict_get_hashstr(const struct rjd_dict* dict, const char* key);
static inline bool rjd_dict_has_hashstr(const struct rjd_dict* dict, const char* key);

static inline void rjd_dict_insert_hashstr(struct rjd_dict* dict, const char* key, void* item)
{
	rjd_dict_insert(dict, rjd_hash64_data((uint8_t*)key, -1), item);
}

static inline void* rjd_dict_erase_hashstr(struct rjd_dict* dict, const char* key)
{
	return rjd_dict_erase(dict, rjd_hash64_data((uint8_t*)key, -1));
}

static inline void* rjd_dict_get_hashstr(const struct rjd_dict* dict, const char* key)
{
	return rjd_dict_get(dict, rjd_hash64_data((uint8_t*)key, -1));
}

static inline bool rjd_dict_has_hashstr(const struct rjd_dict* dict, const char* key)
{
	return rjd_dict_has(dict, rjd_hash64_data((uint8_t*)key, -1));
}

#if RJD_IMPL

enum rjd_dict_findmode
{
	RJD_DICT_FINDMODE_INSERTION,
	RJD_DICT_FINDMODE_EXISTING,
};

static void rjd_dict_grow(struct rjd_dict* dict, size_t capacity);
static int32_t rjd_dict_findindex(const rjd_hash64* hashes, rjd_hash64 hash, enum rjd_dict_findmode mode);
 
struct rjd_dict rjd_dict_init(struct rjd_mem_allocator* allocator, size_t initial_capacity)
{
	RJD_ASSERT(allocator);

	struct rjd_dict dict = { 0, NULL, NULL, allocator };

	if (initial_capacity > 0) {
		rjd_dict_grow(&dict, initial_capacity);
	}

	return dict;
}

void rjd_dict_insert(struct rjd_dict* dict, rjd_hash64 hash, void* value)
{
	RJD_ASSERT(dict);
	RJD_ASSERT(rjd_hash64_valid(hash));

	const float load = dict->hashes ? (dict->count + 1) / (float)rjd_array_capacity(dict->hashes) : 1;
	if (load > 0.6) {
		uint32_t capacity = dict->hashes ? rjd_array_capacity(dict->hashes) * 2 : 32;
		rjd_dict_grow(dict, capacity);
	}

	int32_t i = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_INSERTION);
	RJD_ASSERT(i >= 0);
	RJD_ASSERT(!rjd_hash64_valid(dict->hashes[i]));

	dict->hashes[i] = hash;
	dict->values[i] = value;
	++dict->count;
}

void* rjd_dict_erase(struct rjd_dict* dict, rjd_hash64 hash)
{
	RJD_ASSERT(dict);
	
	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index < 0) {
		return NULL;
	}

	void* v = dict->values[index];

	dict->hashes[index] = rjd_hash64_data(NULL, 0);
	dict->values[index] = NULL;
	--dict->count;

	return v;
}

void* rjd_dict_get(const struct rjd_dict* dict, rjd_hash64 hash)
{
	RJD_ASSERT(dict);

	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index < 0) {
		return NULL;
	}

	return dict->values[index];
}

bool rjd_dict_has(const struct rjd_dict* dict, rjd_hash64 hash)
{
	RJD_ASSERT(dict);

	if (!rjd_hash64_valid(hash)) {
		return false;
	}

	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index >= 0) {
		return rjd_hash64_valid(dict->hashes[index]);
	}

	return false;
}

void rjd_dict_free(struct rjd_dict* dict)
{
	RJD_ASSERT(dict);

	rjd_array_free(dict->hashes);
	rjd_array_free(dict->values);
	dict->hashes = NULL;
	dict->values = NULL;
	dict->count = 0;
}

static void rjd_dict_grow(struct rjd_dict* dict, size_t capacity)
{
	RJD_ASSERT(capacity > 0);
	RJD_ASSERT(dict);

	rjd_hash64* hashes = rjd_array_alloc(rjd_hash64, (uint32_t)capacity, dict->allocator);
	void** values = rjd_array_alloc(void*, (uint32_t)capacity, dict->allocator);

	rjd_array_resize(hashes, (uint32_t)capacity);
	rjd_array_resize(values, (uint32_t)capacity);

	for (uint32_t i = 0; i < rjd_array_count(dict->hashes); ++i) {
		if (rjd_hash64_valid(dict->hashes[i])) {
			int32_t k = rjd_dict_findindex(hashes, dict->hashes[i], RJD_DICT_FINDMODE_INSERTION);
			RJD_ASSERT(k >= 0);
			hashes[k] = dict->hashes[i];
			values[k] = dict->values[i];
		}
	}

	rjd_array_free(dict->hashes);
	rjd_array_free(dict->values);

	dict->hashes = hashes;
	dict->values = values;
}

static int32_t rjd_dict_findindex(const rjd_hash64* hashes, rjd_hash64 hash, enum rjd_dict_findmode mode)
{
	if (!hashes) {
		return -1;
	}

	const uint32_t capacity = rjd_array_capacity(hashes);
	const uint32_t start = hash.value % capacity;
	uint32_t i = start;
	do {
		if (mode == RJD_DICT_FINDMODE_INSERTION && !rjd_hash64_valid(hashes[i])) {
			return (int32_t)i;
		} else if (mode == RJD_DICT_FINDMODE_EXISTING && hashes[i].value == hash.value) {
			return (int32_t)i;
		}

		i = (i + 1) % capacity;
	} while (i != start);

	return -1;
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_fio.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_FILEIO_H 1

#define RJD_FIO_ERR_ENUM(macro) \
	macro(RJD_FIO_ERR_OK)		\
	macro(RJD_FIO_ERR_IO)		\
	macro(RJD_FIO_ERR_NOMEM)
RJD_ENUM_DECLARE(rjd_fio_err, RJD_FIO_ERR_ENUM);

#define RJD_FIO_WRITEMODE_ENUM(macro)	\
	macro(RJD_FIO_WRITEMODE_REPLACE)	\
	macro(RJD_FIO_WRITEMODE_APPEND)
RJD_ENUM_DECLARE(rjd_fio_writemode, RJD_FIO_WRITEMODE_ENUM);

// use rjd_array_free() to free *buffer after use
enum rjd_fio_err rjd_fio_read(const char* path, char** buffer, struct rjd_mem_allocator* context);
enum rjd_fio_err rjd_fio_write(const char* path, const char* data, size_t length, enum rjd_fio_writemode mode);
enum rjd_fio_err rjd_fio_size(const char* path, size_t* out_size);
enum rjd_fio_err rjd_fio_delete(const char* path);

#if RJD_IMPL

RJD_ENUM_DEFINE(rjd_fio_err, RJD_FIO_ERR_ENUM);
RJD_ENUM_DEFINE(rjd_fio_writemode, RJD_FIO_WRITEMODE_ENUM);

enum rjd_fio_err rjd_fio_read(const char* path, char** buffer, struct rjd_mem_allocator* context)
{
	FILE* file = fopen(path, "rb");
	if (!file) {
		return RJD_FIO_ERR_IO;
	}

	if (fseek(file, 0, SEEK_END)) {
		fclose(file);
		return RJD_FIO_ERR_IO;
	}

	long int length = ftell(file);
	if (length < 0) {
		length = 0;
	}

	rewind(file);

	*buffer = rjd_array_alloc(char, (uint32_t)length, context);
	if (!*buffer) {
		return RJD_FIO_ERR_NOMEM;
	}
	rjd_array_resize(*buffer, (uint32_t)length);

	size_t read_length = fread(*buffer, 1, length, file);
	fclose(file);

	if (read_length < (size_t)length) {
		rjd_array_free(*buffer);
		*buffer = NULL;
		return RJD_FIO_ERR_IO;
	}

	return RJD_FIO_ERR_OK;
}

enum rjd_fio_err rjd_fio_write(const char* path, const char* data, size_t length, enum rjd_fio_writemode mode)
{
	const char* m = (mode == RJD_FIO_WRITEMODE_REPLACE) ? "wb" : "ab";
	FILE* file = fopen(path, m);

	size_t written = fwrite(data, 1, length, file);

	fclose(file);

	if (written == 0) {
		return RJD_FIO_ERR_IO;
	} else if (written < length) {
		return RJD_FIO_ERR_IO;
	} else {
		return RJD_FIO_ERR_OK;
	}
}

enum rjd_fio_err rjd_fio_size(const char* path, size_t* out_size)
{
	FILE* file = fopen(path, "rb");
	if (!file) {
		return RJD_FIO_ERR_IO;
	}

	if (fseek(file, 0, SEEK_END)) {
		fclose(file);
		return RJD_FIO_ERR_IO;
	}

	long int length = ftell(file);
	fclose(file);

	*out_size = (size_t) length;
	return RJD_FIO_ERR_OK;
}

enum rjd_fio_err rjd_fio_delete(const char* path)
{
	if (remove(path)) {
		return RJD_FIO_ERR_IO;
	}

	return RJD_FIO_ERR_OK;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_strpool.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_STRPOOL_H 1

struct rjd_strpool
{
	struct rjd_dict storage;
};

struct rjd_strref;

struct rjd_strpool rjd_strpool_init(struct rjd_mem_allocator* allocator, size_t initial_capacity);
void rjd_strpool_free(struct rjd_strpool* pool);
struct rjd_strref* rjd_strpool_add(struct rjd_strpool* pool, const char* fmt, ...);
struct rjd_strref* rjd_strpool_addv(struct rjd_strpool* pool, const char* fmt, va_list args); 
struct rjd_strref* rjd_strpool_addl(struct rjd_strpool* pool, const char* str, size_t length);
void rjd_strref_release(struct rjd_strref* ref);
const char* rjd_strref_str(const struct rjd_strref* ref);
uint32_t rjd_strref_length(const struct rjd_strref* ref);

#if RJD_IMPL

struct rjd_strref
{
	const char* str;
	struct rjd_strpool* owner;
	int32_t refcount;
	uint32_t length;
};

static struct rjd_strref* rjd_strpool_addimpl(struct rjd_strpool* pool, const char* str);

struct rjd_strpool rjd_strpool_init(struct rjd_mem_allocator* allocator, size_t initial_capacity)
{
	RJD_ASSERT(allocator);

	struct rjd_strpool pool = { rjd_dict_init(allocator, initial_capacity * 2) };
	return pool;
}

void rjd_strpool_free(struct rjd_strpool* pool)
{
	RJD_ASSERT(pool);

	void** refs = pool->storage.values;
	for (uint32_t i = 0; i < rjd_array_count(refs); ++i) {
		if (refs[i]) {
			struct rjd_strref* ref = refs[i];
			rjd_mem_free(ref); // struct and string are part of the same allocation block
		}
	}
	rjd_dict_free(&pool->storage);
}

struct rjd_strref* rjd_strpool_add(struct rjd_strpool* pool, const char* format, ...)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	va_list args;
	va_start(args, format);
		ref = rjd_strpool_addv(pool, format, args);
	va_end(args);

	return ref;
}

struct rjd_strref* rjd_strpool_addv(struct rjd_strpool* pool, const char* format, va_list args)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	RJD_STRBUF_SCOPED(buffer, pool->storage.allocator, {
		rjd_strbuf_appendv(&buffer, format, args);
		ref = rjd_strpool_addimpl(pool, rjd_strbuf_str(&buffer));
	});

	return ref;
}

struct rjd_strref* rjd_strpool_addl(struct rjd_strpool* pool, const char* format, size_t length)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	RJD_STRBUF_SCOPED(buffer, pool->storage.allocator, {
		rjd_strbuf_appendl(&buffer, format, (uint32_t)length);
		ref = rjd_strpool_addimpl(pool, rjd_strbuf_str(&buffer));
	});

	return ref;
}

void rjd_strref_release(struct rjd_strref* ref)
{
	RJD_ASSERT(ref);

	struct rjd_strpool* pool = ref->owner;

	rjd_hash64 hash = rjd_hash64_data((const uint8_t*)ref->str, -1);
	RJD_ASSERTMSG(rjd_dict_get(&pool->storage, hash) == ref, "ref was not contained in string pool");

	--ref->refcount;
	if (ref->refcount <= 0) {
		rjd_mem_free(ref); // struct and string are part of the same allocation block
		rjd_dict_erase(&pool->storage, hash);
	}
}

const char* rjd_strref_str(const struct rjd_strref* ref)
{
	RJD_ASSERT(ref);
	return ref->str;
}

uint32_t rjd_strref_length(const struct rjd_strref* ref)
{
	RJD_ASSERT(ref);
	return ref->length;
}

static struct rjd_strref* rjd_strpool_addimpl(struct rjd_strpool* pool, const char* str) 
{
	RJD_ASSERT(pool);
	RJD_ASSERT(str);

	rjd_hash64 hash = rjd_hash64_data((const uint8_t*)str, -1);
	struct rjd_strref* ref = rjd_dict_get(&pool->storage, hash);
	if (!ref) {
		uint8_t* mem = rjd_mem_alloc_array(uint8_t, sizeof(struct rjd_strref) + strlen(str) + 1, pool->storage.allocator);
		ref = (struct rjd_strref*)mem;

		char* copied_str = (char*)(mem + sizeof(struct rjd_strref));
		strcpy(copied_str, str);

		ref->str = copied_str;
		ref->owner = pool;
		ref->refcount = 0;
		ref->length = (uint32_t)strlen(ref->str);

		rjd_dict_insert(&pool->storage, hash, ref);
	}
	++ref->refcount;

	return ref;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_slotmap.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_SLOTMAP_H 1

struct rjd_slot
{
	uint16_t index;
	uint16_t salt;
};

static inline bool rjd_slot_isvalid(struct rjd_slot slot);

#define rjd_slotmap_alloc(type, count, allocator)	(rjd_slotmap_alloc_impl(sizeof(type), count, allocator))
#define rjd_slotmap_insert(map, data, out_slot)		((map) = rjd_slotmap_insert_impl((map), (out_slot)), \
													 (map)[(out_slot)->index] = data)
#define rjd_slotmap_get(map, slot)					((map) + rjd_slotmap_get_impl((map), (slot)))
#define rjd_slotmap_count(map)						(rjd_slotmap_count_impl(map))
#define rjd_slotmap_erase(map, slot)				(rjd_slotmap_erase_impl((map), slot))
#define rjd_slotmap_free(map)						(rjd_slotmap_free_impl(map))
#define rjd_slotmap_next(map, slot)					(rjd_slotmap_next_impl((map), (slot))) // pass null slot for first

void* rjd_slotmap_alloc_impl(size_t sizeof_type, uint32_t count, struct rjd_mem_allocator* allocator);
void* rjd_slotmap_insert_impl(void* map, struct rjd_slot* out_slot);
uint32_t rjd_slotmap_get_impl(const void* map, struct rjd_slot slot);
uint32_t rjd_slotmap_count_impl(const void* map);
void rjd_slotmap_erase_impl(void* map, struct rjd_slot slot);
void rjd_slotmap_free_impl(void* map);
struct rjd_slot rjd_slotmap_next_impl(void* map, const struct rjd_slot* slot);

static inline bool rjd_slot_isvalid(struct rjd_slot slot)
{
	return slot.salt != 0;
}

#if RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// private interface

struct rjd_slotmap_header
{
	struct rjd_mem_allocator* allocator;
	void* data;
	uint16_t* salts;
	bool* used;
	uint32_t* freelist;
	uint32_t sizeof_type;
	uint32_t count;
	uint32_t debug_sentinel;
};

enum {
	RJD_SLOTMAP_DEBUG_SENTINEL = 0x5A5A5A5A,
};

static struct rjd_slotmap_header* rjd_slotmap_getheader(const void* map);
static void* rjd_slotmap_grow(void* oldmap, size_t sizeof_type, uint32_t count, struct rjd_mem_allocator* allocator);

////////////////////////////////////////////////////////////////////////////////
// public implementation

void* rjd_slotmap_alloc_impl(size_t sizeof_type, uint32_t count, struct rjd_mem_allocator* allocator)
{
	return rjd_slotmap_grow(NULL, sizeof_type, count, allocator);
}

void* rjd_slotmap_insert_impl(void* map, struct rjd_slot* out_slot)
{
	RJD_ASSERT(map);
	RJD_ASSERT(out_slot);

	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

	if (rjd_array_count(header->freelist) == 0) {
		map = rjd_slotmap_grow(map, header->sizeof_type, header->count * 2, header->allocator);
		header = rjd_slotmap_getheader(map);
		RJD_ASSERT(rjd_array_count(header->freelist) > 0);
	}

	uint32_t index = rjd_array_pop(header->freelist);

	uint16_t* salt = header->salts + index;
	*salt += 1;

	header->used[index] = true;

	out_slot->index = rjd_math_truncate_u32_to_u16(index);
	out_slot->salt = *salt;

	return map;
}

uint32_t rjd_slotmap_get_impl(const void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	RJD_ASSERT(slot.index < header->count);
	uint32_t index = slot.index;
	RJD_ASSERTMSG(!rjd_array_contains(header->freelist, &index), "This slot is unallocated.");
	return slot.index;
}

uint32_t rjd_slotmap_count_impl(const void* map)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	return header->count;
}

void rjd_slotmap_erase_impl(void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	RJD_ASSERT(slot.index < header->count);
	
	rjd_array_push(header->freelist, slot.index);
	header->used[slot.index] = false;
}

void rjd_slotmap_free_impl(void* map)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

	rjd_array_free(header->freelist);
	rjd_mem_free(header);
}

struct rjd_slot rjd_slotmap_next_impl(void* map, const struct rjd_slot* slot)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

	uint32_t start = 0;
	if (slot) {
		start = slot->index + 1;
	}

	for (uint32_t i = start; i < header->count; ++i) {
		if (header->used[i]) {
			struct rjd_slot next = {
				.index = rjd_math_truncate_u32_to_u16(i),
				.salt = header->salts[i],
			};
			return next;
		}
	}

	struct rjd_slot next = {0};
	RJD_ASSERT(!rjd_slot_isvalid(next));
	return next;
}

////////////////////////////////////////////////////////////////////////////////
// private implementation

struct rjd_slotmap_header* rjd_slotmap_getheader(const void* map)
{
	char* raw = (char*)map;
	char* rawheader = (raw - sizeof(struct rjd_slotmap_header));
	struct rjd_slotmap_header* header = (struct rjd_slotmap_header*)rawheader;
	RJD_ASSERTMSG(header->debug_sentinel == RJD_SLOTMAP_DEBUG_SENTINEL, 
		"Debug sentinel does not match. Address %p does not point to a slotmap or there was a buffer underrun corruption.", map);
	return header;
}

void* rjd_slotmap_grow(void* oldmap, size_t sizeof_type, uint32_t count, struct rjd_mem_allocator* allocator)
{
	struct rjd_slotmap_header* oldheader = oldmap ? rjd_slotmap_getheader(oldmap) : NULL;

	uint32_t oldcount = oldheader ? oldheader->count : 0;
	if (count <= oldcount) {
		return oldmap;
	}

	size_t total_mem_size = sizeof(struct rjd_slotmap_header) + sizeof_type * count + sizeof(uint16_t) * count;
	char* mem = rjd_mem_alloc_array(char, total_mem_size, allocator);

	struct rjd_slotmap_header* header = (struct rjd_slotmap_header*)mem;
	header->allocator = allocator;
	header->sizeof_type = (uint32_t)sizeof_type;
	header->count = count;
	header->data = (void*)(mem + sizeof(struct rjd_slotmap_header));
	header->salts = (uint16_t*)((char*)header->data + sizeof_type * count);
	header->used = rjd_array_alloc(bool, count, allocator);
	header->freelist = rjd_array_alloc(uint32_t, count, allocator);
	header->debug_sentinel = RJD_SLOTMAP_DEBUG_SENTINEL;

	memset(header->salts + oldcount, 0, (header->count - oldcount) * sizeof(*header->salts));

	rjd_array_resize(header->used, count);
	if (oldheader) {
		memcpy(header->used, oldheader->used, sizeof(*header->used) * oldheader->count);
	}

	for (uint32_t i = oldcount; i < count; ++i) {
		rjd_array_push(header->freelist, i);
	}

	// copy existing data
	if (oldheader) {
		memcpy(header->data, oldheader->data, sizeof_type * oldheader->count);
		memcpy(header->salts, oldheader->salts, sizeof(uint16_t) * oldheader->count);
		rjd_slotmap_free(oldmap);
	}

	return header->data;
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_path.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PATH_H 1

//struct rjd_strbuf;
//
//struct rjd_path
//{
//	struct rjd_strbuf buf;
//};

//struct rjd_path rjd_path_init();
//struct rjd_path rjd_path_init_contents(const char* path);
//void rjd_path_append(struct rjd_path* path1, const char* path2);
//void rjd_path_join(struct rjd_path* path1, struct rjd_path path2);
//const char* rjd_path_get(struct rjd_path* path);
//const char* rjd_path_get_extension(struct rjd_path* path);
const char* rjd_path_extension(const char* path);

#if RJD_IMPL

//struct rjd_path rjd_path_init()
//{
//}
//
//struct rjd_path rjd_path_init_contents(const char* initial_contents)
//{
//}
//
//void rjd_path_append(struct rjd_path* path, const char* path)
//{
//}
//
//void rjd_path_join(struct rjd_path* path1, struct rjd_path path2)
//{
//}

const char* rjd_path_extension(const char* path)
{
	if (!path) {
		return NULL;
	}

	const char* extension = strrchr(path, '.');
	// If a path ends with a period, it doesn't have an extension
	if (extension && extension[1] == '\0') {
		return NULL;
	}
	return extension;
}

#endif

