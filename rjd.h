#pragma once

////////////////////////////////////////////////////////////////////////////////
// autogenerated rjd.h
////////////////////////////////////////////////////////////////////////////////

#include <stdint.h>
#include <float.h>
#include <stddef.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>
#include <stdarg.h>
#include <xmmintrin.h> // SSE2
#include <pmmintrin.h> // SSE3

#if RJD_IMPL
	#include <stdlib.h>
	#include <stdio.h>
#endif

////////////////////////////////////////////////////////////////////////////////
// rjd_platform.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PLATFORM_H 1

// Platforms
#if _WIN32 || __CYGWIN__
	#define RJD_PLATFORM_WINDOWS 1
	#define RJD_PLATFORM_OSX 0
#elif __APPLE__ && __MACH__
	#define RJD_PLATFORM_OSX 1
	#define RJD_PLATFORM_WINDOWS 0
#else
	#error Unknown platform.
#endif

// Compilers
#ifdef _MSC_VER
	#define RJD_COMPILER_MSVC 1
#elif __clang__
	#define RJD_COMPILER_CLANG 1
#elif __GNUC__
	#define RJD_COMPILER_GCC 1
#else
	#error Unknown compiler.
#endif

#if RJD_COMPILER_MSVC
	#define RJD_FORCE_INLINE __forceinline
	#define RJD_FORCE_ALIGN(type, alignment) __declspec(align(alignment)) type
	#define restrict __restrict
#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
	#define RJD_FORCE_INLINE static inline __attribute__((always_inline))
	#define RJD_FORCE_ALIGN(type, alignment) type __attribute__((aligned(alignment)))
#else
	#error Unhandled compiler
#endif

#if RJD_COMPILER_MSVC
	#if defined(_M_X86) || defined(_M_X64)
		#define RJD_ARCH_64 1
	#elif defined(_M_IX86)
		#define RJD_ARCH_32 1
	#else
		#error Unknown architecture
	#endif
#elif RJD_COMPILER_GCC
	#if defined(__x86_64) || defined(__x86_64__)
		#define RJD_ARCH_64 1
	#elif defined(i386) || defined(__i386) || defined(__i386__)
		#define RJD_ARCH_32 1
	#else
		#error Unknown architecture
	#endif
#elif RJD_COMPILER_CLANG
    #if defined(__x86_64) || defined(__x86_64__)
        #define RJD_ARCH_64 1
    #elif defined(i386) || defined(__i386) || defined(__i386__)
        #define RJD_ARCH_32 1
    #else
        #error Unknown architecture
    #endif
#else
	#error Unhandled compiler
#endif

#if RJD_COMPILER_MSVC
	#define RJD_COMPILER_MSVC_ONLY(code) code
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code)
#elif RJD_COMPILER_GCC
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code) code
	#define RJD_COMPILER_CLANG_ONLY(code)
#elif RJD_COMPILER_CLANG
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code) code
#else
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code)
#endif

#if RJD_COMPILER_MSVC
	#pragma warning(disable:4204) // nonstandard extension used: non-constant aggregate initializer (this is ok in C99)
	#pragma warning(disable:4201) // nonstandard extension used: nameless struct/union (all major compilers support this)
#elif RJD_COMPILER_CLANG
	#pragma clang diagnostic ignored "-Wmissing-braces" // clang is paranoid about zero-init for nested structs
#endif

#if defined(__OBJC__)
	#define RJD_LANG_OBJC 1
#else
	#define RJD_LANG_OBJC 0
#endif

#if defined(__cplusplus)
	#define RJD_LANG_CPP 1
#else
	#define RJD_LANG_CPP 0
#endif

#if RJD_IMPL 
#if RJD_PLATFORM_WINDOWS 
	#define WIN32_LEAN_AND_MEAN
	#define WIN32_EXTRA_LEAN
	#define NOMINMAX
	#include <windows.h>
	#undef near
	#undef far
#endif // RJD_PLATFORM_WINDOWS
#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_debug.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_DEBUG_H 1

enum rjd_log_verbosity
{
	RJD_LOG_VERBOSITY_LOW,
	RJD_LOG_VERBOSITY_MED,
	RJD_LOG_VERBOSITY_HIGH,
};

struct rjd_logchannel
{
	enum rjd_log_verbosity verbosity;
	bool enabled;
	const char* name;
	void (*hook)(const char* formatted, size_t length);
};

#if RJD_ENABLE_LOGGING
	#define RJD_LOG_CHANNEL(channel, verbosity, ...) rjd_log_impl(__FILE__, __LINE__, channel, verbosity, __VA_ARGS__)
	#define RJD_LOG(...) RJD_LOG_CHANNEL(g_rjd_global_logchannel, RJD_LOG_VERBOSITY_MED, __VA_ARGS__)
#else
	#define RJD_LOG_CHANNEL(channel, ...)
	#define RJD_LOG(...)
#endif


#define RJD_NAMEGEN2(a, b) a##b
#define RJD_NAMEGEN(a, b) RJD_NAMEGEN2(a, b)

#if RJD_COMPILER_MSVC
	#define RJD_STATIC_ASSERTMSG(condition, message) typedef int RJD_NAMEGEN(rjd_staticassert_fail, __COUNTER__)[(condition) ? 1 : -1]
#else
	#define RJD_STATIC_ASSERTMSG(condition, message) _Static_assert(condition, message)
#endif
#define RJD_STATIC_ASSERT(condition) RJD_STATIC_ASSERTMSG(condition, #condition)

#if RJD_COMPILER_CLANG || RJD_COMPILER_GCC
	#define RJD_SAME_TYPE_TEST(a, b) (__builtin_types_compatible_p(__typeof__(a), __typeof__(b)))
#else
	#define RJD_SAME_TYPE_TEST(a, b) (1)
#endif
#define RJD_STATIC_TEST(a) (sizeof(int[(a)?1:-1]) * 0)
#define RJD_MUST_BE_SAME_TYPE_TEST(a,b) RJD_STATIC_TEST(RJD_SAME_TYPE_TEST(a,b))

#if RJD_COMPILER_MSVC
	#define RJD_TRAP() __debugbreak()
#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
	#define RJD_TRAP() __builtin_trap()
#endif

#if RJD_ENABLE_ASSERT
	#define RJD_ASSERT(condition) RJD_ASSERTMSG(condition, #condition)
	#define RJD_ASSERTMSG(condition, ...) if (!(condition)) { RJD_LOG(__VA_ARGS__); RJD_TRAP(); }
	#define RJD_ASSERTFAIL(...) { RJD_LOG(__VA_ARGS__); RJD_TRAP(); }
#else
	#define RJD_ASSERT(condition, ...) 
	#define RJD_ASSERTMSG(condition, ...) 
	#define RJD_ASSERTFAIL(...)
#endif

#define RJD_UNUSED_PARAM(param) ((void)(param))

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...);
void rjd_log_resetglobal(void);

extern const struct rjd_logchannel* g_rjd_global_logchannel;

#if RJD_IMPL

const struct rjd_logchannel rjd_global_logchannel = {
	.verbosity = RJD_LOG_VERBOSITY_MED,
	.enabled = true,
	.name = "Default Global",
};
const struct rjd_logchannel* g_rjd_global_logchannel = &rjd_global_logchannel;

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...)
{
	if (!channel || !channel->enabled) {
		return;
	}

	if (verbosity > channel->verbosity) {
		return;
	}

	va_list args;
	va_start(args, format);

	char rawMessage[4096];

	int written = vsnprintf(rawMessage, sizeof(rawMessage), format, args);
	va_end(args);

	if (written < 0)
	{
		printf("Failed to format message.\n");
		RJD_TRAP();
	}

	static const char* formattedLog = "%s(%u): %s\n";
	static const uint32_t logLength = sizeof("%s(%u): %s\n");
	
	char formatted[4096];

	if (sizeof(formatted) <= logLength + written)
	{
		printf("Static buffer not large enough.\n");
		RJD_TRAP();
	}

	const int size = sprintf(formatted, formattedLog, file, line, rawMessage);

	if (channel->hook) {
		channel->hook(formatted, size);
	} else {
		RJD_COMPILER_MSVC_ONLY(OutputDebugString(formatted));
		fwrite(formatted, 1, size, stdout);
		fflush(stdout);
	}
}

void rjd_log_resetglobal()
{
	g_rjd_global_logchannel = &rjd_global_logchannel;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_result.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESULT_H 1

struct rjd_result
{
	const char* error;
};

static inline struct rjd_result rjd_result_init(const char* message) {
	return (struct rjd_result){message};
}

static inline bool rjd_result_isok(struct rjd_result result) {
	return result.error == NULL;
}

// TODO static assert that message is a compile-time string
#define RJD_RESULT(message) rjd_result_init(message)
#define RJD_RESULT_OK() rjd_result_init(NULL)
#define RJD_RESULT_CHECK(validation_condition, message) if (!(validation_condition)) { return RJD_RESULT(message); }
#define RJD_RESULT_PROMOTE(result) if (!rjd_result_isok(result)) { return result; }

////////////////////////////////////////////////////////////////////////////////
// rjd_enum.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ENUM_H 1

// TODO support RJD_ENABLE_ENUM_TYPEDEF

// To use these macros, you need to define an xmacro list, then the use the appropriate *DECLARE
// in a header and *DEFINE in source files. By using these macros, you get:
// * The enum definition (as if you defined it yourself)
// * A count of members in the enum named k_<enumname>_count
// * An enumname_tostring() function that takes the enum and returns a static string (no mem allocation)
// * An enumname_parse() function that takes a const char* and pointer to enum and returns success/fail
// * An array of the enum values' string representation
//
// For example, let's define a Result enum with the values Success and Fail. Note to not forget the 
// backslash for extending the macro in the real version.
//
//	#define MY_ENUM_LIST(macro)
//		macro(RESULT_FAIL)
//		macro(RESULT_SUCCESS)
//	RJD_ENUM_DECLARE(Result, MY_ENUM_LIST);
//	RJD_ENUM_DEFINE(Result, MY_ENUM_LIST);
//
//	The generated interface for the Result enum above would be:
//		enum Result { RESULT_FAIL, RESULT_SUCCESS };
//		enum { k_Result_count = 2 };
//		const char* Result_tostring(enum Result v);
//		bool Result_parse(const char* s, enum Result v);
//		const char* s_Result_strings[] = { "RESULT_FAIL", "RESULT_SUCCESS" };
//
//	You can also specify custom strings if you want to override the default tostring/parse:
//
//	#define MY_ENUM_LIST2(macro)
//		macro(MY_ENUM_LIST2_V1, "CustomStringRep1")
//		macro(MY_ENUM_LIST2_V2, "CustomStringRep2")
//		macro(MY_ENUM_LIST2_V3, "CustomStringRep3")
//	RJD_ENUM_DECLARE_WITH_STRINGS(CoolEnum, MY_ENUM_LIST);
//	RJD_ENUM_DEFINE_WITH_STRINGS(CoolEnum, MY_ENUM_LIST);
//

#define RJD_ENUM_IMPL_TOSTRING(name) name ## _tostring
#define RJD_ENUM_IMPL_COUNT(name) k_ ## name ## _count
#define RJD_ENUM_IMPL_PARSE(name) name ## _parse
#define RJD_ENUM_IMPL_STRINGS(name) s_ ## name ## _strings

#define RJD_ENUM_IMPL_MEMBER(item) item,
#define RJD_ENUM_IMPL_SUM(item) 1 +
#define RJD_ENUM_IMPL_TOSTRING_ITEM(item) #item,
#define RJD_ENUM_IMPL_TOSTRING_CASE(item) case item: return #item;

#define RJD_ENUM_IMPL_MEMBER_WITH_STRING(item, str) item,
#define RJD_ENUM_IMPL_SUM_WITH_STRING(item, str) 1 +
#define RJD_ENUM_IMPL_WITH_STRING_ITEM(item, str) str,
#define RJD_ENUM_IMPL_WITH_STRING_CASE(item, str) case item: return str;

#define RJD_ENUM_DECLARE(name, macrolist)											\
	enum name {																		\
		macrolist(RJD_ENUM_IMPL_MEMBER)												\
	};																				\
	enum { RJD_ENUM_IMPL_COUNT(name) = macrolist(RJD_ENUM_IMPL_SUM) 0 };			\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v);							\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out);					\
	extern const char* RJD_ENUM_IMPL_STRINGS(name)[]

#define RJD_ENUM_DEFINE(name, macrolist)											\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v) {							\
		switch(v) {																	\
			macrolist(RJD_ENUM_IMPL_TOSTRING_CASE)									\
		}																			\
		return "invalid value";														\
	}																				\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out) {					\
		RJD_ASSERT(out);															\
		for (size_t i = 0; i < RJD_ENUM_IMPL_COUNT(name); ++i) {					\
			if (!strcmp(RJD_ENUM_IMPL_STRINGS(name)[i], s)) {						\
				*out = (enum name)i;												\
				return true;														\
			}																		\
		}																			\
		return false;																\
	}																				\
	const char* RJD_ENUM_IMPL_STRINGS(name)[] = {									\
		macrolist(RJD_ENUM_IMPL_TOSTRING_ITEM)										\
	}

#define RJD_ENUM_DECLARE_WITH_STRINGS(name, macrolist)								\
	enum name {																		\
		macrolist(RJD_ENUM_IMPL_MEMBER_WITH_STRING)									\
	};																				\
	enum { RJD_ENUM_IMPL_COUNT(name) = macrolist(RJD_ENUM_IMPL_SUM_WITH_STRING) 0 };\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v);							\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out);					\
	extern const char* RJD_ENUM_IMPL_STRINGS(name)[]

#define RJD_ENUM_DEFINE_WITH_STRINGS(name, macrolist)								\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v) {							\
		switch(v) {																	\
			macrolist(RJD_ENUM_IMPL_WITH_STRING_CASE)								\
		}																			\
		return "invalid value";														\
	}																				\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out) {					\
		RJD_ASSERT(out);															\
		for (size_t i = 0; i < RJD_ENUM_IMPL_COUNT(name); ++i) {					\
			if (!strcmp(RJD_ENUM_IMPL_STRINGS(name)[i], s)) {						\
				*out = (enum name)i;												\
				return true;														\
			}																		\
		}																			\
		return false;																\
	}																				\
	const char* RJD_ENUM_IMPL_STRINGS(name)[] = {									\
		macrolist(RJD_ENUM_IMPL_WITH_STRING_ITEM)									\
	}


////////////////////////////////////////////////////////////////////////////////
// rjd_hash.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_HASH_H 1

struct rjd_hash32
{
	uint32_t value;
};

struct rjd_hash64
{
	uint64_t value;
};

enum
{
	RJD_HASH_NULLTERMINATED_BUFFER = -1,
};

// You can pass -1 as the length to indicate a NULL-terminated buffer (e.g. c-style string)
struct rjd_hash32 rjd_hash32_data(const uint8_t* key, int length);
struct rjd_hash64 rjd_hash64_data(const uint8_t* key, int length);
static inline struct rjd_hash32 rjd_hash32_str(const char* key);
static inline struct rjd_hash64 rjd_hash64_str(const char* key);
bool rjd_hash32_valid(struct rjd_hash32 hash);
bool rjd_hash64_valid(struct rjd_hash64 hash);

////////////////////////////////////////////////////////////////////////////////
// Inline implementation

static inline struct rjd_hash32 rjd_hash32_str(const char* key)
{
	const void* data = key;
	return rjd_hash32_data(data, -1);
}

static inline struct rjd_hash64 rjd_hash64_str(const char* key)
{
	const void* data = key;
	return rjd_hash64_data(data, -1);
}

#if RJD_IMPL

// Code derived from:
// Copyright (c) 2011 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//
// originally developed by Fowler, Noll and Vo
// http://isthe.com/chongo/tech/comp/fnv/
//
// prime/seed from http://isthe.com/chongo/tech/comp/fnv/

struct rjd_hash32 rjd_hash32_data(const uint8_t* key, int length)
{
	RJD_ASSERT(length >= -1);

	if (key == NULL || length == 0 || (length == -1 && *key == '\0')) {
		struct rjd_hash32 hash = {0};
		return hash;
	}

	const uint64_t PRIME = 16777619;
	const uint64_t SEED  = 2166136261;

	struct rjd_hash32 hash = { SEED };
	if (length == -1) {
		while (*key) {
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	} else {
		while (length > 0)
		{
			--length;
			hash.value = (uint32_t)((*key++ ^ hash.value) * PRIME);
		}
	}
	return hash;
}

struct rjd_hash64 rjd_hash64_data(const uint8_t* key, int length)
{
	RJD_ASSERT(length >= -1);

	if (key == NULL || length == 0 || (length == -1 && *key == '\0')) {
		struct rjd_hash64 hash = {0};
		return hash;
	}

	const uint64_t PRIME = 1099511628211ull;
	const uint64_t SEED  = 14695981039346656037ull;

	struct rjd_hash64 hash = { SEED };
	if (length == -1) {
		while (*key) {
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	} else {
		while (length > 0)
		{
			--length;
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	}
	return hash;
}

bool rjd_hash32_valid(struct rjd_hash32 hash)
{
	return hash.value != 0;
}

bool rjd_hash64_valid(struct rjd_hash64 hash)
{
	return hash.value != 0;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_mem.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_MEM_H 1

struct rjd_mem_allocator_stats
{
	uint32_t total_size;
	struct {
		uint32_t used;
		uint32_t overhead;
		uint32_t peak;
		uint32_t unused;
		uint32_t allocs;
		uint32_t frees;
	} current;
	struct {
		uint32_t peak;
		uint32_t allocs;
		uint32_t frees;
		uint32_t resets;
	} lifetime;
};

enum
{
	RJD_KB = 1024,
	RJD_MB = 1024 * 1024,
	RJD_GB = 1024 * 1024 * 1024,
};

// TODO realloc
typedef const char* (*rjd_mem_allocator_type_func)(void);
typedef void* (*rjd_mem_allocator_alloc_func)(size_t size, void* optional_heap);
typedef void (*rjd_mem_allocator_free_func)(void* memory);
typedef void (*rjd_mem_allocator_reset_func)(void* optional_heap);

struct rjd_mem_allocator
{
	rjd_mem_allocator_type_func type_func; // must return a static string
	rjd_mem_allocator_alloc_func alloc_func;
	rjd_mem_allocator_free_func free_func;
	rjd_mem_allocator_reset_func reset_func; // optional
	void* optional_heap;

	struct rjd_mem_allocator_stats stats;

	uint32_t debug_sentinel;
};

struct rjd_mem_allocator rjd_mem_allocator_init_default(void);
struct rjd_mem_allocator rjd_mem_allocator_init_linear(void* memblock, size_t size);

const char* rjd_mem_allocator_type(struct rjd_mem_allocator* allocator);
bool rjd_mem_allocator_reset(struct rjd_mem_allocator* allocator);
struct rjd_mem_allocator_stats rjd_mem_allocator_getstats(const struct rjd_mem_allocator* allocator);

void rjd_mem_free(const void* mem);
void rjd_mem_swap(void* restrict mem1, void* restrict mem2, size_t size);

#define rjd_mem_alloc(type, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type), (allocator), 8, true))
#define rjd_mem_alloc_noclear(type, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type), (allocator), 8, false))
#define rjd_mem_alloc_aligned(type, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type), allocator, alignment, true))
#define rjd_mem_alloc_array(type, count, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, 8, true))
#define rjd_mem_alloc_array_noclear(type, count, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, 8, false))
#define rjd_mem_alloc_array_aligned(type, count, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, alignment, true))
#define rjd_mem_alloc_array_aligned_noclear(type, count, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, alignment, false))

#define RJD_MEM_ISALIGNED(p, align) (((uintptr_t)(p) & ((align)-1)) == 0)
#define RJD_MEM_ALIGN(size, align) ((size) + (RJD_MEM_ISALIGNED(size, align) ? 0 : ((align) - ((size) & ((align)-1)))))

void* rjd_mem_alloc_impl(size_t size, struct rjd_mem_allocator* allocator, uint32_t alignment, bool clear);

////////////////////////////////////////////////////////////////////////////////

#if RJD_IMPL

struct rjd_mem_heap_linear
{
	void* base;
	void* next;
	size_t size;
	uint32_t debug_sentinel;
};

struct rjd_mem_allocation_header
{
	struct rjd_mem_allocator* allocator;
	uint16_t offset_to_block_begin_from_user;
	uint32_t total_blocksize;
	uint32_t debug_sentinel;
};

static const char* rjd_mem_allocator_global_type(void);
static void* rjd_mem_allocator_global_alloc(size_t size, void* heap);
static void rjd_mem_allocator_global_free(void* mem);

static const char* rjd_mem_allocator_linear_type(void);
static void* rjd_mem_allocator_linear_alloc(size_t size, void* heap);
static void rjd_mem_allocator_linear_reset(void* heap);

const uint32_t RJD_MEM_DEBUG_DEFAULT_SENTINEL32 = 0xA7A7A7A7u;
const uint32_t RJD_MEM_DEBUG_LINEAR_SENTINEL32 = 0xA8A8A8A8u;
const uint32_t RJD_MEM_STATS_UNKNOWN_UPPERBOUND = UINT32_MAX;

struct rjd_mem_allocator rjd_mem_allocator_init_default()
{
	struct rjd_mem_allocator allocator = {
		.type_func = rjd_mem_allocator_global_type,
		.alloc_func = NULL,
		.free_func = NULL,
		.reset_func = NULL,
		.optional_heap = NULL,
		.stats = {
			.total_size = RJD_MEM_STATS_UNKNOWN_UPPERBOUND,
			.current = {
				.unused = RJD_MEM_STATS_UNKNOWN_UPPERBOUND,
			},
		},
		.debug_sentinel = RJD_MEM_DEBUG_DEFAULT_SENTINEL32,
	};

	// MSVC has a slightly different signature for malloc/free so to avoid platform-specific
	// code, we just wrap them for all platforms here
	allocator.alloc_func = rjd_mem_allocator_global_alloc;
	allocator.free_func = rjd_mem_allocator_global_free;

	return allocator;
}

struct rjd_mem_allocator rjd_mem_allocator_init_linear(void* memblock, size_t size)
{
	RJD_ASSERT(memblock);

	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)RJD_MEM_ALIGN((uintptr_t)memblock, 64);
	uint32_t usable_size = 0;
	{
		char* usable_memory_start = (char*)RJD_MEM_ALIGN((uintptr_t)heap + sizeof(struct rjd_mem_heap_linear), 64);
		char* usable_memory_end = (char*)memblock + size;
		RJD_ASSERTMSG(usable_memory_start < usable_memory_end, 
			"Given size was not large enough to make a heap. You need at least 128 bytes...");

		usable_size = (uint32_t)(usable_memory_end - usable_memory_start);

		struct rjd_mem_heap_linear copy = { 
			.base = usable_memory_start, 
			.next = usable_memory_start, 
			.size = usable_size, 
			.debug_sentinel = RJD_MEM_DEBUG_LINEAR_SENTINEL32 
		};
		*heap = copy;
	}

	struct rjd_mem_allocator allocator = {
		.type_func = rjd_mem_allocator_linear_type,
		.alloc_func = rjd_mem_allocator_linear_alloc,
		.free_func = NULL,
		.reset_func = rjd_mem_allocator_linear_reset,
		.optional_heap = heap,
		.stats = {
			.total_size = usable_size,
			.current = {
				.unused = usable_size,
			},
		},
		.debug_sentinel = RJD_MEM_DEBUG_LINEAR_SENTINEL32,
	};

	return allocator;
}

const char* rjd_mem_allocator_type(struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);
	return allocator->type_func();
}

bool rjd_mem_allocator_reset(struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);

	allocator->stats.current.used = 0;
	allocator->stats.current.overhead = 0;
	allocator->stats.current.peak = 0;
	allocator->stats.current.unused = allocator->stats.total_size;
	allocator->stats.current.allocs = 0;
	allocator->stats.current.frees = 0;
	++allocator->stats.lifetime.resets;

	if (allocator->reset_func) {
		allocator->reset_func(allocator->optional_heap);

		return true;
	}
	return false;
}

struct rjd_mem_allocator_stats rjd_mem_allocator_getstats(const struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);
	return allocator->stats;
}

void* rjd_mem_alloc_impl(size_t size, struct rjd_mem_allocator* allocator, uint32_t alignment, bool clear)
{
	RJD_ASSERT(allocator);
    RJD_ASSERT(size >= 0)
	RJD_ASSERT(alignment >= 8);

	const uint32_t header_size = sizeof(struct rjd_mem_allocation_header);
    const uint32_t alignment_padding = alignment * 2;
	const uint32_t total_size = (uint32_t)size + header_size + alignment_padding;
    
   	char* raw = allocator->alloc_func(total_size, allocator->optional_heap);
	if (raw == NULL) {
		return raw;
	}

	if (clear) {
		memset(raw, 0, total_size);
	}

	uintptr_t aligned_user = RJD_MEM_ALIGN((uintptr_t)raw + alignment + header_size, alignment);

    const ptrdiff_t offset_to_block_begin_from_user = aligned_user - (uintptr_t)raw;
    RJD_ASSERT(offset_to_block_begin_from_user < UINT16_MAX);
    
	struct rjd_mem_allocation_header* header = (void*)(aligned_user - header_size);
	header->allocator = allocator;
	header->total_blocksize = (uint32_t)total_size;
    header->offset_to_block_begin_from_user = offset_to_block_begin_from_user;
	header->debug_sentinel = allocator->debug_sentinel;

	{
		uint32_t* current_used = &allocator->stats.current.used;
		uint32_t* current_peak = &allocator->stats.current.peak;
		uint32_t* lifetime_peak = &allocator->stats.lifetime.peak;
		*current_used += total_size;
		allocator->stats.current.overhead += total_size - size;
		*current_peak = (*current_peak < *current_used) ? *current_used : *current_peak;
		*lifetime_peak = (*lifetime_peak < *current_used) ? *current_used : *lifetime_peak;
		if (allocator->stats.current.unused != RJD_MEM_STATS_UNKNOWN_UPPERBOUND) {
			RJD_ASSERT(allocator->stats.current.unused >= total_size);
			allocator->stats.current.unused -= total_size;
		}
		++allocator->stats.current.allocs;
		++allocator->stats.lifetime.allocs;
	}

	return (void*)aligned_user;
}

void rjd_mem_free(const void* mem)
{
	if (!mem) {
		return;
	}

	char* raw = (void*)mem;
	struct rjd_mem_allocation_header* header = (void*)(raw - sizeof(struct rjd_mem_allocation_header));
	struct rjd_mem_allocator* allocator = header->allocator;

	RJD_ASSERTMSG(header->debug_sentinel == allocator->debug_sentinel, "This memory was not allocated with rjd_mem_alloc.");

	if (allocator->free_func) {
		RJD_ASSERT(allocator->stats.current.used >= header->total_blocksize);
		allocator->stats.current.used -= header->total_blocksize;
		if (allocator->stats.current.unused != RJD_MEM_STATS_UNKNOWN_UPPERBOUND) {
			allocator->stats.current.unused += header->total_blocksize;
		}
		++allocator->stats.current.frees;
		++allocator->stats.lifetime.frees;
        
        char* begin = raw - header->offset_to_block_begin_from_user;
        allocator->free_func(begin);
	}
}

void rjd_mem_swap(void* restrict mem1, void* restrict mem2, size_t size)
{
	uint8_t tmp[1024];
	RJD_ASSERTMSG(size < (uint32_t)sizeof(tmp), "Increase size of static buffer to at least %u", size);

	memcpy(tmp, mem1, size);
	memcpy(mem1, mem2, size);
	memcpy(mem2, tmp, size);
}

////////////////////////////////////////////////////////////////////////////////
// local helper definitions

const char* rjd_mem_allocator_global_type(void)
{
	return "rjd_global";
}

void* rjd_mem_allocator_global_alloc(size_t size, void* unused_heap)
{
	RJD_UNUSED_PARAM(unused_heap);

	return malloc(size);
}

void rjd_mem_allocator_global_free(void* mem)
{
	free(mem);
}

const char* rjd_mem_allocator_linear_type(void)
{
	return "rjd_linear";
}

void* rjd_mem_allocator_linear_alloc(size_t size, void* optional_heap)
{
	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)optional_heap;
	RJD_ASSERT(heap->debug_sentinel == RJD_MEM_DEBUG_LINEAR_SENTINEL32);

	size_t align_diff = size % 8;
	if (align_diff != 0) {
		size += align_diff;
	}

	if ((char*)heap->next + size <= (char*)heap->base + heap->size) 
	{
		void* mem = (char*)heap->next;
		heap->next = (char*)heap->next + size;

		return mem;
	}

	return NULL;
}

void rjd_mem_allocator_linear_reset(void* optional_heap)
{
	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)optional_heap;
	RJD_ASSERT(heap->debug_sentinel == RJD_MEM_DEBUG_LINEAR_SENTINEL32);

	heap->next = heap->base;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_rng.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RNG_H 1

struct rjd_rng
{
	uint64_t seed;
	uint64_t state;
};

struct rjd_rng rjd_rng_init(uint64_t seed);
uint64_t rjd_rng_next(struct rjd_rng* rng);
double rjd_rng_float(struct rjd_rng* rng);
int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive);

#if RJD_IMPL

struct rjd_rng rjd_rng_init(uint64_t seed)
{
	struct rjd_rng rng = { seed, seed };
	return rng;
}

uint64_t rjd_rng_next(struct rjd_rng* rng)
{
	rng->state ^= rng->state << 15;
	rng->state ^= rng->state >> 3;
	rng->state ^= rng->state << 52;
	return rng->state;
}

double rjd_rng_float(struct rjd_rng* rng)
{
	uint64_t next = rjd_rng_next(rng) % 1000001ull;
	return (double)next / 1000000.0;
}

int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive)
{
	if (max_exclusive < min_inclusive) {
		return max_exclusive;
	}

	int32_t range = max_exclusive - min_inclusive;
	if (range == 0) {
		return min_inclusive;
	}

	uint64_t next = rjd_rng_next(rng);
	return min_inclusive + (next % range);
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_array.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ARRAY_H 1

// helpers
#define RJD_MUST_BE_ARRAY(a) (RJD_STATIC_TEST(!RJD_SAME_TYPE_TEST((a), &(*a))))

// static array count
#define rjd_countof(buf) (sizeof(buf) / sizeof(*(buf)) + RJD_MUST_BE_ARRAY(buf))

// dyanmic array
#define rjd_array_alloc(type, capacity, allocator)	((type*)(rjd_array_alloc_impl((capacity), (allocator), sizeof(type))))
#define rjd_array_clone(buf, allocator)				rjd_array_clone_impl((buf), allocator, sizeof(*(buf)))
#define rjd_array_free(buf)							rjd_array_free_impl(buf)
#define rjd_array_capacity(buf) 					((buf)?(const uint32_t)(*rjd_array_capacity_impl(buf)):0)
#define rjd_array_count(buf) 						((buf)?(const uint32_t)(*rjd_array_count_impl(buf)):0)
#define rjd_array_clear(buf)						(*rjd_array_count_impl(buf) = 0)
#define rjd_array_reserve(buf, capacity)			(buf = rjd_array_reserve_impl((buf), capacity, sizeof(*(buf))))
#define rjd_array_resize(buf, size) 				(buf = rjd_array_resize_impl((buf), size, sizeof(*(buf))))
#define rjd_array_trim(buf)							(buf = rjd_array_trim_impl((buf), sizeof(*(buf))))
#define rjd_array_erase(buf, index) 				rjd_array_erase_impl((buf), index, sizeof(*(buf)))
#define rjd_array_erase_unordered(buf, index) 		rjd_array_erase_unordered_impl((buf), index, sizeof(*(buf)))
#define rjd_array_empty(buf) 						(rjd_array_count(buf) == 0)
#define rjd_array_full(buf) 						(rjd_array_count(buf) == rjd_array_capacity(buf))
#define rjd_array_push(buf, value) 					(buf = rjd_array_push_impl((buf), \
													sizeof(*(buf))), (buf)[rjd_array_count(buf) - 1] = value)
#define rjd_array_pop(buf)		 					(rjd_array_pop_impl(buf), 		\
													--*rjd_array_count_impl(buf), 	\
													*(buf + rjd_array_count(buf)))
#define rjd_array_insert(buf, ptr, index)			(buf = rjd_array_insert_impl((buf), (ptr), sizeof(*(buf)), index))
#define rjd_array_get(buf, index)					(rjd_array_get_validate((buf), (index)), (buf + index))
#define rjd_array_first(buf)						(rjd_array_get_validate((buf), 0), (buf)[0])
#define rjd_array_last(buf)							(rjd_array_get_validate((buf), 0), (buf)[rjd_array_count(buf) - 1])

// searching/sorting
typedef int32_t (*rjd_array_compare_func)(const void* left, const void* right);
typedef int32_t (*rjd_array_compare_c_func)(void* context, const void* left, const void* right);

enum { RJD_ARRAY_NOT_FOUND = -1 };

#define rjd_array_find(buf, ptr)						rjd_array_find_impl((buf), (ptr), sizeof(*(buf)), RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_contains(buf, ptr)					rjd_array_contains_impl((buf), (ptr), sizeof(*(buf)), RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))

// These functions sort or deal with sorted data
#define rjd_array_sort(buf, comparer) \
		rjd_array_sort_impl((buf), sizeof(*(buf)), comparer)
#define rjd_array_lowerbound(buf, ptr, comparer) \
		rjd_array_lowerbound_impl((buf), ptr, sizeof(*(buf)), comparer, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_find_sorted(buf, ptr, comparer) \
		rjd_array_find_sorted_impl((buf), (ptr), sizeof(*(buf)), comparer, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_contains_sorted(buf, ptr, comparer) \
		rjd_array_contains_sorted_impl((buf), (ptr), sizeof(*(buf)), comparer, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))

// These versions of the sort/find sorted functions allow you to provide a content parameter that 
// is passed into the compare func.
#define rjd_array_sort_c(buf, comparer, context) \
		rjd_array_sort_c_impl((buf), sizeof(*(buf)), comparer, context)
#define rjd_array_lowerbound_c(buf, ptr, comparer, context) \
		rjd_array_lowerbound_c_impl((buf), (ptr), sizeof(*(buf)), comparer, context, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_find_sorted_c(buf, ptr, comparer, context) \
		rjd_array_find_sorted_c_impl((buf), (ptr), sizeof(*(buf)), comparer, context, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_contains_sorted_c(buf, ptr, comparer, context) \
		rjd_array_contains_sorted_c_impl((buf), (ptr), sizeof(*(buf)), comparer, context, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))

// predicate helpers for the functional-style interface
#define rjd_array_sum_predicate(acc, element) 		(acc + element)

// functional-style helpers
#define rjd_array_filter(buf, predicate, context)	for(int _i = (int)rjd_array_count(buf) - 1; _i >= 0; --_i) { 	 	\
															if (!(predicate((buf)[_i]))) { rjd_array_erase((buf), _i); } \
													}
#define rjd_array_map(in, out, predicate)			rjd_array_resize((out), rjd_array_count(in)); 					\
													for (size_t _i = 0; _i < rjd_array_count(in); ++_i) {			\
														out[_i] = predicate(in[_i]); 								\
													}
#define rjd_array_reduce(buf, acc, predicate)		for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) {			\
														(acc) = predicate(acc, ((buf)[_i]));						\
													}
#define rjd_array_sum(buf, acc)						for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) {			\
														(acc) = rjd_array_sum_predicate((acc), ((buf)[_i]));		\
													}
#define rjd_array_reverse(buf)						rjd_array_reverse_impl(buf, sizeof(*buf))

// randomness helpers
#define rjd_array_sample(buf, rng)					((buf)[rjd_rng_range32(rng, 0, rjd_array_count(buf))])
#define rjd_array_shuffle(buf, rng)					rjd_array_shuffle_impl(buf, rng, sizeof(*buf))

struct rjd_mem_allocator;
struct rjd_rng;

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_mem_allocator* allocator, size_t sizeof_type);
void* rjd_array_clone_impl(const void* array, struct rjd_mem_allocator* allocator, size_t sizeof_type);
void rjd_array_free_impl(const void* array);
uint32_t* rjd_array_capacity_impl(const void* array);
uint32_t* rjd_array_count_impl(const void* array);
void* rjd_array_reserve_impl(void* array, uint32_t newcapacity, size_t sizeof_type);
void* rjd_array_resize_impl(void* array, uint32_t newcount, size_t sizeof_type);
void* rjd_array_trim_impl(void* array, size_t sizeof_type);
void rjd_array_erase_impl(void* array, uint32_t index, size_t sizeof_type);
void rjd_array_erase_unordered_impl(void* array, uint32_t index, size_t sizeof_type);
void* rjd_array_push_impl(void* array, size_t sizeof_type);
void rjd_array_pop_impl(void* array);
void* rjd_array_insert_impl(void* array, const void* insert, size_t sizeof_type, uint32_t index);
void rjd_array_get_validate(void* array, uint32_t index);
int32_t rjd_array_find_impl(const void* array, const void* search, size_t sizeof_type, int unused);
bool rjd_array_contains_impl(const void* array, const void* search, size_t sizeof_type, int unused);
void rjd_array_sort_impl(void* array, size_t sizeof_type, rjd_array_compare_func comparer);
int32_t rjd_array_lowerbound_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func comparer, int unused);
int32_t rjd_array_find_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func comparer, int unused);
bool rjd_array_contains_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func comparer, int unused);
void rjd_array_sort_c_impl(void* array, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context);
int32_t rjd_array_lowerbound_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context, int unused);
int32_t rjd_array_find_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context, int unused);
bool rjd_array_contains_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context, int unused);
void rjd_array_shuffle_impl(void* array, struct rjd_rng* rng, size_t sizeof_type);
void rjd_array_reverse_impl(void* array, size_t sizeof_type);

#if RJD_IMPL

struct rjd_array_header
{
	struct rjd_mem_allocator* allocator;
	uint32_t capacity;
	uint32_t count;
	uint32_t debug_sentinel;
};

const uint32_t RJD_ARRAY_DEBUG_SENTINEL32 = 0xA7A7A7A7;

static struct rjd_array_header* rjd_array_getheader(void* array);
static struct rjd_mem_allocator* rjd_array_allocator(void* array);
static inline void rjd_array_validate(const void* array);
static void* rjd_array_grow(void* array, size_t sizeof_type);

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_mem_allocator* allocator, size_t sizeof_type)
{
	RJD_ASSERT(capacity > 0);
	RJD_ASSERT(allocator);
	RJD_ASSERT(sizeof_type > 0);

	size_t rawsize = sizeof(struct rjd_array_header) + (sizeof_type * capacity);
	char* raw = rjd_mem_alloc_array(char, rawsize, allocator);

	struct rjd_array_header* header = (struct rjd_array_header*)raw;
	header->allocator = allocator;
	header->capacity = capacity;
	header->count = 0;
	header->debug_sentinel = RJD_ARRAY_DEBUG_SENTINEL32; 

	char* buf = raw + sizeof(struct rjd_array_header);
	return buf;
}

void* rjd_array_clone_impl(const void* array, struct rjd_mem_allocator* allocator, size_t sizeof_type)
{
	uint32_t count = rjd_array_count(array);
	void* clone = rjd_array_alloc_impl(count, allocator, sizeof_type);
	clone = rjd_array_resize_impl(clone, count, sizeof_type);
	memcpy(clone, array, count * sizeof_type);
	return clone;
}

void rjd_array_free_impl(const void* array)
{
	if (!array) {
		return;
	}
	rjd_array_validate(array);

	char* raw = (char*)array;
	rjd_mem_free(raw - sizeof(struct rjd_array_header));
}

uint32_t* rjd_array_capacity_impl(const void* array)
{
	RJD_ASSERT(array);

	rjd_array_validate(array);

	struct rjd_array_header* header = rjd_array_getheader((void*)array);
	return &header->capacity;
}

uint32_t* rjd_array_count_impl(const void* array)
{
	RJD_ASSERT(array);

	rjd_array_validate(array);

	struct rjd_array_header* header = rjd_array_getheader((void*)array);
	return &header->count;
}

void* rjd_array_reserve_impl(void* array, uint32_t newcapacity, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	uint32_t oldcapacity = rjd_array_capacity(array);

	if (oldcapacity < newcapacity) {
		struct rjd_mem_allocator* allocator = rjd_array_allocator(array);
		char* newarray = rjd_array_alloc_impl(newcapacity, allocator, sizeof_type);

		uint32_t* count = rjd_array_count_impl(newarray);
		*count = rjd_array_count(array);

		memcpy(newarray, array, (*count * sizeof_type));

		rjd_array_free(array);
		return newarray;
	}

	return array;
}

void* rjd_array_resize_impl(void* array, uint32_t newcount, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	array = rjd_array_reserve_impl(array, newcount, sizeof_type);
	uint32_t* count = rjd_array_count_impl(array);

	// zero new members
	if (newcount > *count) {
		memset((char*)array + (*count * sizeof_type), 0, (newcount - *count) * sizeof_type);
	}

	*count = newcount;
	return array;
}

void* rjd_array_trim_impl(void* array, size_t sizeof_type)
{
	if (rjd_array_count(array) == rjd_array_capacity(array)) {
		return array;
	}

	void* newarray = rjd_array_alloc_impl(rjd_array_count(array), rjd_array_allocator(array), sizeof_type);
	memcpy(newarray, array, rjd_array_count(array) * sizeof_type);
	*rjd_array_count_impl(newarray) = rjd_array_count(array);

	rjd_array_free(array);

	return newarray;
}

void rjd_array_erase_impl(void* array, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(index < rjd_array_count(array));
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	char* raw = array;
	size_t toshift = rjd_array_count(array) - index - 1;
	if (toshift > 0) {
		memmove(raw + index * sizeof_type, raw + (index + 1) * sizeof_type, toshift * sizeof_type);
	}
	--*rjd_array_count_impl(array);
}

void rjd_array_erase_unordered_impl(void* array, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(index < rjd_array_count(array));
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	char* raw = array;

	uint32_t* count = rjd_array_count_impl(array);

	if (*count > 1) {
		char* erase = raw + index * sizeof_type;
		char* swap = raw + (*count - 1) * sizeof_type;
		memcpy(erase, swap, sizeof_type);
	}

	if (*count > 0) {
		--*rjd_array_count_impl(array);
	}
}

void* rjd_array_push_impl(void* array, size_t sizeof_type) 
{
	array = rjd_array_grow(array, sizeof_type);
	++*rjd_array_count_impl(array);

	// skip init new element to 0 since it will be set in the push macro

	return array;
}

void rjd_array_pop_impl(void* array)
{
	RJD_ASSERT(rjd_array_count(array) > 0);
}

void* rjd_array_insert_impl(void* array, const void* insert, size_t sizeof_type, uint32_t index)
{
	array = rjd_array_grow(array, sizeof_type);
	uint32_t* count = rjd_array_count_impl(array);
	++*count;

	RJD_ASSERT(*count > index);

	void* where_to_insert = (char*)array + sizeof_type * index;
	void* element_after_insert = (char*)where_to_insert + sizeof_type;
	memmove(element_after_insert, where_to_insert, sizeof_type * (*count - index));
	memcpy(where_to_insert, insert, sizeof_type);

	return array;
}

void rjd_array_get_validate(void* array, uint32_t index)
{
	rjd_array_validate(array);
	RJD_ASSERT(index < rjd_array_count(array));
}

int32_t rjd_array_find_impl(const void* array, const void* search, size_t sizeof_type, int unused)
{
	RJD_UNUSED_PARAM(unused);

	rjd_array_validate(array);

	if (!array) {
		return false;
	}

	char* raw = (char*)array;
	for (int32_t i = 0; i < (int32_t)rjd_array_count(array); ++i) {
		if (!memcmp(raw + i * sizeof_type, search, sizeof_type)) {
			return i;
		}
	}
	return RJD_ARRAY_NOT_FOUND;
}

bool rjd_array_contains_impl(const void* array, const void* search, size_t sizeof_type, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_find_impl(array, search, sizeof_type, 0);
	return index != RJD_ARRAY_NOT_FOUND;
}

void rjd_array_sort_impl(void* array, size_t sizeof_type, rjd_array_compare_func comparer)
{
	rjd_array_validate(array);
	size_t length = rjd_array_count(array);
	qsort(array, length, sizeof_type, comparer);
}

int32_t rjd_array_lowerbound_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func comparer, int unused)
{
	RJD_UNUSED_PARAM(unused);

	rjd_array_validate(array);

	uint32_t length = rjd_array_count(array);

	if (length == 0) {
		return 0;
	}

	int32_t first = 0;
	int32_t index = 0;
	
	while (length > 0)
	{
		int32_t step = length / 2;
		index = first + step;

		const void* value = (const char*)array + index * sizeof_type;
		const int32_t compared_value = comparer(value, needle);

		if (compared_value < 0) {
			++index;
			first = index;
			length -= step + 1;
		} else if (compared_value > 0) {
			length = step;
		} else {
			break;
		}
	}
	return index;
}

int32_t rjd_array_find_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func comparer, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_lowerbound_impl(array, needle, sizeof_type, comparer, 0);
	const void* value = (const char*)array + (index * sizeof_type);
	if (comparer(array, value) == 0) {
		return index;
	}
	return RJD_ARRAY_NOT_FOUND;
}

bool rjd_array_contains_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func comparer, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_find_sorted_impl(array, needle, sizeof_type, comparer, 0);
	return index != RJD_ARRAY_NOT_FOUND;
}

void rjd_array_sort_c_impl(void* array, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context)
{
	rjd_array_validate(array);
	const size_t length = rjd_array_count(array);
#if RJD_COMPILER_MSVC
	qsort_s(array, length, sizeof_type, context, comparer);
#else
	qsort_r(array, length, sizeof_type, context, comparer);
#endif
}

int32_t rjd_array_lowerbound_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context, int unused)
{
	RJD_UNUSED_PARAM(unused);

	rjd_array_validate(array);

	uint32_t length = rjd_array_count(array);

	if (length == 0) {
		return 0;
	}

	int32_t first = 0;
	int32_t index = 0;
	
	while (length > 0)
	{
		int32_t step = length / 2;
		index = first + step;

		const void* value = (const char*)array + index * sizeof_type;
		const int32_t compared_value = comparer(context, value, needle);

		if (compared_value < 0) {
			++index;
			first = index;
			length -= step + 1;
		} else if (compared_value > 0) {
			length = step;
		} else {
			break;
		}
	}
	return index;
}

int32_t rjd_array_find_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_lowerbound_c_impl(array, needle, sizeof_type, comparer, context, 0);
	const void* value = (const char*)array + (index * sizeof_type);
	if (comparer(context, array, value) == 0) {
		return index;
	}
	return RJD_ARRAY_NOT_FOUND;
}

bool rjd_array_contains_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func comparer, void* context, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_find_sorted_c_impl(array, needle, sizeof_type, comparer, context, 0);
	return index != RJD_ARRAY_NOT_FOUND;
}

void rjd_array_shuffle_impl(void* array, struct rjd_rng* rng, size_t sizeof_type)
{
	if (!array) {
		return;
	}

	rjd_array_validate(array);

	char tmp[512];
	RJD_ASSERTMSG(sizeof_type <= sizeof(tmp), 
		"tmp (%u bytes) must be greater than or equal to sizeof_type (%u bytes)", 
		(unsigned) sizeof(tmp), (unsigned) sizeof_type);

	char* raw = (char*)array;
	for (uint32_t i = 0; i < rjd_array_count(array); ++i) {
		uint32_t k = rjd_rng_range32(rng, 0, rjd_array_count(array));
		if (i == k) {
			continue;
		}

		char* a = raw + (i * sizeof_type);
		char* b = raw + (k * sizeof_type);

		memcpy(tmp, a, sizeof_type);
		memcpy(a, b, sizeof_type);
		memcpy(b, tmp, sizeof_type);
	}
}

void rjd_array_reverse_impl(void* array, size_t sizeof_type)
{
	if (!array) {
		return;
	}
	rjd_array_validate(array);

	uint8_t* raw = array;
	for (uint8_t* begin = raw, *end = raw + (int32_t)sizeof_type * ((int32_t)rjd_array_count(array) - 1); 
		begin < end; 
		begin += sizeof_type, end -= sizeof_type)
	{
		rjd_mem_swap(begin, end, sizeof_type);
	}
}

////////////////////////////////////////////////////////////////////////////////
// local helpers

static struct rjd_array_header* rjd_array_getheader(void* array)
{
	if (!array) {
		return NULL;
	}
	rjd_array_validate(array);

	char* raw = array;
	char* raw_header = raw - sizeof(struct rjd_array_header);
	return (struct rjd_array_header*) raw_header;
}

static struct rjd_mem_allocator* rjd_array_allocator(void* array)
{
	RJD_ASSERT(array);
	return rjd_array_getheader(array)->allocator;
}

static inline void rjd_array_validate(const void* array)
{
	RJD_ASSERT(array);
	const char* raw = array;
	const struct rjd_array_header* header = (struct rjd_array_header*)(raw - sizeof(struct rjd_array_header));
	RJD_ASSERTMSG(header->debug_sentinel == RJD_ARRAY_DEBUG_SENTINEL32, 
		"Debug sentinel was either corrupted by an underrun or this is not an rjd_array.");
	RJD_UNUSED_PARAM(header);
}

static void* rjd_array_grow(void* array, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	uint32_t count = rjd_array_count(array);
	uint32_t capacity = rjd_array_capacity(array);
	if (count == capacity) {
		array = rjd_array_reserve_impl(array, capacity * 2, sizeof_type);
	}
	return array;
}

#endif //RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_math.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_MATH_H 1

#define RJD_MATH_PI (3.141592653589793238462643f)
#define RJD_MATH_EPSILON (0.000001)

////////////////////////////////////////////////////////////////////////////////
// utils

static inline uint32_t rjd_math_next_pow2(uint32_t v);
static inline int32_t rjd_math_pow32(int32_t v, uint32_t power);

#define RJD_MATH_DECLARE_SIGN_FUNC(name, type) static inline type name(type v);
#define RJD_MATH_DEFINE_SIGN_FUNC(name, type) static inline type name(type v) { return (v < 0) ? (type)-1 : (type)1; }
#define RJD_MATH_SIGN_FUNCS(xmacro)		\
	xmacro(rjd_math_sign32, int32_t)	\
	xmacro(rjd_math_sign, double)		\
	xmacro(rjd_math_signf, float)
RJD_MATH_SIGN_FUNCS(RJD_MATH_DECLARE_SIGN_FUNC)

#define RJD_MATH_DECLARE_ISEQUAL_FUNC(name, type) static inline bool name(type a, type b);
#define RJD_MATH_DEFINE_ISEQUAL_FUNC(name, type) static inline bool name(type a, type b) { return (type)fabs(a - b) < RJD_MATH_EPSILON; }
#define RJD_MATH_ISEQUAL_FUNCS(xmacro)	\
	xmacro(rjd_math_isequal, double)	\
	xmacro(rjd_math_isequalf, float)
RJD_MATH_ISEQUAL_FUNCS(RJD_MATH_DECLARE_ISEQUAL_FUNC)

#define RJD_MATH_DECLARE_MIN_FUNC(name, type) static inline type name(type a, type b);
#define RJD_MATH_DEFINE_MIN_FUNC(name, type) static inline type name(type a, type b) { return (a < b) ? a : b; }
#define RJD_MATH_MIN_FUNCS(xmacro)		\
	xmacro(rjd_math_min32, int32_t)		\
	xmacro(rjd_math_min64, int64_t)		\
	xmacro(rjd_math_minu32, uint32_t)	\
	xmacro(rjd_math_minu64, uint64_t)
RJD_MATH_MIN_FUNCS(RJD_MATH_DECLARE_MIN_FUNC)

#define RJD_MATH_DECLARE_MAX_FUNC(name, type) static inline type name(type a, type b);
#define RJD_MATH_DEFINE_MAX_FUNC(name, type) static inline type name(type a, type b) { return (a < b) ? b : a; }
#define RJD_MATH_MAX_FUNCS(xmacro)		\
	xmacro(rjd_math_max32, int32_t)		\
	xmacro(rjd_math_max64, int64_t)		\
	xmacro(rjd_math_maxu64, uint64_t)	\
	xmacro(rjd_math_maxu32, uint32_t)
RJD_MATH_MAX_FUNCS(RJD_MATH_DECLARE_MAX_FUNC)

#define RJD_MATH_DECLARE_CLAMP_FUNC(name, type) static inline type name(type v, type minv, type maxv);
#define RJD_MATH_DEFINE_CLAMP_FUNC(name, type) static inline type name(type v, type minv, type maxv) { return (v < minv) ? (minv) : (v > maxv ? maxv : v); }
#define RJD_MATH_CLAMP_FUNCS(xmacro)	\
	xmacro(rjd_math_clamp, double)		\
	xmacro(rjd_math_clampf, float)		\
	xmacro(rjd_math_clamp32, int32_t)	\
	xmacro(rjd_math_clamp64, int64_t)	\
	xmacro(rjd_math_clampu32, uint32_t)	\
	xmacro(rjd_math_clampu64, uint64_t)
RJD_MATH_CLAMP_FUNCS(RJD_MATH_DECLARE_CLAMP_FUNC)

#define RJD_MATH_DECLARE_TRUNCATE_FUNC(name, bigtype, smalltype) static inline smalltype name(bigtype v);
#define RJD_MATH_DEFINE_TRUNCATE_FUNC(name, bigtype, smalltype) static inline smalltype name(bigtype v) { RJD_ASSERT(v <= (smalltype)-1); return (smalltype)v; }
#define RJD_MATH_TRUNCATE_FUNCS(xmacro) 						\
	xmacro(rjd_math_truncate_u64_to_u32, uint64_t, uint32_t)	\
	xmacro(rjd_math_truncate_u64_to_u16, uint64_t, uint16_t)	\
	xmacro(rjd_math_truncate_u64_to_u8,  uint64_t, uint8_t)		\
	xmacro(rjd_math_truncate_u32_to_u16, uint32_t, uint16_t)	\
	xmacro(rjd_math_truncate_u32_to_u8,  uint32_t, uint8_t)		\
	xmacro(rjd_math_truncate_u16_to_u8,  uint16_t, uint8_t)
RJD_MATH_TRUNCATE_FUNCS(RJD_MATH_DECLARE_TRUNCATE_FUNC)

#define RJD_MATH_DECLARE_REMAP_FUNC(name, type) static inline type name(type v, type oldmin, type oldmax, type newmin, type newmax);
#define RJD_MATH_DEFINE_REMAP_FUNC(name, type) static inline type name(type v, type oldmin, type oldmax, type newmin, type newmax) { type oldrange = oldmax - oldmin; type newrange = newmax - newmin; return ((v - oldmin) * newrange) / oldrange + newmin; }
#define RJD_MATH_REMAP_FUNCS(xmacro)	\
	xmacro(rjd_math_remap, double)		\
	xmacro(rjd_math_remapf, float)
RJD_MATH_REMAP_FUNCS(RJD_MATH_DECLARE_REMAP_FUNC)

// vector structs

typedef union rjd_math_float2 {
	struct {
		float x;
		float y;
	};
	float v[2];
} rjd_math_float2;

typedef union rjd_math_float3 {
	struct {
		float x;
		float y;
		float z;
	};
	float v[3];
} rjd_math_float3;

typedef union rjd_math_float4 {
	struct {
		float x;
		float y;
		float z;
		float w;
	};
	float v[4];
} rjd_math_float4;

typedef struct rjd_math_float16 {
	float v[16];
} rjd_math_float16;

typedef struct rjd_math_vec3 {
	__m128 v;
} rjd_math_vec3;

typedef struct rjd_math_vec4 {
	__m128 v;
} rjd_math_vec4;

// column-major 4x4 matrix
typedef struct {
	rjd_math_vec4 m[4];
} rjd_math_mat4;

// float structs are mainly intended for convenience tranlations out of __m128 registers

static inline rjd_math_float2 rjd_math_float2_xy(float x, float y);
static inline rjd_math_float3 rjd_math_float3_xyz(float x, float y, float z);
static inline rjd_math_float4 rjd_math_float4_xyzw(float x, float y, float z, float w);

static inline rjd_math_vec3 rjd_math_float2_to_vec3(rjd_math_float2 f, float z);
static inline rjd_math_vec3 rjd_math_float3_to_vec3(rjd_math_float3 f);
static inline rjd_math_vec3 rjd_math_float4_to_vec3(rjd_math_float4 f);

static inline rjd_math_vec4 rjd_math_float2_to_vec4(rjd_math_float2 f, float z, float w);
static inline rjd_math_vec4 rjd_math_float3_to_vec4(rjd_math_float3 f, float w);
static inline rjd_math_vec4 rjd_math_float4_to_vec4(rjd_math_float4 f);

static inline rjd_math_float2 rjd_math_vec3_to_float2(rjd_math_vec3 v);
static inline rjd_math_float3 rjd_math_vec3_to_float3(rjd_math_vec3 v);
static inline rjd_math_float4 rjd_math_vec3_to_float4(rjd_math_vec3 v, float w);

static inline rjd_math_float2 rjd_math_vec4_to_float2(rjd_math_vec4 v);
static inline rjd_math_float3 rjd_math_vec4_to_float3(rjd_math_vec4 v);
static inline rjd_math_float4 rjd_math_vec4_to_float4(rjd_math_vec4 v);

static inline rjd_math_float16 rjd_math_mat4_to_float16(rjd_math_mat4 m);

// vec4

#define rjd_math_vec4_shuffle(v4, x, y, z, w) ((rjd_math_vec4){_mm_shuffle_ps((v4).v, (v4).v, _MM_SHUFFLE(w, z, y, x))})

static inline rjd_math_vec4 rjd_math_vec4_zero(void);
static inline rjd_math_vec4 rjd_math_vec4_xyzw(float x, float y, float z, float w);
static inline rjd_math_vec4 rjd_math_vec4_splat(float v);
static inline rjd_math_vec4 rjd_math_vec4_one(void);
static inline rjd_math_vec4 rjd_math_vec4_setx(rjd_math_vec4 v, float x);
static inline rjd_math_vec4 rjd_math_vec4_sety(rjd_math_vec4 v, float y);
static inline rjd_math_vec4 rjd_math_vec4_setz(rjd_math_vec4 v, float z);
static inline rjd_math_vec4 rjd_math_vec4_setw(rjd_math_vec4 v, float w);
static inline float 		rjd_math_vec4_x(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_y(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_z(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_w(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_sum(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_dot(rjd_math_vec4 a, rjd_math_vec4 b);
static inline float 		rjd_math_vec4_lengthsq(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_length(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_i(rjd_math_vec4 v, size_t index);
static inline float			rjd_math_vec4_hmin(rjd_math_vec4 v);
static inline float			rjd_math_vec4_hmax(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_normalize(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_scale(rjd_math_vec4 v, float s);
static inline rjd_math_vec4 rjd_math_vec4_neg(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_add(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_sub(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_mul(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_div(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_min(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_max(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_project(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_lerp(rjd_math_vec4 a, rjd_math_vec4 b, float t);
static inline bool			rjd_math_vec4_eq(rjd_math_vec4 a, rjd_math_vec4 b);
static inline bool			rjd_math_vec4_ge(rjd_math_vec4 a, rjd_math_vec4 b);
static inline float*		rjd_math_vec4_write(rjd_math_vec4 v, float* out);

// vec3

#define rjd_math_vec3_shuffle(v3, x, y, z) ((rjd_math_vec3){_mm_shuffle_ps((v3).v, (v3).v, _MM_SHUFFLE(3, z, y, x))})

static inline rjd_math_vec3 rjd_math_vec3_zero(void);
static inline rjd_math_vec3 rjd_math_vec3_xyz(float x, float y, float z);
static inline rjd_math_vec3 rjd_math_vec3_splat(float v);
static inline rjd_math_vec3 rjd_math_vec3_one(void);
static inline rjd_math_vec3 rjd_math_vec3_up(void);
static inline rjd_math_vec3 rjd_math_vec3_down(void);
static inline rjd_math_vec3 rjd_math_vec3_left(void);
static inline rjd_math_vec3 rjd_math_vec3_right(void);
static inline rjd_math_vec3 rjd_math_vec3_forward(void);
static inline rjd_math_vec3 rjd_math_vec3_back(void);
static inline rjd_math_vec3 rjd_math_vec3_yzx(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_zxy(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_setx(rjd_math_vec3 v, float x);
static inline rjd_math_vec3 rjd_math_vec3_sety(rjd_math_vec3 v, float y);
static inline rjd_math_vec3 rjd_math_vec3_setz(rjd_math_vec3 v, float z);
static inline float 		rjd_math_vec3_x(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_y(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_z(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_sum(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_dot(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float 		rjd_math_vec3_angle(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float 		rjd_math_vec3_lengthsq(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_length(rjd_math_vec3 v);
static inline float			rjd_math_vec3_hmin(rjd_math_vec3 v);
static inline float			rjd_math_vec3_hmax(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_normalize(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_scale(rjd_math_vec3 v, float s);
static inline rjd_math_vec3 rjd_math_vec3_neg(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_add(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_sub(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_mul(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_div(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_cross(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_min(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_max(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_project(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_reflect(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_lerp(rjd_math_vec3 a, rjd_math_vec3 b, float t);
static inline bool			rjd_math_vec3_eq(rjd_math_vec3 a, rjd_math_vec3 b);
static inline bool			rjd_math_vec3_ge(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float*		rjd_math_vec3_write(rjd_math_vec3 v, float* out);
static inline float*		rjd_math_vec3_writefast(rjd_math_vec3 v, float* out); // writes 4 floats to out

// mat4

static inline rjd_math_mat4 rjd_math_mat4_identity(void);
static inline rjd_math_mat4 rjd_math_mat4_translation(rjd_math_vec3 trans);
//static inline rjd_math_mat4 rjd_math_mat4_rotation(rjd_math_quat rot); // TODO quaternions
static inline rjd_math_mat4 rjd_math_mat4_angleaxis(float angle, rjd_math_vec3 axis);
static inline rjd_math_mat4 rjd_math_mat4_rotationx(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationy(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationz(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationbasis(rjd_math_vec3 x, rjd_math_vec3 y, rjd_math_vec3 z);
static inline rjd_math_mat4 rjd_math_mat4_scaling(float scale);
static inline rjd_math_mat4 rjd_math_mat4_scaling_nonuniform(rjd_math_vec3 scale);
static inline rjd_math_mat4 rjd_math_mat4_add(rjd_math_mat4 a, rjd_math_mat4 b);
static inline rjd_math_mat4 rjd_math_mat4_mul(rjd_math_mat4 a, rjd_math_mat4 b);
static inline rjd_math_vec3 rjd_math_mat4_mulv3(rjd_math_mat4 m, rjd_math_vec3 v);
static inline rjd_math_vec4 rjd_math_mat4_mulv4(rjd_math_mat4 m, rjd_math_vec4 v);
static inline rjd_math_mat4 rjd_math_mat4_inv(rjd_math_mat4 m);
static inline rjd_math_mat4 rjd_math_mat4_transpose(rjd_math_mat4 m);
static inline rjd_math_mat4 rjd_math_mat4_frustum(float left, float right, float top, float bot, float near, float far);
static inline rjd_math_mat4 rjd_math_mat4_ortho_righthanded(float left, float right, float top, float bot, float near, float far);
static inline rjd_math_mat4 rjd_math_mat4_ortho_lefthanded(float left, float right, float top, float bot, float near, float far);
static inline rjd_math_mat4 rjd_math_mat4_perspective_righthanded(float y_fov, float aspect, float near, float far);
static inline rjd_math_mat4 ijd_math_mat4_perspective_lefthanded(float y_fov, float aspect, float near, float far);
static inline rjd_math_mat4 rjd_math_mat4_lookat_righthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up);
static inline rjd_math_mat4 rjd_math_mat4_lookat_lefthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up);
static inline float*		rjd_math_mat4_write_colmajor(rjd_math_mat4 m, float* out);
static inline float*		rjd_math_mat4_write_rowmajor(rjd_math_mat4 m, float* out);

// implementation

RJD_MATH_SIGN_FUNCS(RJD_MATH_DEFINE_SIGN_FUNC)
RJD_MATH_ISEQUAL_FUNCS(RJD_MATH_DEFINE_ISEQUAL_FUNC)
RJD_MATH_MIN_FUNCS(RJD_MATH_DEFINE_MIN_FUNC)
RJD_MATH_MAX_FUNCS(RJD_MATH_DEFINE_MAX_FUNC)
RJD_MATH_CLAMP_FUNCS(RJD_MATH_DEFINE_CLAMP_FUNC)
RJD_MATH_TRUNCATE_FUNCS(RJD_MATH_DEFINE_TRUNCATE_FUNC)
RJD_MATH_REMAP_FUNCS(RJD_MATH_DEFINE_REMAP_FUNC)

static inline uint32_t rjd_math_next_pow2(uint32_t v) 
{
	--v;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;

	return v;
}

static inline int32_t rjd_math_pow32(int32_t v, uint32_t power)
{
	int32_t r = 1;
	while (power) {
		r *= v;
		--power;
	}
	return r;
}

// vec <-> float tranlations

static inline rjd_math_float2 rjd_math_float2_xy(float x, float y)
{
	return (rjd_math_float2){{ x, y }};
}
static inline rjd_math_float3 rjd_math_float3_xyz(float x, float y, float z)
{
	return (rjd_math_float3){{ x, y, z }};
}
static inline rjd_math_float4 rjd_math_float4_xyzw(float x, float y, float z, float w)
{
	return (rjd_math_float4){{ x, y, z, w }};
}

static inline rjd_math_vec3 rjd_math_float2_to_vec3(rjd_math_float2 f, float z)
{
	return rjd_math_vec3_xyz(f.x, f.y, z);
}
static inline rjd_math_vec3 rjd_math_float3_to_vec3(rjd_math_float3 f)
{
	return rjd_math_vec3_xyz(f.x, f.y, f.z);
}
static inline rjd_math_vec3 rjd_math_float4_to_vec3(rjd_math_float4 f)
{
	return rjd_math_vec3_xyz(f.x, f.y, f.z);
}

static inline rjd_math_vec4 rjd_math_float2_to_vec4(rjd_math_float2 f, float z, float w)
{
	return rjd_math_vec4_xyzw(f.x, f.y, z, w);
}
static inline rjd_math_vec4 rjd_math_float3_to_vec4(rjd_math_float3 f, float w)
{
	return rjd_math_vec4_xyzw(f.x, f.y, f.z, w);
}
static inline rjd_math_vec4 rjd_math_float4_to_vec4(rjd_math_float4 f)
{
	return rjd_math_vec4_xyzw(f.x, f.y, f.z, f.w);
}

static inline rjd_math_float2 rjd_math_vec3_to_float2(rjd_math_vec3 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec3_writefast(v, f.v);
	return (rjd_math_float2){ .x = f.x, .y = f.y };
}
static inline rjd_math_float3 rjd_math_vec3_to_float3(rjd_math_vec3 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec3_writefast(v, f.v);
	return (rjd_math_float3){ .x = f.x, .y = f.y, .z = f.z };
}
static inline rjd_math_float4 rjd_math_vec3_to_float4(rjd_math_vec3 v, float w)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec3_writefast(v, f.v);
	f.w = w;
	return f;
}

static inline rjd_math_float2 rjd_math_vec4_to_float2(rjd_math_vec4 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec4_write(v, f.v);
	return (rjd_math_float2){ .x = f.x, .y = f.y };
}
static inline rjd_math_float3 rjd_math_vec4_to_float3(rjd_math_vec4 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec4_write(v, f.v);
	return (rjd_math_float3){ .x = f.x, .y = f.y, .z = f.z };
}
static inline rjd_math_float4 rjd_math_vec4_to_float4(rjd_math_vec4 v)
{
	RJD_FORCE_ALIGN(rjd_math_float4, 16) f;
	rjd_math_vec4_write(v, f.v);
	return f;
}

static inline rjd_math_float16 rjd_math_mat4_to_float16(rjd_math_mat4 m)
{
	RJD_FORCE_ALIGN(rjd_math_float16, 16) f;
	rjd_math_mat4_write_colmajor(m, f.v);
	return f;
}

// vec3 <-> vec4 conversion helpers

static inline rjd_math_vec4 rjd_math_vec3to4(rjd_math_vec3 v3) {
	rjd_math_vec4 v4 = { v3.v };
	return v4;
}

static inline rjd_math_vec3 rjd_math_vec4to3(rjd_math_vec4 v4) {
	rjd_math_vec3 v3 = { v4.v };
	return v3;
}

static inline rjd_math_vec4 rjd_math_vec3to4w(rjd_math_vec3 v3, float w) {
	rjd_math_vec4 v4 = rjd_math_vec3to4(v3);
	return rjd_math_vec4_setw(v4, w);
}

static inline rjd_math_vec3 rjd_math_vec4to3w(rjd_math_vec4 v4) {
	v4 = rjd_math_vec4_setw(v4, 0);
	return rjd_math_vec4to3(v4);
}

// vec4

static inline rjd_math_vec4 rjd_math_vec4_zero(void) {
	rjd_math_vec4 v = { _mm_setzero_ps() };
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_xyzw(float x, float y, float z, float w) {
	rjd_math_vec4 v = { _mm_set_ps(w, z, y, x) }; 
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_splat(float f) {
	rjd_math_vec4 v = { _mm_set1_ps(f) };
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_one(void) {
	return rjd_math_vec4_splat(1);
}
static inline rjd_math_vec4 rjd_math_vec4_setx(rjd_math_vec4 v, float x) {
	v.v = _mm_move_ss(v.v, rjd_math_vec4_splat(x).v);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_sety(rjd_math_vec4 v, float y) {
	v = rjd_math_vec4_shuffle(v, 1, 0, 2, 3);
	v = rjd_math_vec4_setx(v, y);
	v = rjd_math_vec4_shuffle(v, 1, 0, 2, 3);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_setz(rjd_math_vec4 v, float z) {
	v = rjd_math_vec4_shuffle(v, 2, 1, 0, 3);
	v = rjd_math_vec4_setx(v, z);
	v = rjd_math_vec4_shuffle(v, 2, 1, 0, 3);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_setw(rjd_math_vec4 v, float w) {
	v = rjd_math_vec4_shuffle(v, 3, 1, 2, 0);
	v = rjd_math_vec4_setx(v, w);
	v = rjd_math_vec4_shuffle(v, 3, 1, 2, 0);
	return v;
}
static inline float rjd_math_vec4_x(rjd_math_vec4 v) {
	return _mm_cvtss_f32(v.v);
}
static inline float rjd_math_vec4_y(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 1, 0, 2, 3));
}
static inline float rjd_math_vec4_z(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 2, 1, 0, 3));
}
static inline float rjd_math_vec4_w(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 3, 1, 2, 0));
}
static inline float rjd_math_vec4_sum(rjd_math_vec4 v) {
	v.v = _mm_hadd_ps(v.v, v.v);
	v.v = _mm_hadd_ps(v.v, v.v);
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_dot(rjd_math_vec4 a, rjd_math_vec4 b) {
	rjd_math_vec4 product = rjd_math_vec4_mul(a,b);
	return rjd_math_vec4_sum(product);
}
static inline float rjd_math_vec4_lengthsq(rjd_math_vec4 v) {
	return rjd_math_vec4_dot(v, v);
}
static inline float rjd_math_vec4_length(rjd_math_vec4 v) {
	return sqrtf(rjd_math_vec4_lengthsq(v));
}
static inline float rjd_math_vec4_hmin(rjd_math_vec4 v) {
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,1,1,2,3));
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,2,1,2,3));
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,3,1,2,3));
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_hmax(rjd_math_vec4 v) {
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,1,1,2,3));
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,2,1,2,3));
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,3,1,2,3));
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_i(rjd_math_vec4 v, size_t index) {
	switch(index) {
		case 0:	v = rjd_math_vec4_shuffle(v,0,0,0,0); break;
		case 1:	v = rjd_math_vec4_shuffle(v,1,1,1,1); break;
		case 2:	v = rjd_math_vec4_shuffle(v,2,2,2,2); break;
		case 3:	v = rjd_math_vec4_shuffle(v,3,3,3,3); break;
		default:
			RJD_ASSERTFAIL("index must be between 0 and 3");
			break;
	}
	return rjd_math_vec4_x(v);
}
static inline rjd_math_vec4 rjd_math_vec4_normalize(rjd_math_vec4 v) {
	float length = rjd_math_vec4_length(v);
	RJD_ASSERT(length != 0);
	rjd_math_vec4 l = rjd_math_vec4_splat(length);
	return rjd_math_vec4_div(v, l);
}
static inline rjd_math_vec4 rjd_math_vec4_scale(rjd_math_vec4 v, float s) {
	rjd_math_vec4 scales = rjd_math_vec4_splat(s);
	return rjd_math_vec4_mul(v, scales);
}
static inline rjd_math_vec4 rjd_math_vec4_neg(rjd_math_vec4 v) {
	return rjd_math_vec4_scale(v, -1);
}
static inline rjd_math_vec4 rjd_math_vec4_add(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_add_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_sub(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_sub_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_mul(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_mul_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_div(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_div_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_min(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_min_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_max(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_max_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_project(rjd_math_vec4 a, rjd_math_vec4 b) {
	float dot = rjd_math_vec4_dot(a, b);
	float lb = rjd_math_vec4_length(b);
	return rjd_math_vec4_scale(b, dot / lb);
}
static inline rjd_math_vec4 rjd_math_vec4_lerp(rjd_math_vec4 a, rjd_math_vec4 b, float t) {
	rjd_math_vec4 v = rjd_math_vec4_sub(b, a);
	v = rjd_math_vec4_scale(v, t);
	v = rjd_math_vec4_add(v, a);
	return v;
}
static inline bool rjd_math_vec4_eq(rjd_math_vec4 a, rjd_math_vec4 b) {
	return (_mm_movemask_ps(_mm_cmpeq_ps(a.v, b.v)) & 0xF) == 0xF;
}
static inline bool rjd_math_vec4_ge(rjd_math_vec4 a, rjd_math_vec4 b) {
	return (_mm_movemask_ps(_mm_cmpge_ps(a.v, b.v)) & 0xF) == 0xF;
}
static inline float* rjd_math_vec4_write(rjd_math_vec4 v, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out,  v.v);
	return out + 4;
}

// vec3

static inline rjd_math_vec3 rjd_math_vec3_zero(void) { 
	return rjd_math_vec4to3(rjd_math_vec4_zero());
}
static inline rjd_math_vec3 rjd_math_vec3_xyz(float x, float y, float z) {
	return rjd_math_vec4to3(rjd_math_vec4_xyzw(x,y,z,0));
}
static inline rjd_math_vec3 rjd_math_vec3_splat(float v) { return rjd_math_vec3_xyz(v,v,v); }
static inline rjd_math_vec3 rjd_math_vec3_one(void) { return rjd_math_vec3_xyz(1,1,1); }
static inline rjd_math_vec3 rjd_math_vec3_up(void) { return rjd_math_vec3_xyz(0,1,0); }
static inline rjd_math_vec3 rjd_math_vec3_down(void) { return rjd_math_vec3_xyz(0,-1,0); }
static inline rjd_math_vec3 rjd_math_vec3_left(void) { return rjd_math_vec3_xyz(-1,0,0); }
static inline rjd_math_vec3 rjd_math_vec3_right(void) { return rjd_math_vec3_xyz(1,0,0); }
static inline rjd_math_vec3 rjd_math_vec3_forward(void) { return rjd_math_vec3_xyz(0,0,1); }
static inline rjd_math_vec3 rjd_math_vec3_back(void) { return rjd_math_vec3_xyz(0,0,-1); }
static inline rjd_math_vec3 rjd_math_vec3_yzx(rjd_math_vec3 v) {
	return rjd_math_vec3_shuffle(v, 1, 2, 0);
}
static inline rjd_math_vec3 rjd_math_vec3_zxy(rjd_math_vec3 v) {
	return rjd_math_vec3_shuffle(v, 2, 0, 1);
}
static inline rjd_math_vec3 rjd_math_vec3_setx(rjd_math_vec3 v, float x) {
	v.v = _mm_move_ss(v.v, rjd_math_vec3_splat(x).v);
	return v;
}
static inline rjd_math_vec3 rjd_math_vec3_sety(rjd_math_vec3 v, float y) {
	return rjd_math_vec4to3(rjd_math_vec4_sety(rjd_math_vec3to4(v), y));
}
static inline rjd_math_vec3 rjd_math_vec3_setz(rjd_math_vec3 v, float z) {
	return rjd_math_vec4to3(rjd_math_vec4_setz(rjd_math_vec3to4(v), z));
}
static inline float rjd_math_vec3_x(rjd_math_vec3 v) {
	return rjd_math_vec4_x(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_y(rjd_math_vec3 v) {
	return rjd_math_vec4_y(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_z(rjd_math_vec3 v) {
	return rjd_math_vec4_z(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_sum(rjd_math_vec3 v) {
	return rjd_math_vec4_sum(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_dot(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4_dot(rjd_math_vec3to4(a), rjd_math_vec3to4(b));
}
static inline float rjd_math_vec3_angle(rjd_math_vec3 a, rjd_math_vec3 b) {
	float dot = rjd_math_vec3_dot(a, b);
	float la = rjd_math_vec3_length(a);
	float lb = rjd_math_vec3_length(b);
	return acosf(dot / (la * lb));
}
static inline float rjd_math_vec3_lengthsq(rjd_math_vec3 v) {
	return rjd_math_vec4_lengthsq(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_length(rjd_math_vec3 v) {
	return rjd_math_vec4_length(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_hmin(rjd_math_vec3 v) {
	v = rjd_math_vec3_min(v, rjd_math_vec3_shuffle(v,1,1,2));
	v = rjd_math_vec3_min(v, rjd_math_vec3_shuffle(v,2,1,2));
	return rjd_math_vec3_x(v);
}
static inline float rjd_math_vec3_hmax(rjd_math_vec3 v) {
	v = rjd_math_vec3_max(v, rjd_math_vec3_shuffle(v,1,1,2));
	v = rjd_math_vec3_max(v, rjd_math_vec3_shuffle(v,2,1,2));
	return rjd_math_vec3_x(v);
}
static inline rjd_math_vec3 rjd_math_vec3_normalize(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_normalize(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_scale(rjd_math_vec3 v, float s) {
	return rjd_math_vec4to3(rjd_math_vec4_scale(rjd_math_vec3to4(v), s));
}
static inline rjd_math_vec3 rjd_math_vec3_neg(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_neg(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_add(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_add(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_sub(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_sub(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_mul(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_mul(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_div(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_div(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_cross(rjd_math_vec3 a, rjd_math_vec3 b) {
	rjd_math_vec3 ap = rjd_math_vec3_mul(rjd_math_vec3_yzx(a), rjd_math_vec3_zxy(b));
	rjd_math_vec3 bp = rjd_math_vec3_mul(rjd_math_vec3_zxy(a), rjd_math_vec3_yzx(b));
	return rjd_math_vec3_sub(ap, bp);
}
static inline rjd_math_vec3 rjd_math_vec3_min(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_min(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_max(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_max(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_project(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_project(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_reflect(rjd_math_vec3 v, rjd_math_vec3 n) {
	RJD_ASSERT(rjd_math_vec3_eq(n, rjd_math_vec3_normalize(n)));
	rjd_math_vec3 projected = rjd_math_vec3_scale(n, 2 * rjd_math_vec3_dot(v, n));
	return rjd_math_vec3_sub(v, projected);
}
static inline rjd_math_vec3 rjd_math_vec3_lerp(rjd_math_vec3 a, rjd_math_vec3 b, float t) {
	return rjd_math_vec4to3(rjd_math_vec4_lerp(rjd_math_vec3to4(a), rjd_math_vec3to4(b), t));
}
static inline bool rjd_math_vec3_eq(rjd_math_vec3 a, rjd_math_vec3 b) {
	return (_mm_movemask_ps(_mm_cmpeq_ps(a.v, b.v)) & 7) == 7; // 7 is the platform-independent version of 0b111
}
static inline bool rjd_math_vec3_ge(rjd_math_vec3 a, rjd_math_vec3 b) {
	return (_mm_movemask_ps(_mm_cmpge_ps(a.v, b.v)) & 7) == 7;
}
static inline float* rjd_math_vec3_write(rjd_math_vec3 v, float* out) {
	RJD_FORCE_ALIGN(float, 16) tmp[4];
	_mm_stream_ps(tmp, v.v);
	memcpy(out, tmp, sizeof(float) * 3);
	return out + 3;
}
static inline float* rjd_math_vec3_writefast(rjd_math_vec3 v, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out, v.v);
	return out + 3;
}

// mat4

static inline rjd_math_mat4 rjd_math_mat4_identity(void) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(1,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,1,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,1,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_translation(rjd_math_vec3 trans) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(1,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,1,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,1,0);
	m.m[3] = rjd_math_vec3to4w(trans, 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_angleaxis(float angle, rjd_math_vec3 axis) {
	rjd_math_mat4 m;

	// TODO optimize
	float c = cosf(angle);
	float k = 1 - c;
	float s = sinf(angle);

	float x = rjd_math_vec3_x(axis);
	float y = rjd_math_vec3_y(axis);
	float z = rjd_math_vec3_z(axis);

	//rjd_math_vec4 axis4 = rjd_math_vec3to4w(axis,1); // x,y,z,1
	//rjd_math_vec4 tmp1 = rjd_math_vec4_mul(axis4, rjd_math_vec4_xyzw(s,s,s,c)); // x*s, y*s, z*s, c
	//rjd_math_vec4 vk = rjd_math_vec4_splat(k);

	//rjd_math_vec4 v0 = rjd_math_vec4_mul(axis4, rjd_math_vec4_shuffle(axis4,0,0,0,3));
	//v0 = rjd_math_vec4_mul(v0, vk);

	//v0 = rjd_math_vec4_add(v0, rjd_math_vec4_shuffle(tmp1,3,2,1));

	//m.m[0] = 


	//vec3 diagonal = rjd_math_vec3_mul(axis, axis);
	//diagonal = rjd_math_vec3_mul(diagonal, veck);
	//diagonal = rjd_math_vec3_add(diagonal, rjd_math_vec3_splat(c));
	
	float m00 = k*x*x + c;
	float m10 = k*x*y + z*s;
	float m20 = k*x*z - y*s;

	float m01 = k*x*y - z*s;
	float m11 = k*y*y + c;
	float m21 = k*y*z + x*s;

	float m02 = k*x*z + y*s;
	float m12 = k*y*z - x*s;
	float m22 = k*z*z + c;

	m.m[0] = rjd_math_vec4_xyzw(m00, m10, m20, 0);
	m.m[1] = rjd_math_vec4_xyzw(m01, m11, m21, 0);
	m.m[2] = rjd_math_vec4_xyzw(m02, m12, m22, 0);
	m.m[3] = rjd_math_vec4_xyzw(  0,   0,   0, 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_rotationx(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_right());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationy(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_up());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationz(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_forward());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationbasis(rjd_math_vec3 x, rjd_math_vec3 y, rjd_math_vec3 z) {
	rjd_math_vec4 xx = rjd_math_vec3to4(x);
	rjd_math_vec4 yy = rjd_math_vec3to4(y);
	rjd_math_vec4 zz = rjd_math_vec3to4(z);
	rjd_math_mat4 m = { { xx, yy, zz, rjd_math_vec4_xyzw(0,0,0,1) } };
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_scaling(float s) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(s,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,s,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,s,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_scaling_nonuniform(rjd_math_vec3 scale) {
	float x = rjd_math_vec3_x(scale);
	float y = rjd_math_vec3_y(scale);
	float z = rjd_math_vec3_z(scale);

	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(x,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,y,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,z,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_add(rjd_math_mat4 a, rjd_math_mat4 b) {
    rjd_math_mat4 m = {0};
	for (size_t i = 0; i < rjd_countof(m.m); ++i) {
		m.m[i] = rjd_math_vec4_add(a.m[i], b.m[i]);
	}
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_mul(rjd_math_mat4 a, rjd_math_mat4 b) {
	rjd_math_mat4 t = rjd_math_mat4_transpose(a);
    rjd_math_mat4 m = {0};
	for (size_t i = 0; i < rjd_countof(m.m); ++i) {
		m.m[i] = rjd_math_mat4_mulv4(t, b.m[i]);
	}
	return m;
}
static inline rjd_math_vec3 rjd_math_mat4_mulv3(rjd_math_mat4 m, rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_mat4_mulv4(m, rjd_math_vec3to4w(v, 1)));
}
static inline rjd_math_vec4 rjd_math_mat4_mulv4(rjd_math_mat4 m, rjd_math_vec4 v) {
	// TODO optimize
	rjd_math_mat4 trans = rjd_math_mat4_transpose(m);
	float x = rjd_math_vec4_dot(trans.m[0], v);
	float y = rjd_math_vec4_dot(trans.m[1], v);
	float z = rjd_math_vec4_dot(trans.m[2], v);
	float w = rjd_math_vec4_dot(trans.m[3], v);
	return rjd_math_vec4_xyzw(x, y, z, w);
}
static inline rjd_math_mat4 rjd_math_mat4_inv(rjd_math_mat4 m) {
	rjd_math_mat4 t = rjd_math_mat4_transpose(m);
	rjd_math_vec4 t0 = t.m[0];
	rjd_math_vec4 t1 = t.m[1];
	rjd_math_vec4 t2 = t.m[2];
	rjd_math_vec4 t3 = t.m[3];
	
	rjd_math_mat4 inv;
	rjd_math_vec4 term;

	// first column
	//inv0.x = m11m22m33 + m12m23m31 + m13m21m32 - m11m23m32 - m12m21m33 - m13m22m31;
	//inv0.y = m10m23m32 + m12m20m33 + m13m22m30 - m10m22m33 - m12m23m30 - m13m20m32;
	//inv0.z = m10m21m31 + m11m23m30 + m13m20m31 - m10m23m30 - m11m20m33 - m13m21m30;
	//inv0.w = m10m22m31 + m11m20m32 + m12m21m30 - m10m21m32 - m11m22m30 - m12m20m31;
	//																		x		  y			z		  w
	term = rjd_math_vec4_shuffle(t1,1,0,0,0);							// m11,		 m10,      m10,      m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); 	// m11m22,   m10m23,   m10m21,   m10m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,1,1)); 	// m11m22m33,m10m23m32,m10m21m31,m10m22m31
	inv.m[0] = term;

	term = rjd_math_vec4_shuffle(t1,2,2,1,1);							// m12,      m12,      m11,      m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); 	// m12m23,   m12m20,   m11m23,   m11m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); 	// m12m23m31,m12m20m33,m11m23m30,m11m20m32
	inv.m[0] = rjd_math_vec4_add(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,3,3,3,2);							// m13,      m13,      m13,      m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); 	// m13m21,   m13m22,   m13m20,   m12m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,1,1)); 	// m13m21m32,m13m22m30,m13m20m31,m12m21m30
	inv.m[0] = rjd_math_vec4_add(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,1,0,0,0);							// m11,      m10,      m10,      m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); 	// m11m23,   m10m22,   m10m23,   m10m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,0,2)); 	// m11m23m32,m10m22m33,m10m23m30,m10m21m32
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,2,2,1,1);							// m12,      m12,      m11,      m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); 	// m12m21,   m12m23,   m11m20,   m11m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); 	// m12m21m33,m12m23m30,m11m20m33,m11m22m30
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,3,3,3,2);							// m13,      m13,      m13,      m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); 	// m13m22,   m13m20,   m13m21,   m12m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,2,0,1)); 	// m13m22m31,m13m20m32,m13m21m30,m12m20m31
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	// second column
	// inv.m[1].x = m01m23m32 + m02m21m33 + m03m22m31 - m01m22m33 - m02m23m31 - m03m21m32
	// inv.m[1].y = m00m22m33 + m02m23m30 + m03m20m30 - m00m23m32 - m02m20m33 - m03m22m30
	// inv.m[1].z = m00m23m31 + m01m20m33 + m03m21m30 - m00m21m33 - m01m23m30 - m03m20m31
	// inv.m[1].w = m00m21m32 + m01m22m30 + m02m20m31 - m00m22m31 - m01m20m32 - m02m21m30
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                         // m01,      m00,      m00,      m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); // m01m23,   m00m22,   m00m23,   m00m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,1,2)); // m01m23m32,m00m22m33,m00m23m31,m00m21m32
	inv.m[1] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                         // m02,      m02,      m01,      m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); // m02m21,   m02m23,   m01m20,   m01m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); // m02m21m33,m02m23m30,m01m20m33,m01m22m30
	inv.m[1] = rjd_math_vec4_add(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                         // m03,      m03,      m03,      m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); // m03m22,   m03m20,   m03m21,   m02m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,0,0,1)); // m03m22m31,m03m20m30,m03m21m30,m02m20m31
	inv.m[1] = rjd_math_vec4_add(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                         // m01,      m00,      m00,      m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); // m01m22,   m00m23,   m00m21,   m00m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,3,1)); // m01m22m33,m00m23m32,m00m21m33,m00m22m31
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                         // m02,      m02,      m01,      m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); // m02m23,   m02m20,   m01m23,   m01m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); // m02m23m31,m02m20m33,m01m23m30,m01m20m32
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                         // m03,      m03,      m03,      m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,2,0,1)); // m03m21,   m03m22,   m03m20,   m02m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,0,1,0)); // m03m21m32,m03m22m30,m03m20m31,m02m21m30
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	// third column
	// inv.m[2].x = m01m12m33 + m02m13m31 + m03m11m32 - m01m13m32 - m02m11m33 - m03m12m31
	// inv.m[2].y = m00m13m32 + m02m10m33 + m03m12m30 - m00m12m33 - m02m13m30 - m03m10m32
	// inv.m[2].z = m00m11m33 + m01m13m30 + m03m10m31 - m00m13m31 - m01m10m33 - m01m11m30
	// inv.m[2].w = m00m12m31 + m01m10m32 + m02m11m30 - m00m11m32 - m01m12m30 - m02m10m31
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01       m00       m00       m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,3,1,2)); // m01m12    m00m13    m00m11    m00m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,3,1)); // m01m12m33 m00m13m32 m00m11m33 m00m12m31
	inv.m[2] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02       m02       m01       m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,0,3,0)); // m02m13    m02m10    m01m13    m01m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); // m02m13m31 m02m10m33 m01m13m30 m01m10m32
	inv.m[2] = rjd_math_vec4_add(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03       m03       m03       m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,2,0,1)); // m03m11    m03m12    m03m10    m02m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,0,1,0)); // m03m11m32 m03m12m30 m03m10m31 m02m11m30
	inv.m[2] = rjd_math_vec4_add(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01       m00       m00       m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,2,3,1)); // m01m13    m00m12    m00m13    m00m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,1,2)); // m01m13m32 m00m12m33 m00m13m31 m00m11m32
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02       m02       m01       m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,3,0,2)); // m02m11    m02m13    m01m10    m01m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); // m02m11m33 m02m13m30 m01m10m33 m01m12m30
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,3,3,1,2);                          // m03       m03       m01       m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,0,1,0)); // m03m12    m03m10    m01m11    m02m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,2,0,1)); // m03m12m31 m03m10m32 m01m11m30 m02m10m31
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);	

	// fourth column
	// inv.m[3].x = m01m13m22 + m02m11m23 + m03m12m21 - m01m12m23 - m02m13m21 - m03m11m22
	// inv.m[3].y = m00m12m23 + m02m13m20 + m03m10m22 - m00m13m22 - m02m10m23 - m03m12m20
	// inv.m[3].z = m00m13m21 + m01m13m23 + m03m11m20 - m00m11m23 - m01m13m20 - m03m10m21
	// inv.m[3].w = m00m11m22 + m01m12m20 + m02m10m21 - m00m12m21 - m01m10m22 - m02m11m20
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01 m00 m00 m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,2,3,1)); // m01m13 m00m12 m00m13 m00m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); // m01m13m22 m00m12m23 m00m13m21 m00m11m22
	inv.m[3] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02 m02 m01 m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,3,3,2)); // m02m11 m02m13 m01m13 m01m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); // m02m11m23 m02m13m20 m01m13m23 m01m12m20
	inv.m[3] = rjd_math_vec4_add(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03 m03 m03 m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,0,1,0)); // m03m12 m03m10 m03m11 m02m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,2,0,1)); // m03m12m21 m03m10m22 m03m11m20 m02m10m21
	inv.m[3] = rjd_math_vec4_add(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01 m00 m00 m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,3,1,2)); // m01m12 m00m13 m00m11 m00m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); // m01m12m23 m00m13m22 m00m11m23 m00m12m21
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02 m02 m01 m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,0,3,0)); // m02m13 m02m10 m01m13 m01m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); // m02m13m21 m02m10m23 m01m13m20 m01m10m22
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03 m03 m03 m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,2,0,1)); // m03m11 m03m12 m03m10 m02m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); // m03m11m22 m03m12m20 m03m10m21 m02m11m20
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	rjd_math_mat4 trans = rjd_math_mat4_transpose(inv);
	rjd_math_vec4 det = rjd_math_vec4_mul(trans.m[0], m.m[0]);

	det.v = _mm_hadd_ps(det.v, det.v);
	det.v = _mm_hadd_ps(det.v, det.v);
	det = rjd_math_vec4_shuffle(det,0,0,0,0);

	RJD_ASSERTMSG(!rjd_math_isequalf(rjd_math_vec4_x(det), 0), "Matrix is not invertible - if you're not sure, check rjd_math_mat4_det() == 0 beforehand");

	rjd_math_vec4 det_reciprocal = {_mm_rcp_ps(det.v)};

    rjd_math_mat4 out = {0};
	for (size_t i = 0; i < rjd_countof(out.m); ++i) {
		out.m[i] = rjd_math_vec4_mul(det_reciprocal, inv.m[i]);
	}

	// NOTE that intel's implementation is 82 intrinsics while this is at least 140(cofactor) + 9(determinant) + 
	// 		12(transpose) + 12(transpose), but this implementation is more straightforward

	return out;
}
static inline rjd_math_mat4 rjd_math_mat4_transpose(rjd_math_mat4 m) {
	_MM_TRANSPOSE4_PS(m.m[0].v, m.m[1].v, m.m[2].v, m.m[3].v);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_frustum(float left, float right, float top, float bot, float near, float far) {
	RJD_UNUSED_PARAM(left);
	RJD_UNUSED_PARAM(right);
	RJD_UNUSED_PARAM(top);
	RJD_UNUSED_PARAM(bot);
	RJD_UNUSED_PARAM(near);
	RJD_UNUSED_PARAM(far);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_ortho_righthanded(float left, float right, float top, float bot, float near, float far) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(           2/(right-left),                   0,               0, 0);
	m.m[1] = rjd_math_vec4_xyzw(                        0,         2/(top-bot),               0, 0);
	m.m[2] = rjd_math_vec4_xyzw(                        0,                   0,    1/(near-far), 0);
	m.m[3] = rjd_math_vec4_xyzw((left+right)/(left-right), (top+bot)/(bot-top), near/(near-far), 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_ortho_lefthanded(float left, float right, float top, float bot, float near, float far) {
	RJD_ASSERTFAIL("not implemented");
	RJD_UNUSED_PARAM(left);
	RJD_UNUSED_PARAM(right);
	RJD_UNUSED_PARAM(top);
	RJD_UNUSED_PARAM(bot);
	RJD_UNUSED_PARAM(near);
	RJD_UNUSED_PARAM(far);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_perspective_righthanded(float y_fov, float aspect, float near, float far) {
	RJD_ASSERTFAIL("not implemented");
	RJD_UNUSED_PARAM(y_fov);
	RJD_UNUSED_PARAM(aspect);
	RJD_UNUSED_PARAM(near);
	RJD_UNUSED_PARAM(far);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_perspective_lefthanded(float y_fov, float aspect, float near, float far) {
	RJD_ASSERTFAIL("not implemented");
	RJD_UNUSED_PARAM(y_fov);
	RJD_UNUSED_PARAM(aspect);
	RJD_UNUSED_PARAM(near);
	RJD_UNUSED_PARAM(far);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_lookat_righthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up) {
	rjd_math_vec3 forward = rjd_math_vec3_normalize(rjd_math_vec3_sub(target, eye));
	rjd_math_vec3 left = rjd_math_vec3_normalize(rjd_math_vec3_cross(forward, up));
	up = rjd_math_vec3_normalize(rjd_math_vec3_cross(left, forward));

	rjd_math_mat4 rot = rjd_math_mat4_rotationbasis(left, up, rjd_math_vec3_neg(forward));
	rjd_math_mat4 trans = rjd_math_mat4_translation(rjd_math_vec3_neg(eye));
	return rjd_math_mat4_mul(trans, rjd_math_mat4_transpose(rot));
}
static inline rjd_math_mat4 rjd_math_mat4_lookat_lefthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up) {
	RJD_ASSERTFAIL("not implemented");
	RJD_UNUSED_PARAM(eye);
	RJD_UNUSED_PARAM(target);
	RJD_UNUSED_PARAM(up);
	return rjd_math_mat4_identity();
}
static inline float* rjd_math_mat4_write_colmajor(rjd_math_mat4 m, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out + 0,  m.m[0].v);
	_mm_stream_ps(out + 4,  m.m[1].v);
	_mm_stream_ps(out + 8,  m.m[2].v);
	_mm_stream_ps(out + 12, m.m[3].v);
	return out + 16;
}
static inline float* rjd_math_mat4_write_rowmajor(rjd_math_mat4 m, float* out) {
	rjd_math_mat4 transpose = rjd_math_mat4_transpose(m);
	return rjd_math_mat4_write_colmajor(transpose, out);
}


////////////////////////////////////////////////////////////////////////////////
// rjd_geo.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_GEO_H 1

typedef struct {
	rjd_math_vec4 minmax; // xy is the min, zw is the max
} rjd_geo_rect;

typedef struct {
	rjd_math_vec3 xyr; // z is the radius
} rjd_geo_circle;

typedef struct {
	rjd_math_vec3 min;
	rjd_math_vec3 max;
} rjd_geo_box;

typedef struct {
	rjd_math_vec4 xyzr; // w is the radius
} rjd_geo_sphere;

typedef struct {
	rjd_math_vec3 p;
	rjd_math_vec3 d;
} rjd_geo_ray;

rjd_geo_rect rjd_geo_rect_minmax(float minx, float miny, float maxx, float maxy);
rjd_geo_circle rjd_geo_circle_xyr(float x, float y, float r);
rjd_geo_box rjd_geo_box_minmax(rjd_math_vec3 min,  rjd_math_vec3 max);
rjd_geo_sphere rjd_geo_sphere_xyzr(float x, float y, float z, float r);
rjd_geo_ray rjd_geo_ray_pd(rjd_math_vec3 p,  rjd_math_vec3 d);

bool rjd_geo_point_rect(rjd_math_vec3 p, rjd_geo_rect r);
bool rjd_geo_point_box(rjd_math_vec3 p, rjd_geo_box b);
bool rjd_geo_point_circle(rjd_math_vec3 p, rjd_geo_circle c);
bool rjd_geo_point_sphere(rjd_math_vec3 p, rjd_geo_sphere s);
bool rjd_geo_circle_circle(rjd_geo_circle c1, rjd_geo_circle c2);
bool rjd_geo_circle_rect(rjd_geo_circle c, rjd_geo_rect r);
bool rjd_geo_rect_rect(rjd_geo_rect a, rjd_geo_rect b);
bool rjd_geo_sphere_sphere(rjd_geo_sphere b, rjd_geo_sphere a);
bool rjd_geo_sphere_box(rjd_geo_sphere s, rjd_geo_box b);
bool rjd_geo_box_box(rjd_geo_box a, rjd_geo_box b);
bool rjd_geo_ray_point(rjd_geo_ray r, rjd_math_vec3 p, float* t_out);
bool rjd_geo_ray_sphere(rjd_geo_ray r, rjd_geo_sphere s, float* t_out);
bool rjd_geo_ray_box(rjd_geo_ray r, rjd_geo_box b, float* t_out);
bool rjd_geo_ray_boxfast(rjd_math_vec3 ray_pos, rjd_math_vec3 ray_inv_dir, rjd_geo_box b, float* t_out);

#if RJD_IMPL

rjd_geo_rect rjd_geo_rect_minmax(float minx, float miny, float maxx, float maxy) {
	RJD_ASSERT(minx <= maxx);
	RJD_ASSERT(miny <= maxy);
	rjd_geo_rect r = { rjd_math_vec4_xyzw(minx, miny, maxx, maxy) };
	return r;
}

rjd_geo_circle rjd_geo_circle_xyr(float x, float y, float r) {
	rjd_geo_circle c = { rjd_math_vec3_xyz(x,y,r) };
	return c;
}

rjd_geo_box rjd_geo_box_minmax(rjd_math_vec3 min, rjd_math_vec3 max) {
	rjd_geo_box b = { min, max };
	return b;
}

rjd_geo_sphere rjd_geo_sphere_xyzr(float x, float y, float z, float r) {
	rjd_geo_sphere s = { rjd_math_vec4_xyzw(x,y,z,r) };
	return s;
}

rjd_geo_ray rjd_geo_ray_pd(rjd_math_vec3 p, rjd_math_vec3 d) {
	rjd_geo_ray r = { p, d };
	return r;
}

bool rjd_geo_point_rect(rjd_math_vec3 p, rjd_geo_rect r) {
	rjd_math_vec4 pp = rjd_math_vec3to4(p);
	pp = rjd_math_vec4_shuffle(pp,0,1,0,1); // { x,y,x,y }

	rjd_math_vec4 a = { _mm_unpackhi_ps(pp.v, r.minmax.v) }; // { x maxx y maxy }
	rjd_math_vec4 b = { _mm_unpacklo_ps(pp.v, r.minmax.v) }; // { x minx y miny }
	b = rjd_math_vec4_shuffle(b,1,0,3,2);						 // { minx x miny y }
	
	return rjd_math_vec4_ge(a,b); // { x >= minx, maxx >= x, y >= miny, maxy >= y }
}

bool rjd_geo_point_box(rjd_math_vec3 p, rjd_geo_box b) {
	return rjd_math_vec3_ge(p, b.min) && rjd_math_vec3_ge(b.max, p);
}

bool rjd_geo_point_circle(rjd_math_vec3 p, rjd_geo_circle c) {
	rjd_math_vec3 v = rjd_math_vec3_sub(p, rjd_math_vec3_setz(c.xyr,0));
	return rjd_math_vec3_lengthsq(v) <= powf(rjd_math_vec3_z(c.xyr), 2);
}

bool rjd_geo_point_sphere(rjd_math_vec3 p, rjd_geo_sphere s) {
	rjd_math_vec4 pp = rjd_math_vec3to4(p);
	rjd_math_vec4 v = rjd_math_vec4_sub(pp, rjd_math_vec4_setw(s.xyzr, 0));
	return rjd_math_vec4_lengthsq(v) <= powf(rjd_math_vec4_w(s.xyzr), 2);
}

bool rjd_geo_circle_circle(rjd_geo_circle c1, rjd_geo_circle c2) {
	rjd_math_vec3 v = rjd_math_vec3_setz(rjd_math_vec3_sub(c1.xyr, c2.xyr), 0);
	rjd_math_vec3 added = rjd_math_vec3_add(c1.xyr, c2.xyr);
	rjd_math_vec3 squared = rjd_math_vec3_mul(added, added);
	return rjd_math_vec3_lengthsq(v) <= rjd_math_vec3_z(squared);
}

bool rjd_geo_circle_rect(rjd_geo_circle c, rjd_geo_rect r) {
	rjd_math_vec3 min = rjd_math_vec4to3(r.minmax);
	rjd_math_vec3 max = { _mm_movehl_ps(r.minmax.v, r.minmax.v) };

	rjd_math_vec3 center = rjd_math_vec3_setz(c.xyr, 0);
	rjd_math_vec3 p = rjd_math_vec3_max(min, rjd_math_vec3_min(max, center));
	p = rjd_math_vec3_setz(p, 0);
	return rjd_geo_point_circle(p, c);
}

bool rjd_geo_rect_rect(rjd_geo_rect a, rjd_geo_rect b) {
	rjd_math_vec4 min = { _mm_unpacklo_ps(a.minmax.v, b.minmax.v) }; // a.x, b.x, a.y, b.y
	rjd_math_vec4 max = { _mm_unpackhi_ps(a.minmax.v, b.minmax.v) }; // a.x, b.x, a.y, b.y
	max = rjd_math_vec4_shuffle(max,1,0,3,2); // b.x, a.x, b.y, a.y

	return rjd_math_vec4_ge(max, min);
}

bool rjd_geo_sphere_sphere(rjd_geo_sphere a, rjd_geo_sphere b) {
	rjd_math_vec4 v = rjd_math_vec4_setw(rjd_math_vec4_sub(a.xyzr, b.xyzr), 0);
	rjd_math_vec4 squared = rjd_math_vec4_mul(a.xyzr, b.xyzr);
	return rjd_math_vec4_lengthsq(v) <= rjd_math_vec4_w(squared);
}

bool rjd_geo_sphere_box(rjd_geo_sphere s, rjd_geo_box b) {
	rjd_math_vec3 center = rjd_math_vec4to3w(s.xyzr);
	rjd_math_vec3 p = rjd_math_vec3_max(b.min, rjd_math_vec3_min(b.max, center));
	return rjd_geo_point_sphere(p, s);
}

bool rjd_geo_box_box(rjd_geo_box a, rjd_geo_box b) {
	return rjd_math_vec3_ge(a.max, b.min) && rjd_math_vec3_ge(b.max, a.min);
}

bool rjd_geo_ray_point(rjd_geo_ray r, rjd_math_vec3 p, float* t_out) {
	rjd_math_vec3 to_p = rjd_math_vec3_sub(r.p, p);
	rjd_math_vec3 to_p_normalized = rjd_math_vec3_normalize(to_p);
	if (rjd_math_isequalf(rjd_math_vec3_dot(to_p_normalized, r.d), 1)) {
		return false;
	}

	if (t_out) {
		*t_out = rjd_math_vec3_length(to_p);
	}

	return true;
}

bool rjd_geo_ray_sphere(rjd_geo_ray r, rjd_geo_sphere s, float* t_out) {
	rjd_math_vec3 center = rjd_math_vec4to3w(s.xyzr);
	rjd_math_vec3 r_to_s = rjd_math_vec3_sub(center, r.p);
	float dot = rjd_math_vec3_dot(r.d, r_to_s);
	if (dot < 0) {
		return false;
	}

	rjd_math_vec3 p = rjd_math_vec3_scale(r.d, dot);
	rjd_math_vec3 s_to_p = rjd_math_vec3_sub(p, center);
	bool colliding = rjd_math_vec3_lengthsq(s_to_p) <= powf(rjd_math_vec4_w(s.xyzr), 2);
	if (colliding && t_out) {
		*t_out = dot;
	}

	return colliding;
}

bool rjd_geo_ray_box(rjd_geo_ray r, rjd_geo_box b, float* t_out) {
	rjd_math_vec3 inv_dir = rjd_math_vec3_div(rjd_math_vec3_one(), r.d);

	float t_dummy = FLT_MAX;
	if (!t_out) {
		t_out = &t_dummy;
	}

	return rjd_geo_ray_boxfast(r.p, inv_dir, b, t_out);
}

bool rjd_geo_ray_boxfast(rjd_math_vec3 ray_pos, rjd_math_vec3 ray_inv_dir, rjd_geo_box b, float* t_out) {
	rjd_math_vec3 v0 = rjd_math_vec3_mul(rjd_math_vec3_sub(b.min, ray_pos), ray_inv_dir);
	rjd_math_vec3 v1 = rjd_math_vec3_mul(rjd_math_vec3_sub(b.max, ray_pos), ray_inv_dir);

	rjd_math_vec3 min = rjd_math_vec3_min(v0, v1);
	rjd_math_vec3 max = rjd_math_vec3_max(v0, v1);

	float tmin = rjd_math_vec3_hmax(min);
	float tmax = rjd_math_vec3_hmax(max);

	bool colliding = (tmax >= 0) && (tmax >= tmin) && (tmin <= *t_out);
	if (colliding) {
		*t_out = tmin;
	}
	return colliding;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_easing.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_EASING_H 1

enum rjd_ease_type
{
	RJD_EASE_TYPE_LINE, // linear
	RJD_EASE_TYPE_SINE, // sine
	RJD_EASE_TYPE_CUBE, // cubic
	RJD_EASE_TYPE_QUAD, // quadratic
	RJD_EASE_TYPE_QUAR, // quartic
	RJD_EASE_TYPE_QUIN, // quintic
	RJD_EASE_TYPE_EXPO, // exponential
	RJD_EASE_TYPE_CIRC, // circular
	RJD_EASE_TYPE_BACK, // back
	RJD_EASE_TYPE_ELAS, // elastic
	RJD_EASE_TYPE_BOUN, // bounce
	RJD_EASE_TYPE_MAX,
};

enum rjd_ease_dir
{
	RJD_EASE_DIR_INOUT,
	RJD_EASE_DIR_IN,
	RJD_EASE_DIR_OUT,
	RJD_EASE_DIR_MAX,
};

typedef float (*rjd_ease_func)(float t);

static inline float rjd_ease(float t, enum rjd_ease_type type, enum rjd_ease_dir dir);
static inline float rjd_ease_between(float t, float min, float max, rjd_ease_func f);
static inline float rjd_ease_line(float t);
static inline float rjd_ease_in_sine(float t);
static inline float rjd_ease_in_quad(float t);
static inline float rjd_ease_in_cube(float t);
static inline float rjd_ease_in_quar(float t);
static inline float rjd_ease_in_quin(float t);
static inline float rjd_ease_in_expo(float t);
static inline float rjd_ease_in_circ(float t);
static inline float rjd_ease_in_back(float t);
static inline float rjd_ease_in_elas(float t);
static inline float rjd_ease_in_boun(float t);
static inline float rjd_ease_out_sine(float t);
static inline float rjd_ease_out_quad(float t);
static inline float rjd_ease_out_cube(float t);
static inline float rjd_ease_out_quar(float t);
static inline float rjd_ease_out_quin(float t);
static inline float rjd_ease_out_expo(float t);
static inline float rjd_ease_out_circ(float t);
static inline float rjd_ease_out_back(float t);
static inline float rjd_ease_out_elas(float t);
static inline float rjd_ease_out_boun(float t);
static inline float rjd_ease_inout_sine(float t);
static inline float rjd_ease_inout_quad(float t);
static inline float rjd_ease_inout_cube(float t);
static inline float rjd_ease_inout_quar(float t);
static inline float rjd_ease_inout_quin(float t);
static inline float rjd_ease_inout_expo(float t);
static inline float rjd_ease_inout_circ(float t);
static inline float rjd_ease_inout_back(float t);
static inline float rjd_ease_inout_elas(float t);
static inline float rjd_ease_inout_boun(float t);

// impl

static inline float rjd_ease(float t, enum rjd_ease_type type, enum rjd_ease_dir dir)
{
	switch (dir) {
		case RJD_EASE_DIR_IN: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_in_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_in_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_in_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_in_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_in_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_in_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_in_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_in_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_in_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_in_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		case RJD_EASE_DIR_OUT: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_inout_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_inout_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_inout_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_inout_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_inout_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_inout_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_inout_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_inout_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_inout_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_inout_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		case RJD_EASE_DIR_INOUT: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_inout_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_inout_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_inout_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_inout_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_inout_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_inout_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_inout_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_inout_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_inout_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_inout_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		default: break;
	}

	RJD_ASSERTFAIL("type (%d) or dir (%d) was invalid.\n", type, dir);
	return 0;
}

static inline float rjd_ease_between(float t, float min, float max, rjd_ease_func f) {
	return f(t) * (max - min) + min;
}

static inline float rjd_ease_line(float t) {
	return t;
}

static inline float rjd_ease_in_sine(float t) {
	return sinf((t - 1) * RJD_MATH_PI/2.0f) + 1;
}

static inline float rjd_ease_in_quad(float t) {
	return t*t;
}

static inline float rjd_ease_in_cube(float t) {
	return t*t*t;
}

static inline float rjd_ease_in_quar(float t) {
	return t*t*t*t;
}

static inline float rjd_ease_in_quin(float t) {
	return t*t*t*t*t;
}

static inline float rjd_ease_in_expo(float t) {
	return t == 0 ? t : powf(2, 10*(t - 1));
}

static inline float rjd_ease_in_circ(float t) {
	return -sqrtf(1-t*t) + 1;
}

static inline float rjd_ease_in_back(float t) {
	return t * t * t - t * sinf(t * RJD_MATH_PI);
}

static inline float rjd_ease_in_elas(float t) {
	return sinf(13.0f * RJD_MATH_PI / 2.0f * t) * powf(2, 10 * (t - 1));
}

static inline float rjd_ease_in_boun(float t) {
	return 1 - rjd_ease_out_boun(1 - t);
}

static inline float rjd_ease_out_sine(float t) {
	return sinf(t*RJD_MATH_PI/2.0f);
}

static inline float rjd_ease_out_quad(float t) {
	float tt = t - 1;
	return 1 - (tt * tt);
}

static inline float rjd_ease_out_cube(float t) {
	float tt = t - 1;
	return tt * tt * tt + 1;
}

static inline float rjd_ease_out_quar(float t) {
	float tt = t - 1;
	return 1 - (tt * tt * tt * tt);
}

static inline float rjd_ease_out_quin(float t) {
	float tt = t - 1;
	return tt * tt * tt * tt * tt + 1;
}

static inline float rjd_ease_out_expo(float t) {
	return t == 1 ? t : -powf(2, -10*t) + 1;
}

static inline float rjd_ease_out_circ(float t) {
	float tt = t - 1;
	return sqrtf(1 - tt * tt);
}

static inline float rjd_ease_out_back(float t) {
	float tt = 1 - t;
	return 1 - (tt*tt*tt - tt*sinf(tt*RJD_MATH_PI));
}

static inline float rjd_ease_out_elas(float t) {
	return sinf(-13.0f * RJD_MATH_PI / 2.0f * (t + 1)) * powf(2, -10 * t) + 1;
}

static inline float rjd_ease_out_boun(float t) {
	if (t < 4.0f/11.0f) {
		return 121 * t * t / 16.0f;
	} else if (t < 8.0f/11.0f) {
		return 363.0f/40.0f*t*t - 99.0f/10.0f*t + 17.0f/5.0f;
	} else if (t < 9.0f/10.0f) {
		return 4356.0f/361.0f*t*t - 35442.0f/1805.0f*t + 16061.0f/1805.0f;
	} else {
		return 54.0f/5.0f*t*t - 513.0f/25.0f*t + 268.0f/25.0f;
	}
}

static inline float rjd_ease_inout_sine(float t) {
	return sinf(t*RJD_MATH_PI - RJD_MATH_PI/2.0f) / 2.0f + 0.5f;
}

static inline float rjd_ease_inout_quad(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quad(tt) : rjd_ease_out_quad(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_cube(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_cube(tt) : rjd_ease_out_cube(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_quar(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quar(tt) : rjd_ease_out_quar(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_quin(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quin(tt) : rjd_ease_out_quin(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_expo(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_expo(tt) : rjd_ease_out_expo(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_circ(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_circ(tt) : rjd_ease_out_circ(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_back(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_back(tt) : rjd_ease_out_back(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_elas(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_elas(tt) : rjd_ease_out_elas(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_boun(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_boun(tt) : rjd_ease_out_boun(tt - 1) + 1) / 2;
}

////////////////////////////////////////////////////////////////////////////////
// rjd_strbuf.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_STRBUF_H 1

#ifndef RJD_STRBUF_STATIC_SIZE
	#define RJD_STRBUF_STATIC_SIZE 512
#endif

RJD_STATIC_ASSERT(RJD_STRBUF_STATIC_SIZE > 0);

struct rjd_mem_allocator;

struct rjd_strbuf
{
	struct rjd_mem_allocator* allocator;
	uint32_t length;
	char* heap;
	char stack[RJD_STRBUF_STATIC_SIZE];
};

struct rjd_strbuf rjd_strbuf_init(struct rjd_mem_allocator* allocator);
uint32_t rjd_strbuf_length(const struct rjd_strbuf* buf);
const char* rjd_strbuf_str(const struct rjd_strbuf* buf);
void rjd_strbuf_append(struct rjd_strbuf* buf, const char* format, ...);
void rjd_strbuf_appendv(struct rjd_strbuf* buf, const char* format, va_list args);
void rjd_strbuf_appendl(struct rjd_strbuf* buf, const char* str, uint32_t length);
void rjd_strbuf_free(struct rjd_strbuf* buf);

#define RJD_STRBUF_SCOPED(buffername, allocator, scope)				\
	{																\
		struct rjd_strbuf buffername = rjd_strbuf_init(allocator);	\
		{scope}														\
		rjd_strbuf_free(&buffername);								\
	}

#if RJD_IMPL

static void rjd_strbuf_grow(struct rjd_strbuf* buf, uint32_t format_length);

struct rjd_strbuf rjd_strbuf_init(struct rjd_mem_allocator* allocator)
{
	struct rjd_strbuf buf;
	buf.length = 0;
	buf.heap = 0;
	buf.stack[0] = 0;
	buf.allocator = allocator;

	return buf;
}

const char* rjd_strbuf_str(const struct rjd_strbuf* buf)
{
	RJD_ASSERT(buf);
	return buf->heap ? buf->heap : buf->stack;
}

void rjd_strbuf_append(struct rjd_strbuf* buf, const char* format, ...)
{
	RJD_ASSERT(buf);

	if (!format || *format == '\0') {
		return;
	}

	va_list args;
	va_start(args, format);
		rjd_strbuf_appendv(buf, format, args);
	va_end(args);
}

void rjd_strbuf_appendv(struct rjd_strbuf* buf, const char* format, va_list args)
{
	RJD_ASSERT(buf);

	if (!format || *format == '\0') {
		return;
	}

	uint32_t capacity = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t remaining = capacity - buf->length;
	uint32_t format_length = (uint32_t)strlen(format);

	if (remaining < format_length + 1) {
		rjd_strbuf_grow(buf, format_length);
		remaining = rjd_array_capacity(buf->heap) - buf->length;
	}

	char* str = buf->heap ? buf->heap : buf->stack;
	int written = vsnprintf(str + buf->length, remaining, format, args);
	while (written < 0) {
		rjd_strbuf_grow(buf, 1);
		str = buf->heap;
		written = vsnprintf(str + buf->length, remaining, format, args);
	}

	buf->length += written;
}

void rjd_strbuf_appendl(struct rjd_strbuf* buf, const char* format, uint32_t length)
{
	RJD_ASSERT(buf);
	RJD_ASSERT(format + length <= format + strlen(format));

	if (format == NULL || *format == '\0') {
		return;
	}

	uint32_t capacity = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t remaining = capacity - buf->length;

	if (remaining < length) {
		rjd_strbuf_grow(buf, length);
		remaining = rjd_array_capacity(buf->heap) - buf->length;
	}

	char* str = buf->heap ? buf->heap : buf->stack;
	memcpy(str + buf->length, format, length);
	buf->length += length;
	str[buf->length] = '\0';
}

void rjd_strbuf_free(struct rjd_strbuf* buf)
{
	RJD_ASSERT(buf);

	rjd_array_free(buf->heap);
	buf->length = 0;
	buf->heap = 0;
	buf->stack[0] = '\0';
}

static void rjd_strbuf_grow(struct rjd_strbuf* buf, uint32_t format_length)
{
	RJD_ASSERT(buf);
	RJD_ASSERT(buf->allocator);

	uint32_t current = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t min = current + format_length + 1;
	uint32_t next = rjd_math_next_pow2(min);

	if (!buf->heap) {
		buf->heap = rjd_array_alloc(char, next, buf->allocator);
		rjd_array_resize(buf->heap, next);

		strcpy(buf->heap, buf->stack);
	}
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_profiler.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PROFILER_H 1

struct rjd_timer
{
	double timestamp;
};

struct rjd_timer rjd_timer_init(void);
void rjd_timer_reset(struct rjd_timer* timer);
double rjd_timer_elapsed(const struct rjd_timer* timer);
double rjd_timer_global(void);

#define RJD_PROFILE_SCOPE(name, scope) {									\
		struct rjd_timer _timer##name = rjd_timer_init(); 					\
		{scope}																\
		RJD_LOG("Elapsed %s: %.4fms", #name, rjd_timer_elapsed(&_timer##name));	\
	}

#if RJD_IMPL

struct rjd_timer rjd_timer_init(void)
{
	struct rjd_timer timer;
	rjd_timer_reset(&timer);
	return timer;
}

void rjd_timer_reset(struct rjd_timer* timer)
{
	timer->timestamp = rjd_timer_global();
}

double rjd_timer_elapsed(const struct rjd_timer* timer)
{
	return rjd_timer_global() - timer->timestamp;
}
#if RJD_PLATFORM_WINDOWS
	static double RJD_QPC_FREQUENCY = 0;
	
	double rjd_timer_global(void)
	{
		if (RJD_QPC_FREQUENCY == 0) {
			LARGE_INTEGER frequency = {.QuadPart = 1};
			if (!QueryPerformanceFrequency(&frequency))
			{
				RJD_LOG("Failed to get QueryPerformanceFrequency: %d", GetLastError());
			}
			RJD_QPC_FREQUENCY = (double)frequency.QuadPart;
		}

		LARGE_INTEGER time = { .QuadPart = 0 };
		if (!QueryPerformanceCounter(&time))
		{
			RJD_LOG("Failed to get QueryPerformanceCounter. Time will be incorrect. Error: %d", GetLastError());
		}

		return (time.QuadPart * 1000LL) / RJD_QPC_FREQUENCY;
	}
#endif //RJD_PLATFORM_WINDOWS

#if RJD_PLATFORM_OSX
	#include <mach/mach.h>
	#include <mach/mach_time.h>

	static mach_timebase_info_data_t RJD_MACH_TIMEBASE_INFO;
	double rjd_timer_global(void)
	{
		if (RJD_MACH_TIMEBASE_INFO.denom == 0) {
			int ok = mach_timebase_info(&RJD_MACH_TIMEBASE_INFO);
			if (ok != KERN_SUCCESS) {
				RJD_LOG("Failed to get mach timebase info: %d", ok);
			}
		}

		double time = (double)mach_absolute_time();
		return time * ((double)RJD_MACH_TIMEBASE_INFO.numer / ((double)RJD_MACH_TIMEBASE_INFO.denom)) / 1000000;
	}
#endif // 

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_cmd.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_CMD_H 1

struct rjd_mem_allocator;

struct rjd_cmd_argv
{
	const char* shortname;
	const char* longname;
	const char* argname;
	const char* description;
};

struct rjd_cmd
{
	int argc;
	const char** argv;

	struct rjd_cmd_argv* opts;
	struct rjd_cmd_argv* reqs;

	struct rjd_mem_allocator* allocator;
};

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_mem_allocator* allocator);
void rjd_cmd_free(struct rjd_cmd* cmd);
void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description);
void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description);
bool rjd_cmd_ok(const struct rjd_cmd* cmd);
void rjd_cmd_usage(const struct rjd_cmd* cmd);
void rjd_cmd_help(const struct rjd_cmd* cmd);

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* shortname, int _default);
unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* shortname, unsigned _default);
double rjd_cmd_float(const struct rjd_cmd* cmd, const char* shortname, double _default);
bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* shortname);
const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* shortname);

#if RJD_IMPL

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_mem_allocator* allocator)
{
	struct rjd_cmd cmd = {argc, argv, NULL, NULL, allocator};
	cmd.opts = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);
	cmd.reqs = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);

	rjd_cmd_add_opt(&cmd, "-h", "--help", NULL, "Prints help");
	return cmd;
}

void rjd_cmd_free(struct rjd_cmd* cmd)
{
	rjd_array_free(cmd->opts);
	rjd_array_free(cmd->reqs);
}

void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(shortname);
	RJD_ASSERT(longname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv opt = { shortname, longname, argname, description };
	rjd_array_push(cmd->opts, opt);
}

void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(argname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv req = { NULL, NULL, argname, description };
	rjd_array_push(cmd->reqs, req);
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv);
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd);
static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname);

bool rjd_cmd_ok(const struct rjd_cmd* cmd)
{
	RJD_ASSERT(cmd);

	int count = rjd_array_count(cmd->reqs);
	if (cmd->argc - 1 < count) {
		return false;
	}

	const int firstreq = rjd_cmd_firstreq(cmd);

	for (int i = 1; i < firstreq; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);

		if (!opt) {
			return false;
		}

		if (opt->argname) {
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				// since we're expecting an argument, this shouldn't match any other options
				if (rjd_cmd_matchopt(cmd, cmd->argv[i+1])) {
					return false;
				}
			} else {
				const char* eq = strstr(cmd->argv[i], "=");
				if (!eq) {
					return false;
				}
				const char* arg = eq + 1;
				if (*arg == 0) {
					return false;
				}
			}
			++i;
		}
	}
	
	return (cmd->argc - 1 - firstreq) == (int) rjd_array_count(cmd->reqs);
}

void rjd_cmd_usage(const struct rjd_cmd* cmd)
{
	// TODO rjd_stringbuilder

	size_t offset = 0;

	char optString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		offset += snprintf(optString + offset, sizeof(optString) - offset, "%s", cmd->opts[i].shortname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(optString + offset, sizeof(optString) - offset, " ");
		}
	}
	optString[offset] = 0;

	offset = 0;

	char reqString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		offset += snprintf(reqString + offset, sizeof(reqString) - offset, "%s", cmd->reqs[i].argname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(reqString + offset, sizeof(reqString) - offset, " ");
		}
	}
	reqString[offset] = 0;

	printf("Usage: %s [%s] %s\n", cmd->argv[0], optString, reqString);
}

void rjd_cmd_help(const struct rjd_cmd* cmd) 
{
	rjd_cmd_usage(cmd);

	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		printf("%s\n\t%s\n", cmd->reqs[i].argname, cmd->reqs[i].description);
	}

	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const struct rjd_cmd_argv* arg = cmd->opts + i;
		if (arg->argname) {
			printf("%s %s, %s=%s\n\t%s\n", arg->shortname, arg->argname, arg->longname, arg->argname, arg->description);
		} else {
			printf("%s, %s\n\t%s\n", arg->shortname, arg->longname, arg->description);
		}
	}
}

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* name, int _default)
{
	return (int)rjd_cmd_float(cmd, name, _default);
}

unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* name, unsigned _default)
{
	double v = rjd_cmd_float(cmd, name, _default);
	if (v < 0) {
		return _default;
	}
	return (unsigned)v;
}

double rjd_cmd_float(const struct rjd_cmd* cmd, const char* name, double _default)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return _default;
	}

	char* end = NULL;
	double v = strtod(str, &end);
	if (v == 0 && end != NULL) {
		return _default;
	}
	return v;
}

bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* name)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return false;
	}

	if (!strcmp(str, "true")) {
		return true;
	} else if (!strcmp(str, "false")) {
		return false;
	}

	const struct rjd_cmd_argv* opt = rjd_cmd_getopt(cmd, name);
	return opt && !strcmp(opt->shortname, name);
}

const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* name)
{
	const char* opt = rjd_cmd_findopt(cmd, name);
	if (opt) {
		return opt;
	}

	const char* req = rjd_cmd_findreq(cmd, name);
	if (req) {
		return req;
	}

	return NULL;
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv)
{
	if (!argv) {
		return NULL;
	}

	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const char* shortname = cmd->opts[i].shortname;
		const char* longname = cmd->opts[i].longname;
		if (!strcmp(shortname, argv)) {
			return cmd->opts + i;
		}
		if (strstr(argv, longname) == argv) {
			return cmd->opts + i;
		}
	}

	return NULL;
}
	
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd)
{
	int index = 0;
	for (int i = 1; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt) {
			// skip the argument (assuming the format is ok)
			if (!strcmp(cmd->argv[i], opt->shortname) && opt->argname) {
				++i;
			}
			index = i;
		} else {
			break;
		}
	}

	return index + 1;
}

static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		if (!strcmp(cmd->opts[i].shortname, shortname)) {
			return cmd->opts + i;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (int i = 0; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt && !strcmp(opt->shortname, shortname)) {
			if (!opt->argname) {
				return cmd->argv[i];
			}
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				return cmd->argv[i + 1];
			}
			const char* eq = strstr(cmd->argv[i], "=");
			if (eq) {
				return eq + 1;
			}
			break;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname) 
{
	int reqindex = -1;
	for (int i = 0; i < (int)rjd_array_count(cmd->reqs); ++i) {
		if (!strcmp(cmd->reqs[i].argname, argname)) {
			reqindex = i;
			break;
		}
	}

	if (reqindex == -1) {
		return NULL;
	}

	int optindex = rjd_cmd_firstreq(cmd) - 1; // -1 to get to first opt index

	int argvindex = optindex + reqindex + 1; // +1 to skip exe arg
	RJD_ASSERT(argvindex < cmd->argc);

	return cmd->argv[argvindex];
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_dict.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_DICT_H 1

struct rjd_mem_allocator;

struct rjd_dict
{
	uint32_t count;
	struct rjd_hash64* hashes;
	void** values;
	struct rjd_mem_allocator* allocator;
};

struct rjd_dict rjd_dict_init(struct rjd_mem_allocator* allocator, size_t initial_capacity);
void rjd_dict_insert(struct rjd_dict* dict, struct rjd_hash64 hash, void* item);
void* rjd_dict_erase(struct rjd_dict* dict, struct rjd_hash64 hash);
void* rjd_dict_get(const struct rjd_dict* dict, struct rjd_hash64 hash);
bool rjd_dict_has(const struct rjd_dict* dict, struct rjd_hash64 hash);
void rjd_dict_free(struct rjd_dict* dict);

static inline void rjd_dict_insert_hashstr(struct rjd_dict* dict, const char* key, void* item);
static inline void* rjd_dict_erase_hashstr(struct rjd_dict* dict, const char* key);
static inline void* rjd_dict_get_hashstr(const struct rjd_dict* dict, const char* key);
static inline bool rjd_dict_has_hashstr(const struct rjd_dict* dict, const char* key);

static inline void rjd_dict_insert_hashstr(struct rjd_dict* dict, const char* key, void* item)
{
	rjd_dict_insert(dict, rjd_hash64_data((uint8_t*)key, -1), item);
}

static inline void* rjd_dict_erase_hashstr(struct rjd_dict* dict, const char* key)
{
	return rjd_dict_erase(dict, rjd_hash64_data((uint8_t*)key, -1));
}

static inline void* rjd_dict_get_hashstr(const struct rjd_dict* dict, const char* key)
{
	return rjd_dict_get(dict, rjd_hash64_data((uint8_t*)key, -1));
}

static inline bool rjd_dict_has_hashstr(const struct rjd_dict* dict, const char* key)
{
	return rjd_dict_has(dict, rjd_hash64_data((uint8_t*)key, -1));
}

#if RJD_IMPL

enum rjd_dict_findmode
{
	RJD_DICT_FINDMODE_INSERTION,
	RJD_DICT_FINDMODE_EXISTING,
};

static void rjd_dict_grow(struct rjd_dict* dict, size_t capacity);
static int32_t rjd_dict_findindex(const struct rjd_hash64* hashes, struct rjd_hash64 hash, enum rjd_dict_findmode mode);
 
struct rjd_dict rjd_dict_init(struct rjd_mem_allocator* allocator, size_t initial_capacity)
{
	RJD_ASSERT(allocator);

	struct rjd_dict dict = { 0, NULL, NULL, allocator };

	if (initial_capacity > 0) {
		rjd_dict_grow(&dict, initial_capacity);
	}

	return dict;
}

void rjd_dict_insert(struct rjd_dict* dict, struct rjd_hash64 hash, void* value)
{
	RJD_ASSERT(dict);
	RJD_ASSERT(rjd_hash64_valid(hash));

	const float load = dict->hashes ? (dict->count + 1) / (float)rjd_array_capacity(dict->hashes) : 1;
	if (load > 0.6) {
		uint32_t capacity = dict->hashes ? rjd_array_capacity(dict->hashes) * 2 : 32;
		rjd_dict_grow(dict, capacity);
	}

	int32_t i = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_INSERTION);
	RJD_ASSERT(i >= 0);
	RJD_ASSERT(!rjd_hash64_valid(dict->hashes[i]));

	dict->hashes[i] = hash;
	dict->values[i] = value;
	++dict->count;
}

void* rjd_dict_erase(struct rjd_dict* dict, struct rjd_hash64 hash)
{
	RJD_ASSERT(dict);
	
	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index < 0) {
		return NULL;
	}

	void* v = dict->values[index];

	dict->hashes[index] = rjd_hash64_data(NULL, 0);
	dict->values[index] = NULL;
	--dict->count;

	return v;
}

void* rjd_dict_get(const struct rjd_dict* dict, struct rjd_hash64 hash)
{
	RJD_ASSERT(dict);

	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index < 0) {
		return NULL;
	}

	return dict->values[index];
}

bool rjd_dict_has(const struct rjd_dict* dict, struct rjd_hash64 hash)
{
	RJD_ASSERT(dict);

	if (!rjd_hash64_valid(hash)) {
		return false;
	}

	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index >= 0) {
		return rjd_hash64_valid(dict->hashes[index]);
	}

	return false;
}

void rjd_dict_free(struct rjd_dict* dict)
{
	RJD_ASSERT(dict);

	rjd_array_free(dict->hashes);
	rjd_array_free(dict->values);
	dict->hashes = NULL;
	dict->values = NULL;
	dict->count = 0;
}

static void rjd_dict_grow(struct rjd_dict* dict, size_t capacity)
{
	RJD_ASSERT(capacity > 0);
	RJD_ASSERT(dict);

	struct rjd_hash64* hashes = rjd_array_alloc(struct rjd_hash64, (uint32_t)capacity, dict->allocator);
	void** values = rjd_array_alloc(void*, (uint32_t)capacity, dict->allocator);

	rjd_array_resize(hashes, (uint32_t)capacity);
	rjd_array_resize(values, (uint32_t)capacity);

	for (uint32_t i = 0; i < rjd_array_count(dict->hashes); ++i) {
		if (rjd_hash64_valid(dict->hashes[i])) {
			int32_t k = rjd_dict_findindex(hashes, dict->hashes[i], RJD_DICT_FINDMODE_INSERTION);
			RJD_ASSERT(k >= 0);
			hashes[k] = dict->hashes[i];
			values[k] = dict->values[i];
		}
	}

	rjd_array_free(dict->hashes);
	rjd_array_free(dict->values);

	dict->hashes = hashes;
	dict->values = values;
}

static int32_t rjd_dict_findindex(const struct rjd_hash64* hashes, struct rjd_hash64 hash, enum rjd_dict_findmode mode)
{
	if (!hashes) {
		return -1;
	}

	const uint32_t capacity = rjd_array_capacity(hashes);
	const uint32_t start = hash.value % capacity;
	uint32_t i = start;
	do {
		if (mode == RJD_DICT_FINDMODE_INSERTION && !rjd_hash64_valid(hashes[i])) {
			return (int32_t)i;
		} else if (mode == RJD_DICT_FINDMODE_EXISTING && hashes[i].value == hash.value) {
			return (int32_t)i;
		}

		i = (i + 1) % capacity;
	} while (i != start);

	return -1;
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_fio.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_FILEIO_H 1

enum rjd_fio_writemode
{
	RJD_FIO_WRITEMODE_REPLACE,
	RJD_FIO_WRITEMODE_APPEND,
};

// use rjd_array_free() to free *buffer after use
struct rjd_result rjd_fio_read(const char* path, char** buffer, struct rjd_mem_allocator* allocator);
struct rjd_result rjd_fio_write(const char* path, const char* data, size_t length, enum rjd_fio_writemode mode);
struct rjd_result rjd_fio_size(const char* path, size_t* out_size);
struct rjd_result rjd_fio_delete(const char* path);
struct rjd_result rjd_fio_mkdir(const char* path);
bool rjd_fio_exists(const char* path);

#if RJD_IMPL

#if RJD_PLATFORM_OSX
#include <sys/stat.h>
#include <ftw.h>
#endif

struct rjd_result rjd_fio_read(const char* path, char** buffer, struct rjd_mem_allocator* allocator)
{
	FILE* file = fopen(path, "rb");
	if (!file) {
		return RJD_RESULT("Failed to open the path for reading");
	}

	if (fseek(file, 0, SEEK_END)) {
		fclose(file);
		return RJD_RESULT("Failed to seek to the end of the file");
	}

	long int length = ftell(file);
	if (length < 0) {
		length = 0;
	}

	rewind(file);

	*buffer = rjd_array_alloc(char, (uint32_t)length, allocator);
	if (!*buffer) {
		return RJD_RESULT("Not enough memory in the allocator");
	}
	rjd_array_resize(*buffer, (uint32_t)length);

	size_t read_length = fread(*buffer, 1, length, file);
	fclose(file);

	if (read_length < (size_t)length) {
		rjd_array_free(*buffer);
		*buffer = NULL;
		return RJD_RESULT("Failed to read the entire file into memory");
	}

	return RJD_RESULT_OK();
}

struct rjd_result rjd_fio_write(const char* path, const char* data, size_t length, enum rjd_fio_writemode mode)
{
	const char* m = (mode == RJD_FIO_WRITEMODE_REPLACE) ? "wb" : "ab";
	FILE* file = fopen(path, m);
	if (!file) {
		return RJD_RESULT("Failed to open a writable handle");
	}

	const size_t written = fwrite(data, 1, length, file);

	fclose(file);

	if (written == 0) {
		return RJD_RESULT("Failed to write any bytes");
	} else if (written < length) {
		return RJD_RESULT("Failed to write the entire file");
	} else {
		return RJD_RESULT_OK();
	}
}

struct rjd_result rjd_fio_size(const char* path, size_t* out_size)
{
	FILE* file = fopen(path, "rb");
	if (!file) {
		return RJD_RESULT("Failed to open the path for reading");
	}

	if (fseek(file, 0, SEEK_END)) {
		fclose(file);
		return RJD_RESULT("Failed to seek to the end of the file");
	}

	long int length = ftell(file);
	fclose(file);

	*out_size = (size_t) length;
	return RJD_RESULT_OK();
}

#if RJD_PLATFORM_WINDOWS
struct rjd_result rjd_fio_delete(const char* path)
{
	return RJD_RESULT("not implmented");
}

struct rjd_result rjd_fio_mkdir(const char* path)
{
	return RJD_RESULT("not implmented");
}

bool rjd_fio_exists(const char* path)
{
	return false;
}

#elif RJD_PLATFORM_OSX
static int rjd_delete_nftw_func(const char *path, const struct stat *sb, int typeflag, struct FTW *ftwbuf)
{
	RJD_UNUSED_PARAM(sb);
	RJD_UNUSED_PARAM(typeflag);
	RJD_UNUSED_PARAM(ftwbuf);
	return remove(path);
}

struct rjd_result rjd_fio_delete(const char* path)
{
	if (remove(path)) {
    	if (nftw(path, rjd_delete_nftw_func, 64, FTW_DEPTH | FTW_PHYS)) {
			return RJD_RESULT("delete failed");
		}
	}

	return RJD_RESULT_OK();
}

bool rjd_fio_exists(const char* path)
{
    struct stat unused;
    return !stat(path, &unused);
}

struct rjd_result rjd_fio_mkdir(const char* path)
{
    RJD_ASSERT(path);
    RJD_ASSERT(*path);
    
    bool created_directory = false;
    
    const char* next = path;
    const char* end = next;
	do
    {
		end = strstr(end, "/");
        // skip directory separator
        if (end) {
            ++end;
        }
        
        char stackbuffer[256];
        const char* subpath = NULL;

		if (end) {
            RJD_ASSERT(end - next < (ptrdiff_t)sizeof(stackbuffer));
			memcpy(stackbuffer, next, end - next);
			stackbuffer[end - next] = '\0';
            subpath = stackbuffer;
		} else {
			subpath = next;
		}

		const mode_t mode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;
		if (mkdir(subpath, mode) == 0) {
            created_directory = true;
        } else if (created_directory == true) {
            // there was an error creating a nested folder
            created_directory = false;
            break;
        }
    } while (end != NULL);
    
    return created_directory ? RJD_RESULT_OK() : RJD_RESULT("error creating directory");
}
#endif

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_thread.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_THREAD

#ifndef RJD_THREAD_STACKSIZE_DEFAULT
	#define RJD_THREAD_STACKSIZE_DEFAULT (4 * RJD_MB)
#endif

#define RJD_THREAD_NAME_MAX_LENGTH (16u)

typedef void rjd_thread_entrypoint_func(void* userdata);

struct rjd_thread_desc
{
	rjd_thread_entrypoint_func* entrypoint_func;
	struct rjd_mem_allocator* allocator;
	uint32_t stacksize;
	void* userdata;
	const char name[RJD_THREAD_NAME_MAX_LENGTH];
};

struct rjd_thread_id
{
	uint64_t id;
};

struct rjd_thread_platform
{
	char platform_impl[16];
};

struct rjd_thread
{
	struct rjd_thread_id id;
	struct rjd_thread_platform platform;
};

struct rjd_condvar
{
	char platform_impl[128];
};

struct rjd_lock
{
	char platform_impl[64];
};

struct rjd_rwlock
{
	char platform_impl[256];
};

struct rjd_thread_id rjd_thread_current(void);
struct rjd_result rjd_thread_create(struct rjd_thread* thread, struct rjd_thread_desc desc);
struct rjd_result rjd_thread_join(struct rjd_thread* thread);
struct rjd_result rjd_thread_getname(struct rjd_thread* thread, uint32_t destination_max_length, char* out);
void rjd_thread_sleep(uint32_t seconds);

struct rjd_result rjd_condvar_create(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_destroy(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_lock(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_unlock(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_signal_single(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_signal_all(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_wait(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_wait_timed(struct rjd_condvar* condvar, uint32_t seconds);

struct rjd_result rjd_lock_create(struct rjd_lock* lock);
struct rjd_result rjd_lock_destroy(struct rjd_lock* lock);
struct rjd_result rjd_lock_acquire(struct rjd_lock* lock);
struct rjd_result rjd_lock_try_acquire(struct rjd_lock* lock);
struct rjd_result rjd_lock_release(struct rjd_lock* lock);

struct rjd_result rjd_rwlock_create(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_destroy(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_acquire_reader(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_acquire_writer(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_try_acquire_reader(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_try_acquire_writer(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_release(struct rjd_rwlock* lock);

#if RJD_IMPL

#if RJD_PLATFORM_WINDOWS

#error "Unimplemented"

struct rjd_result rjd_lock_create(struct rjd_lock* lock)
{
	// posix mutex is non-rentrant but win32 critical section is. need to assert
	// that owning thread locking the CS isn't the current thread
}

#elif RJD_PLATFORM_OSX

#include <pthread.h>
#include <unistd.h> // sleep
#include <limits.h> // PTHREAD_STACK_MIN
#include <sys/errno.h>
#include <sys/time.h> // gettimeofday

struct rjd_thread_osx
{
	pthread_t handle;
	void* stack;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_thread_osx) <= sizeof(struct rjd_thread_platform));
RJD_STATIC_ASSERT(sizeof(pthread_t) <= sizeof(uint64_t));

struct rjd_thread_params
{
	rjd_thread_entrypoint_func* entrypoint_func;
	void* userdata;
	char name[RJD_THREAD_NAME_MAX_LENGTH];
};

struct rjd_condvar_osx
{
	pthread_cond_t condition_variable;
	struct rjd_lock lock;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_condvar_osx) <= sizeof(struct rjd_condvar));

struct rjd_lock_osx
{
	pthread_mutex_t lock;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_lock_osx) <= sizeof(struct rjd_lock));

struct rjd_rwlock_osx
{
	pthread_rwlock_t lock;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_rwlock_osx) <= sizeof(struct rjd_rwlock));

RJD_STATIC_ASSERT(RJD_THREAD_STACKSIZE_DEFAULT >= PTHREAD_STACK_MIN);

static inline struct rjd_thread_osx* rjd_thread_get_osx(struct rjd_thread* thread);
static inline struct rjd_condvar_osx* rjd_condvar_get_osx(struct rjd_condvar* condvar);
static inline struct rjd_lock_osx* rjd_lock_get_osx(struct rjd_lock* lock);
static inline struct rjd_rwlock_osx* rjd_rwlock_get_osx(struct rjd_rwlock* rwlock);

struct rjd_result rjd_error_to_result(int error);
static void* rjd_thread_entrypoint_osx(void* userdata);

////////////////////////////////////////////////////////////////////////////////
// interface implementation

struct rjd_result rjd_thread_create(struct rjd_thread* thread, struct rjd_thread_desc desc)
{
	struct rjd_thread_osx* thread_osx = rjd_thread_get_osx(thread);
	thread_osx->stack = NULL;

	if (desc.stacksize == 0) {
		desc.stacksize = RJD_THREAD_STACKSIZE_DEFAULT;
	}

	// pthreads require 4K alignment for stacks
	void* stack = rjd_mem_alloc_array_aligned_noclear(uint8_t, desc.stacksize, desc.allocator, 4 * RJD_KB);
	struct rjd_thread_params* params = rjd_mem_alloc(struct rjd_thread_params, desc.allocator);
	params->entrypoint_func = desc.entrypoint_func;
	params->userdata = desc.userdata;
	params->name[0] = 0;
	if (*desc.name) {
		strncpy(params->name, desc.name, RJD_THREAD_NAME_MAX_LENGTH);
        params->name[rjd_countof(params->name) - 1] = 0;
	}

    pthread_attr_t attributes = {0};
    int error = pthread_attr_init(&attributes);
	struct rjd_result result = rjd_error_to_result(error);

	if (rjd_result_isok(result)) {
		error = pthread_attr_setstack(&attributes, stack, desc.stacksize);
        if (error == EINVAL && desc.stacksize < PTHREAD_STACK_MIN) {
            result = RJD_RESULT("Failed to set the stack. Ensure it is at least as large as PTHREAD_STACK_MIN");
        } else {
            result = rjd_error_to_result(error);
        }
        
		if (rjd_result_isok(result)) {
			// NOTE params ownership is passed to thread
			error = pthread_create(&thread_osx->handle, &attributes, rjd_thread_entrypoint_osx, params);
			result = rjd_error_to_result(error);
			if (rjd_result_isok(result)) {
				thread->id.id = (uint64_t)thread_osx->handle;
				thread_osx->stack = stack;
			}
		}
	}

	if (!rjd_result_isok(result)) {
		rjd_mem_free(params);
		rjd_mem_free(stack);
	}

	return result;
}

struct rjd_result rjd_thread_join(struct rjd_thread* thread)
{
	struct rjd_thread_osx* thread_osx = rjd_thread_get_osx(thread);

	void* unused_return_value = NULL;
    int error = pthread_join(thread_osx->handle, &unused_return_value);

	rjd_mem_free(thread_osx->stack);

	return rjd_error_to_result(error);
}

struct rjd_result rjd_thread_getname(struct rjd_thread* thread, uint32_t destination_max_length, char* out)
{
	struct rjd_thread_osx* thread_osx = rjd_thread_get_osx(thread);

	struct rjd_result result = RJD_RESULT_OK();

	int error = pthread_getname_np(thread_osx->handle, out, destination_max_length);
	if (error == ERANGE) {
		result = RJD_RESULT("Destination buffer too short");
	}

	return result;
}

void rjd_thread_sleep(uint32_t seconds)
{
	sleep(seconds);
}

struct rjd_result rjd_condvar_create(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);

	struct rjd_result result = rjd_lock_create(&condvar_osx->lock);
	if (rjd_result_isok(result)) {
		const int error = pthread_cond_init(&condvar_osx->condition_variable, NULL);
		result = rjd_error_to_result(error);
	}

	return result;
}

struct rjd_result rjd_condvar_destroy(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);

    struct rjd_result result = rjd_lock_release(&condvar_osx->lock);
    if (rjd_result_isok(result)) {
        result = rjd_lock_destroy(&condvar_osx->lock);
        if (rjd_result_isok(result)) {
            const int error = pthread_cond_destroy(&condvar_osx->condition_variable);
            result = rjd_error_to_result(error);
        }
    }

	return result;
}

struct rjd_result rjd_condvar_lock(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	return rjd_lock_acquire(&condvar_osx->lock);
}

struct rjd_result rjd_condvar_unlock(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	return rjd_lock_release(&condvar_osx->lock);
}


struct rjd_result rjd_condvar_signal_single(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);

	struct rjd_result result = rjd_lock_acquire(&condvar_osx->lock);
	if (rjd_result_isok(result)) {
		int error = pthread_cond_signal(&condvar_osx->condition_variable);
		result = rjd_error_to_result(error);
		rjd_lock_release(&condvar_osx->lock);
	}
	return result;
}

struct rjd_result rjd_condvar_signal_all(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	
	struct rjd_result result = rjd_lock_acquire(&condvar_osx->lock);
	if (rjd_result_isok(result)) {
		int error = pthread_cond_broadcast(&condvar_osx->condition_variable);
		result = rjd_error_to_result(error);
		rjd_lock_release(&condvar_osx->lock);
	}
	return result;
}

struct rjd_result rjd_condvar_wait(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(&condvar_osx->lock);

	int error = pthread_cond_wait(&condvar_osx->condition_variable, &lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_condvar_wait_timed(struct rjd_condvar* condvar, uint32_t seconds)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(&condvar_osx->lock);

	struct timeval timeval = {0};
	gettimeofday(&timeval, NULL);

	struct timespec timespec = {
		.tv_sec = timeval.tv_sec + seconds,
        .tv_nsec = timeval.tv_usec * 1000,
	};
	int error = pthread_cond_timedwait(&condvar_osx->condition_variable, &lock_osx->lock, &timespec);
	struct rjd_result result = rjd_error_to_result(error);
   
	return result;
}

struct rjd_result rjd_lock_create(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);

    int error = pthread_mutex_init(&lock_osx->lock, NULL);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_destroy(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_destroy(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_acquire(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_lock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_try_acquire(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_trylock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_release(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_unlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_create(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_init(&lock_osx->lock, NULL);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_destroy(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_destroy(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_acquire_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_rdlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_acquire_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_wrlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_try_acquire_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_tryrdlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_try_acquire_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_trywrlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_release(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_unlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

////////////////////////////////////////////////////////////////////////////////
// Local helper implementation

static inline struct rjd_thread_osx* rjd_thread_get_osx(struct rjd_thread* thread)
{
	RJD_ASSERT(thread);
	return (struct rjd_thread_osx*)&thread->platform;
}

static inline struct rjd_condvar_osx* rjd_condvar_get_osx(struct rjd_condvar* condvar)
{
	RJD_ASSERT(condvar);
	return (struct rjd_condvar_osx*)condvar;
}

static inline struct rjd_lock_osx* rjd_lock_get_osx(struct rjd_lock* lock)
{
	RJD_ASSERT(lock);
	return (struct rjd_lock_osx*)lock;
}

static inline struct rjd_rwlock_osx* rjd_rwlock_get_osx(struct rjd_rwlock* rwlock)
{
	RJD_ASSERT(rwlock);
	return (struct rjd_rwlock_osx*)rwlock;
}

struct rjd_result rjd_error_to_result(int error)
{
	switch (error)
	{
		case 0:			return RJD_RESULT_OK();
		case EAGAIN:	return RJD_RESULT("Not enough system resources to create this object or system capacity is already at maximum. Try again later.");
		case EBUSY:		return RJD_RESULT("Unable to perform operation without blocking. If the object is a lock, the thread may already be holding it.");
		case EDEADLK:	return RJD_RESULT("Deadlock detected.");
		case EINVAL:	return RJD_RESULT("Invalid object.");
		case ENOMEM:	return RJD_RESULT("Not enough system memory available.");
		case EPERM: 	return RJD_RESULT("This operation requires higher permissions.");
		case ESRCH:		return RJD_RESULT("Object not found.");
		case ETIMEDOUT:	return RJD_RESULT("Timed out");
	}
	
	return RJD_RESULT("Unknown error");
}

static void* rjd_thread_entrypoint_osx(void* params_untyped)
{
	struct rjd_thread_params params = *(struct rjd_thread_params*)params_untyped;
	rjd_mem_free(params_untyped);

	if (*params.name) {
		pthread_setname_np(params.name);
	}
	params.entrypoint_func(params.userdata);
	return NULL;
}

#endif

#endif

////////////////////////////////////////////////////////////////////////////////
// rjd_atomic.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

struct rjd_atomic_int64  { char impl[8]; };
struct rjd_atomic_int32  { char impl[4]; };
struct rjd_atomic_int16  { char impl[2]; };
struct rjd_atomic_int8   { char impl[1]; };
struct rjd_atomic_uint64 { char impl[8]; };
struct rjd_atomic_uint32 { char impl[4]; };
struct rjd_atomic_uint16 { char impl[2]; };
struct rjd_atomic_uint8  { char impl[1]; };

struct rjd_atomic_int64 rjd_atomic_int64_init (int64_t  value);
int64_t rjd_atomic_int64_get(struct rjd_atomic_int64* atomic);
void rjd_atomic_int64_set(struct rjd_atomic_int64* atomic, int64_t value);
int64_t rjd_atomic_int64_add(struct rjd_atomic_int64* atomic, int64_t value);
int64_t rjd_atomic_int64_sub(struct rjd_atomic_int64* atomic, int64_t value);
int64_t rjd_atomic_int64_inc(struct rjd_atomic_int64* atomic);
int64_t rjd_atomic_int64_dec(struct rjd_atomic_int64* atomic);
bool rjd_atomic_int64_compare_exchange_weak(struct rjd_atomic_int64* atomic, int64_t* expected, int64_t desired);
bool rjd_atomic_int64_compare_exchange_strong(struct rjd_atomic_int64* atomic, int64_t* expected, int64_t desired);

struct rjd_atomic_int32 rjd_atomic_int32_init (int32_t  value);
int32_t rjd_atomic_int32_get(struct rjd_atomic_int32* atomic);
void rjd_atomic_int32_set(struct rjd_atomic_int32* atomic, int32_t value);
int32_t rjd_atomic_int32_add(struct rjd_atomic_int32* atomic, int32_t value);
int32_t rjd_atomic_int32_sub(struct rjd_atomic_int32* atomic, int32_t value);
int32_t rjd_atomic_int32_inc(struct rjd_atomic_int32* atomic);
int32_t rjd_atomic_int32_dec(struct rjd_atomic_int32* atomic);
bool rjd_atomic_int32_compare_exchange_weak(struct rjd_atomic_int32* atomic, int32_t* expected, int32_t desired);
bool rjd_atomic_int32_compare_exchange_strong(struct rjd_atomic_int32* atomic, int32_t* expected, int32_t desired);

struct rjd_atomic_int16 rjd_atomic_int16_init (int16_t  value);
int16_t rjd_atomic_int16_get(struct rjd_atomic_int16* atomic);
void rjd_atomic_int16_set(struct rjd_atomic_int16* atomic, int16_t value);
int16_t rjd_atomic_int16_add(struct rjd_atomic_int16* atomic, int16_t value);
int16_t rjd_atomic_int16_sub(struct rjd_atomic_int16* atomic, int16_t value);
int16_t rjd_atomic_int16_inc(struct rjd_atomic_int16* atomic);
int16_t rjd_atomic_int16_dec(struct rjd_atomic_int16* atomic);
bool rjd_atomic_int16_compare_exchange_weak(struct rjd_atomic_int16* atomic, int16_t* expected, int16_t desired);
bool rjd_atomic_int16_compare_exchange_strong(struct rjd_atomic_int16* atomic, int16_t* expected, int16_t desired);

struct rjd_atomic_int8 rjd_atomic_int8_init (int8_t  value);
int8_t rjd_atomic_int8_get(struct rjd_atomic_int8* atomic);
void rjd_atomic_int8_set(struct rjd_atomic_int8* atomic, int8_t value);
int8_t rjd_atomic_int8_add(struct rjd_atomic_int8* atomic, int8_t value);
int8_t rjd_atomic_int8_sub(struct rjd_atomic_int8* atomic, int8_t value);
int8_t rjd_atomic_int8_inc(struct rjd_atomic_int8* atomic);
int8_t rjd_atomic_int8_dec(struct rjd_atomic_int8* atomic);
bool rjd_atomic_int8_compare_exchange_weak(struct rjd_atomic_int8* atomic, int8_t* expected, int8_t desired);
bool rjd_atomic_int8_compare_exchange_strong(struct rjd_atomic_int8* atomic, int8_t* expected, int8_t desired);

struct rjd_atomic_uint64 rjd_atomic_uint64_init (uint64_t  value);
uint64_t rjd_atomic_uint64_get(struct rjd_atomic_uint64* atomic);
void rjd_atomic_uint64_set(struct rjd_atomic_uint64* atomic, uint64_t value);
uint64_t rjd_atomic_uint64_add(struct rjd_atomic_uint64* atomic, uint64_t value);
uint64_t rjd_atomic_uint64_sub(struct rjd_atomic_uint64* atomic, uint64_t value);
uint64_t rjd_atomic_uint64_inc(struct rjd_atomic_uint64* atomic);
uint64_t rjd_atomic_uint64_dec(struct rjd_atomic_uint64* atomic);
bool rjd_atomic_uint64_compare_exchange_weak(struct rjd_atomic_uint64* atomic, uint64_t* expected, uint64_t desired);
bool rjd_atomic_uint64_compare_exchange_strong(struct rjd_atomic_uint64* atomic, uint64_t* expected, uint64_t desired);

struct rjd_atomic_uint32 rjd_atomic_uint32_init (uint32_t  value);
uint32_t rjd_atomic_uint32_get(struct rjd_atomic_uint32* atomic);
void rjd_atomic_uint32_set(struct rjd_atomic_uint32* atomic, uint32_t value);
uint32_t rjd_atomic_uint32_add(struct rjd_atomic_uint32* atomic, uint32_t value);
uint32_t rjd_atomic_uint32_sub(struct rjd_atomic_uint32* atomic, uint32_t value);
uint32_t rjd_atomic_uint32_inc(struct rjd_atomic_uint32* atomic);
uint32_t rjd_atomic_uint32_dec(struct rjd_atomic_uint32* atomic);
bool rjd_atomic_uint32_compare_exchange_weak(struct rjd_atomic_uint32* atomic, uint32_t* expected, uint32_t desired);
bool rjd_atomic_uint32_compare_exchange_strong(struct rjd_atomic_uint32* atomic, uint32_t* expected, uint32_t desired);

struct rjd_atomic_uint16 rjd_atomic_uint16_init (uint16_t  value);
uint16_t rjd_atomic_uint16_get(struct rjd_atomic_uint16* atomic);
void rjd_atomic_uint16_set(struct rjd_atomic_uint16* atomic, uint16_t value);
uint16_t rjd_atomic_uint16_add(struct rjd_atomic_uint16* atomic, uint16_t value);
uint16_t rjd_atomic_uint16_sub(struct rjd_atomic_uint16* atomic, uint16_t value);
uint16_t rjd_atomic_uint16_inc(struct rjd_atomic_uint16* atomic);
uint16_t rjd_atomic_uint16_dec(struct rjd_atomic_uint16* atomic);
bool rjd_atomic_uint16_compare_exchange_weak(struct rjd_atomic_uint16* atomic, uint16_t* expected, uint16_t desired);
bool rjd_atomic_uint16_compare_exchange_strong(struct rjd_atomic_uint16* atomic, uint16_t* expected, uint16_t desired);

struct rjd_atomic_uint8 rjd_atomic_uint8_init (uint8_t  value);
uint8_t rjd_atomic_uint8_get(struct rjd_atomic_uint8* atomic);
void rjd_atomic_uint8_set(struct rjd_atomic_uint8* atomic, uint8_t value);
uint8_t rjd_atomic_uint8_add(struct rjd_atomic_uint8* atomic, uint8_t value);
uint8_t rjd_atomic_uint8_sub(struct rjd_atomic_uint8* atomic, uint8_t value);
uint8_t rjd_atomic_uint8_inc(struct rjd_atomic_uint8* atomic);
uint8_t rjd_atomic_uint8_dec(struct rjd_atomic_uint8* atomic);
bool rjd_atomic_uint8_compare_exchange_weak(struct rjd_atomic_uint8* atomic, uint8_t* expected, uint8_t desired);
bool rjd_atomic_uint8_compare_exchange_strong(struct rjd_atomic_uint8* atomic, uint8_t* expected, uint8_t desired);

#if RJD_IMPL

#if RJD_COMPILER_MSVC

// TODO

#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
#include <stdatomic.h>

struct rjd_atomic_int64_osx
{
	_Atomic int64_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int64) <= sizeof(struct rjd_atomic_int64));

struct rjd_atomic_int32_osx
{
	_Atomic int32_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int32) <= sizeof(struct rjd_atomic_int32));

struct rjd_atomic_int16_osx
{
	_Atomic int16_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int16) <= sizeof(struct rjd_atomic_int16));

struct rjd_atomic_int8_osx
{
	_Atomic int8_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int8) <= sizeof(struct rjd_atomic_int8));

struct rjd_atomic_uint64_osx
{
	_Atomic uint64_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint64) <= sizeof(struct rjd_atomic_uint64));

struct rjd_atomic_uint32_osx
{
	_Atomic uint32_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int32) <= sizeof(struct rjd_atomic_int32));

struct rjd_atomic_uint16_osx
{
	_Atomic uint16_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint16) <= sizeof(struct rjd_atomic_uint16));

struct rjd_atomic_uint8_osx
{
	_Atomic uint8_t value;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint8) <= sizeof(struct rjd_atomic_uint8));

////////////////////////////////////////////////////////////////////////////////
// Implementation

struct rjd_atomic_int64 rjd_atomic_int64_init (int64_t value)
{
	struct rjd_atomic_int64 atomic;
	struct rjd_atomic_int64_osx* atomic_osx = (struct rjd_atomic_int64_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

int64_t rjd_atomic_int64_get(struct rjd_atomic_int64* atomic)
{
	struct rjd_atomic_int64_osx* atomic_osx = (struct rjd_atomic_int64_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_int64_set(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_osx* atomic_osx = (struct rjd_atomic_int64_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

int64_t rjd_atomic_int64_add(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_osx* atomic_osx = (struct rjd_atomic_int64_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

int64_t rjd_atomic_int64_sub(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_osx* atomic_osx = (struct rjd_atomic_int64_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

int64_t rjd_atomic_int64_inc(struct rjd_atomic_int64* atomic)
{
	return rjd_atomic_int64_add(atomic, 1);
}

int64_t rjd_atomic_int64_dec(struct rjd_atomic_int64* atomic)
{
	return rjd_atomic_int64_sub(atomic, 1);
}

bool rjd_atomic_int64_compare_exchange_weak(struct rjd_atomic_int64* atomic, int64_t* expected, int64_t desired)
{
	struct rjd_atomic_int64_osx* atomic_osx = (struct rjd_atomic_int64_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_int64_compare_exchange_strong(struct rjd_atomic_int64* atomic, int64_t* expected, int64_t desired)
{
	struct rjd_atomic_int64_osx* atomic_osx = (struct rjd_atomic_int64_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int32 rjd_atomic_int32_init (int32_t value)
{
	struct rjd_atomic_int32 atomic;
	struct rjd_atomic_int32_osx* atomic_osx = (struct rjd_atomic_int32_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

int32_t rjd_atomic_int32_get(struct rjd_atomic_int32* atomic)
{
	struct rjd_atomic_int32_osx* atomic_osx = (struct rjd_atomic_int32_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_int32_set(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_osx* atomic_osx = (struct rjd_atomic_int32_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

int32_t rjd_atomic_int32_add(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_osx* atomic_osx = (struct rjd_atomic_int32_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

int32_t rjd_atomic_int32_sub(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_osx* atomic_osx = (struct rjd_atomic_int32_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

int32_t rjd_atomic_int32_inc(struct rjd_atomic_int32* atomic)
{
	return rjd_atomic_int32_add(atomic, 1);
}

int32_t rjd_atomic_int32_dec(struct rjd_atomic_int32* atomic)
{
	return rjd_atomic_int32_sub(atomic, 1);
}

bool rjd_atomic_int32_compare_exchange_weak(struct rjd_atomic_int32* atomic, int32_t* expected, int32_t desired)
{
	struct rjd_atomic_int32_osx* atomic_osx = (struct rjd_atomic_int32_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_int32_compare_exchange_strong(struct rjd_atomic_int32* atomic, int32_t* expected, int32_t desired)
{
	struct rjd_atomic_int32_osx* atomic_osx = (struct rjd_atomic_int32_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int16 rjd_atomic_int16_init (int16_t value)
{
	struct rjd_atomic_int16 atomic;
	struct rjd_atomic_int16_osx* atomic_osx = (struct rjd_atomic_int16_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

int16_t rjd_atomic_int16_get(struct rjd_atomic_int16* atomic)
{
	struct rjd_atomic_int16_osx* atomic_osx = (struct rjd_atomic_int16_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_int16_set(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_osx* atomic_osx = (struct rjd_atomic_int16_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

int16_t rjd_atomic_int16_add(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_osx* atomic_osx = (struct rjd_atomic_int16_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

int16_t rjd_atomic_int16_sub(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_osx* atomic_osx = (struct rjd_atomic_int16_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

int16_t rjd_atomic_int16_inc(struct rjd_atomic_int16* atomic)
{
	return rjd_atomic_int16_add(atomic, 1);
}

int16_t rjd_atomic_int16_dec(struct rjd_atomic_int16* atomic)
{
	return rjd_atomic_int16_sub(atomic, 1);
}

bool rjd_atomic_int16_compare_exchange_weak(struct rjd_atomic_int16* atomic, int16_t* expected, int16_t desired)
{
	struct rjd_atomic_int16_osx* atomic_osx = (struct rjd_atomic_int16_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_int16_compare_exchange_strong(struct rjd_atomic_int16* atomic, int16_t* expected, int16_t desired)
{
	struct rjd_atomic_int16_osx* atomic_osx = (struct rjd_atomic_int16_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int8 rjd_atomic_int8_init (int8_t value)
{
	struct rjd_atomic_int8 atomic;
	struct rjd_atomic_int8_osx* atomic_osx = (struct rjd_atomic_int8_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

int8_t rjd_atomic_int8_get(struct rjd_atomic_int8* atomic)
{
	struct rjd_atomic_int8_osx* atomic_osx = (struct rjd_atomic_int8_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_int8_set(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_osx* atomic_osx = (struct rjd_atomic_int8_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

int8_t rjd_atomic_int8_add(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_osx* atomic_osx = (struct rjd_atomic_int8_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

int8_t rjd_atomic_int8_sub(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_osx* atomic_osx = (struct rjd_atomic_int8_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

int8_t rjd_atomic_int8_inc(struct rjd_atomic_int8* atomic)
{
	return rjd_atomic_int8_add(atomic, 1);
}

int8_t rjd_atomic_int8_dec(struct rjd_atomic_int8* atomic)
{
	return rjd_atomic_int8_sub(atomic, 1);
}

bool rjd_atomic_int8_compare_exchange_weak(struct rjd_atomic_int8* atomic, int8_t* expected, int8_t desired)
{
	struct rjd_atomic_int8_osx* atomic_osx = (struct rjd_atomic_int8_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_int8_compare_exchange_strong(struct rjd_atomic_int8* atomic, int8_t* expected, int8_t desired)
{
	struct rjd_atomic_int8_osx* atomic_osx = (struct rjd_atomic_int8_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint64 rjd_atomic_uint64_init (uint64_t value)
{
	struct rjd_atomic_uint64 atomic;
	struct rjd_atomic_uint64_osx* atomic_osx = (struct rjd_atomic_uint64_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

uint64_t rjd_atomic_uint64_get(struct rjd_atomic_uint64* atomic)
{
	struct rjd_atomic_uint64_osx* atomic_osx = (struct rjd_atomic_uint64_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_uint64_set(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_osx* atomic_osx = (struct rjd_atomic_uint64_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

uint64_t rjd_atomic_uint64_add(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_osx* atomic_osx = (struct rjd_atomic_uint64_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

uint64_t rjd_atomic_uint64_sub(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_osx* atomic_osx = (struct rjd_atomic_uint64_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

uint64_t rjd_atomic_uint64_inc(struct rjd_atomic_uint64* atomic)
{
	return rjd_atomic_uint64_add(atomic, 1);
}

uint64_t rjd_atomic_uint64_dec(struct rjd_atomic_uint64* atomic)
{
	return rjd_atomic_uint64_sub(atomic, 1);
}

bool rjd_atomic_uint64_compare_exchange_weak(struct rjd_atomic_uint64* atomic, uint64_t* expected, uint64_t desired)
{
	struct rjd_atomic_uint64_osx* atomic_osx = (struct rjd_atomic_uint64_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_uint64_compare_exchange_strong(struct rjd_atomic_uint64* atomic, uint64_t* expected, uint64_t desired)
{
	struct rjd_atomic_uint64_osx* atomic_osx = (struct rjd_atomic_uint64_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint32 rjd_atomic_uint32_init (uint32_t value)
{
	struct rjd_atomic_uint32 atomic;
	struct rjd_atomic_uint32_osx* atomic_osx = (struct rjd_atomic_uint32_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

uint32_t rjd_atomic_uint32_get(struct rjd_atomic_uint32* atomic)
{
	struct rjd_atomic_uint32_osx* atomic_osx = (struct rjd_atomic_uint32_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_uint32_set(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_osx* atomic_osx = (struct rjd_atomic_uint32_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

uint32_t rjd_atomic_uint32_add(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_osx* atomic_osx = (struct rjd_atomic_uint32_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

uint32_t rjd_atomic_uint32_sub(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_osx* atomic_osx = (struct rjd_atomic_uint32_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

uint32_t rjd_atomic_uint32_inc(struct rjd_atomic_uint32* atomic)
{
	return rjd_atomic_uint32_add(atomic, 1);
}

uint32_t rjd_atomic_uint32_dec(struct rjd_atomic_uint32* atomic)
{
	return rjd_atomic_uint32_sub(atomic, 1);
}

bool rjd_atomic_uint32_compare_exchange_weak(struct rjd_atomic_uint32* atomic, uint32_t* expected, uint32_t desired)
{
	struct rjd_atomic_uint32_osx* atomic_osx = (struct rjd_atomic_uint32_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_uint32_compare_exchange_strong(struct rjd_atomic_uint32* atomic, uint32_t* expected, uint32_t desired)
{
	struct rjd_atomic_uint32_osx* atomic_osx = (struct rjd_atomic_uint32_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

struct rjd_atomic_uint16 rjd_atomic_uint16_init (uint16_t value)
{
	struct rjd_atomic_uint16 atomic;
	struct rjd_atomic_uint16_osx* atomic_osx = (struct rjd_atomic_uint16_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

////////////////////////////////////////////////////////////////////////////////

uint16_t rjd_atomic_uint16_get(struct rjd_atomic_uint16* atomic)
{
	struct rjd_atomic_uint16_osx* atomic_osx = (struct rjd_atomic_uint16_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_uint16_set(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_osx* atomic_osx = (struct rjd_atomic_uint16_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

uint16_t rjd_atomic_uint16_add(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_osx* atomic_osx = (struct rjd_atomic_uint16_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

uint16_t rjd_atomic_uint16_sub(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_osx* atomic_osx = (struct rjd_atomic_uint16_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

uint16_t rjd_atomic_uint16_inc(struct rjd_atomic_uint16* atomic)
{
	return rjd_atomic_uint16_add(atomic, 1);
}

uint16_t rjd_atomic_uint16_dec(struct rjd_atomic_uint16* atomic)
{
	return rjd_atomic_uint16_sub(atomic, 1);
}

bool rjd_atomic_uint16_compare_exchange_weak(struct rjd_atomic_uint16* atomic, uint16_t* expected, uint16_t desired)
{
	struct rjd_atomic_uint16_osx* atomic_osx = (struct rjd_atomic_uint16_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_uint16_compare_exchange_strong(struct rjd_atomic_uint16* atomic, uint16_t* expected, uint16_t desired)
{
	struct rjd_atomic_uint16_osx* atomic_osx = (struct rjd_atomic_uint16_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint8 rjd_atomic_uint8_init (uint8_t value)
{
	struct rjd_atomic_uint8 atomic;
	struct rjd_atomic_uint8_osx* atomic_osx = (struct rjd_atomic_uint8_osx*)&atomic;
	atomic_store(&atomic_osx->value, value);
	return atomic;
}

uint8_t rjd_atomic_uint8_get(struct rjd_atomic_uint8* atomic)
{
	struct rjd_atomic_uint8_osx* atomic_osx = (struct rjd_atomic_uint8_osx*)atomic;
	return atomic_load(&atomic_osx->value);
}

void rjd_atomic_uint8_set(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_osx* atomic_osx = (struct rjd_atomic_uint8_osx*)atomic;
	atomic_store(&atomic_osx->value, value);
}

uint8_t rjd_atomic_uint8_add(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_osx* atomic_osx = (struct rjd_atomic_uint8_osx*)atomic;
	return atomic_fetch_add(&atomic_osx->value, value); // returns original value
}

uint8_t rjd_atomic_uint8_sub(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_osx* atomic_osx = (struct rjd_atomic_uint8_osx*)atomic;
	return atomic_fetch_sub(&atomic_osx->value, value); // returns original value
}

uint8_t rjd_atomic_uint8_inc(struct rjd_atomic_uint8* atomic)
{
	return rjd_atomic_uint8_add(atomic, 1);
}

uint8_t rjd_atomic_uint8_dec(struct rjd_atomic_uint8* atomic)
{
	return rjd_atomic_uint8_sub(atomic, 1);
}

bool rjd_atomic_uint8_compare_exchange_weak(struct rjd_atomic_uint8* atomic, uint8_t* expected, uint8_t desired)
{
	struct rjd_atomic_uint8_osx* atomic_osx = (struct rjd_atomic_uint8_osx*)atomic;
	return atomic_compare_exchange_weak(&atomic_osx->value, expected, desired);
}

bool rjd_atomic_uint8_compare_exchange_strong(struct rjd_atomic_uint8* atomic, uint8_t* expected, uint8_t desired)
{
	struct rjd_atomic_uint8_osx* atomic_osx = (struct rjd_atomic_uint8_osx*)atomic;
	return atomic_compare_exchange_strong(&atomic_osx->value, expected, desired);
}

#endif // RJD_PLATFORM
#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_strpool.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_STRPOOL_H 1

struct rjd_strpool
{
	struct rjd_dict storage;
};

struct rjd_strref;

struct rjd_strpool rjd_strpool_init(struct rjd_mem_allocator* allocator, size_t initial_capacity);
void rjd_strpool_free(struct rjd_strpool* pool);
struct rjd_strref* rjd_strpool_add(struct rjd_strpool* pool, const char* fmt, ...);
struct rjd_strref* rjd_strpool_addv(struct rjd_strpool* pool, const char* fmt, va_list args); 
struct rjd_strref* rjd_strpool_addl(struct rjd_strpool* pool, const char* str, size_t length);
void rjd_strref_release(struct rjd_strref* ref);
const char* rjd_strref_str(const struct rjd_strref* ref);
uint32_t rjd_strref_length(const struct rjd_strref* ref);

#if RJD_IMPL

struct rjd_strref
{
	const char* str;
	struct rjd_strpool* owner;
	int32_t refcount;
	uint32_t length;
};

static struct rjd_strref* rjd_strpool_addimpl(struct rjd_strpool* pool, const char* str);

struct rjd_strpool rjd_strpool_init(struct rjd_mem_allocator* allocator, size_t initial_capacity)
{
	RJD_ASSERT(allocator);

	struct rjd_strpool pool = { rjd_dict_init(allocator, initial_capacity * 2) };
	return pool;
}

void rjd_strpool_free(struct rjd_strpool* pool)
{
	RJD_ASSERT(pool);

	void** refs = pool->storage.values;
	for (uint32_t i = 0; i < rjd_array_count(refs); ++i) {
		if (refs[i]) {
			struct rjd_strref* ref = refs[i];
			rjd_mem_free(ref); // struct and string are part of the same allocation block
		}
	}
	rjd_dict_free(&pool->storage);
}

struct rjd_strref* rjd_strpool_add(struct rjd_strpool* pool, const char* format, ...)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	va_list args;
	va_start(args, format);
		ref = rjd_strpool_addv(pool, format, args);
	va_end(args);

	return ref;
}

struct rjd_strref* rjd_strpool_addv(struct rjd_strpool* pool, const char* format, va_list args)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	RJD_STRBUF_SCOPED(buffer, pool->storage.allocator, {
		rjd_strbuf_appendv(&buffer, format, args);
		ref = rjd_strpool_addimpl(pool, rjd_strbuf_str(&buffer));
	});

	return ref;
}

struct rjd_strref* rjd_strpool_addl(struct rjd_strpool* pool, const char* format, size_t length)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	RJD_STRBUF_SCOPED(buffer, pool->storage.allocator, {
		rjd_strbuf_appendl(&buffer, format, (uint32_t)length);
		ref = rjd_strpool_addimpl(pool, rjd_strbuf_str(&buffer));
	});

	return ref;
}

void rjd_strref_release(struct rjd_strref* ref)
{
	RJD_ASSERT(ref);

	struct rjd_strpool* pool = ref->owner;

	struct rjd_hash64 hash = rjd_hash64_data((const uint8_t*)ref->str, -1);
	RJD_ASSERTMSG(rjd_dict_get(&pool->storage, hash) == ref, "ref was not contained in string pool");

	--ref->refcount;
	if (ref->refcount <= 0) {
		rjd_mem_free(ref); // struct and string are part of the same allocation block
		rjd_dict_erase(&pool->storage, hash);
	}
}

const char* rjd_strref_str(const struct rjd_strref* ref)
{
	RJD_ASSERT(ref);
	return ref->str;
}

uint32_t rjd_strref_length(const struct rjd_strref* ref)
{
	RJD_ASSERT(ref);
	return ref->length;
}

static struct rjd_strref* rjd_strpool_addimpl(struct rjd_strpool* pool, const char* str) 
{
	RJD_ASSERT(pool);
	RJD_ASSERT(str);

	struct rjd_hash64 hash = rjd_hash64_data((const uint8_t*)str, -1);
	struct rjd_strref* ref = rjd_dict_get(&pool->storage, hash);
	if (!ref) {
		uint8_t* mem = rjd_mem_alloc_array(uint8_t, sizeof(struct rjd_strref) + strlen(str) + 1, pool->storage.allocator);
		ref = (struct rjd_strref*)mem;

		char* copied_str = (char*)(mem + sizeof(struct rjd_strref));
		strcpy(copied_str, str);

		ref->str = copied_str;
		ref->owner = pool;
		ref->refcount = 0;
		ref->length = (uint32_t)strlen(ref->str);

		rjd_dict_insert(&pool->storage, hash, ref);
	}
	++ref->refcount;

	return ref;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_slotmap.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_SLOTMAP_H 1

struct rjd_slot
{
	uint16_t index;
	uint16_t salt;
};

static inline bool rjd_slot_isvalid(struct rjd_slot slot);
static inline void rjd_slot_invalidate(struct rjd_slot* slot);

#define rjd_slotmap_alloc(type, capacity, allocator)	(rjd_slotmap_alloc_impl(sizeof(type), capacity, allocator))
#define rjd_slotmap_insert(map, data, out_slot)		    (rjd_slotmap_insert_impl((void**)(&map), (out_slot)), \
													        (map)[(out_slot)->index] = data)
#define rjd_slotmap_contains(map, slot)				    (rjd_slotmap_contains_impl((map), (slot)))
#define rjd_slotmap_get(map, slot)				    	((map) + rjd_slotmap_get_impl((map), (slot)))
#define rjd_slotmap_count(map)					    	(rjd_slotmap_count_impl(map))
#define rjd_slotmap_erase(map, slot)			    	(rjd_slotmap_erase_impl((map), slot))
#define rjd_slotmap_free(map)					    	(rjd_slotmap_free_impl(map))
#define rjd_slotmap_next(map, slot)				    	(rjd_slotmap_next_impl((map), (slot))) // pass null slot for first

void* rjd_slotmap_alloc_impl(size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator);
void rjd_slotmap_insert_impl(void** map_p, struct rjd_slot* out_slot);
bool rjd_slotmap_contains_impl(const void* map, struct rjd_slot slot);
uint32_t rjd_slotmap_get_impl(const void* map, struct rjd_slot slot);
uint32_t rjd_slotmap_count_impl(const void* map);
void rjd_slotmap_erase_impl(void* map, struct rjd_slot slot);
void rjd_slotmap_free_impl(void* map);
struct rjd_slot rjd_slotmap_next_impl(void* map, const struct rjd_slot* slot);

static inline bool rjd_slot_isvalid(struct rjd_slot slot)
{
	return slot.salt != 0;
}

static inline void rjd_slot_invalidate(struct rjd_slot* slot)
{
	RJD_ASSERT(slot);
	slot->salt = 0;
}

#if RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// private interface

struct rjd_slotmap_header
{
	struct rjd_mem_allocator* allocator;
	void* data;
	uint16_t* salts;
	bool* used;
	uint32_t* freelist;
	uint32_t sizeof_type;
    uint32_t capacity;
	uint32_t count;
	uint32_t debug_sentinel;
};

enum {
	RJD_SLOTMAP_DEBUG_SENTINEL = 0x5A5A5A5A,
};

static struct rjd_slotmap_header* rjd_slotmap_getheader(const void* map);
static void* rjd_slotmap_grow(void* oldmap, size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator);

////////////////////////////////////////////////////////////////////////////////
// public implementation

void* rjd_slotmap_alloc_impl(size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator)
{
	return rjd_slotmap_grow(NULL, sizeof_type, capacity, allocator);
}

void rjd_slotmap_insert_impl(void** map_p, struct rjd_slot* out_slot)
{
	RJD_ASSERT(map_p);
	RJD_ASSERT(*map_p);
	RJD_ASSERT(out_slot);

	void* map = *map_p;

	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

	if (rjd_array_count(header->freelist) == 0) {
		map = rjd_slotmap_grow(map, header->sizeof_type, header->capacity * 2, header->allocator);
		header = rjd_slotmap_getheader(map);
		RJD_ASSERT(rjd_array_count(header->freelist) > 0);
		*map_p = map;
	}

	uint32_t index = rjd_array_pop(header->freelist);

	uint16_t* salt = header->salts + index;
	*salt += 1;

	header->used[index] = true;
    ++header->count;

	out_slot->index = rjd_math_truncate_u32_to_u16(index);
	out_slot->salt = *salt;
}

bool rjd_slotmap_contains_impl(const void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	if (slot.index >= header->capacity) {
		return false;
	}
	uint32_t index = slot.index;
	return !rjd_array_contains(header->freelist, &index);
}

uint32_t rjd_slotmap_get_impl(const void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	RJD_ASSERT(slot.index < header->capacity);
	uint32_t index = slot.index;
	RJD_ASSERTMSG(!rjd_array_contains(header->freelist, &index), "This slot is unallocated. Use rjd_slotmap_contains to check if the slot is valid first.");
    int16_t salt = header->salts[slot.index];
	RJD_ASSERT(salt == slot.salt);
	return slot.index;
}

uint32_t rjd_slotmap_count_impl(const void* map)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	return header->count;
}

void rjd_slotmap_erase_impl(void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	RJD_ASSERT(slot.index < header->capacity);
	
	rjd_array_push(header->freelist, slot.index);
	header->used[slot.index] = false;
    --header->count;
}

void rjd_slotmap_free_impl(void* map)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

    rjd_array_free(header->used);
	rjd_array_free(header->freelist);
	rjd_mem_free(header);
}

struct rjd_slot rjd_slotmap_next_impl(void* map, const struct rjd_slot* slot)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

	uint32_t start = 0;
	if (slot) {
		start = slot->index + 1;
	}

	for (uint32_t i = start; i < header->capacity; ++i) {
		if (header->used[i]) {
			struct rjd_slot next = {
				.index = rjd_math_truncate_u32_to_u16(i),
				.salt = header->salts[i],
			};
			return next;
		}
	}

	struct rjd_slot next = {0};
	RJD_ASSERT(!rjd_slot_isvalid(next));
	return next;
}

////////////////////////////////////////////////////////////////////////////////
// private implementation

struct rjd_slotmap_header* rjd_slotmap_getheader(const void* map)
{
	char* raw = (char*)map;
	char* rawheader = (raw - sizeof(struct rjd_slotmap_header));
	struct rjd_slotmap_header* header = (struct rjd_slotmap_header*)rawheader;
	RJD_ASSERTMSG(header->debug_sentinel == RJD_SLOTMAP_DEBUG_SENTINEL, 
		"Debug sentinel does not match. Address %p does not point to a slotmap or there was a buffer underrun corruption.", map);
	return header;
}

void* rjd_slotmap_grow(void* oldmap, size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator)
{
	struct rjd_slotmap_header* oldheader = oldmap ? rjd_slotmap_getheader(oldmap) : NULL;

	uint32_t oldcapacity = oldheader ? oldheader->capacity : 0;
	if (capacity <= oldcapacity) {
		return oldmap;
	}

	size_t total_mem_size = sizeof(struct rjd_slotmap_header) + sizeof_type * capacity + sizeof(uint16_t) * capacity;
	char* mem = rjd_mem_alloc_array(char, total_mem_size, allocator);
	memset(mem, 0, total_mem_size);

	struct rjd_slotmap_header* header = (struct rjd_slotmap_header*)mem;
	header->allocator = allocator;
	header->sizeof_type = (uint32_t)sizeof_type;
	header->capacity = capacity;
    header->count = 0;
	header->data = (void*)(mem + sizeof(struct rjd_slotmap_header));
	header->salts = (uint16_t*)((char*)header->data + sizeof_type * capacity);
	header->used = rjd_array_alloc(bool, capacity, allocator);
	header->freelist = rjd_array_alloc(uint32_t, capacity, allocator);
	header->debug_sentinel = RJD_SLOTMAP_DEBUG_SENTINEL;

	memset(header->salts + oldcapacity, 0, (header->capacity - oldcapacity) * sizeof(*header->salts));

	rjd_array_resize(header->used, capacity);
	if (oldheader) {
		memcpy(header->used, oldheader->used, sizeof(*header->used) * oldheader->capacity);
        header->count = oldheader->count;
	}

	for (uint32_t i = oldcapacity; i < capacity; ++i) {
		rjd_array_push(header->freelist, i);
	}

	// copy existing data
	if (oldheader) {
		memcpy(header->data, oldheader->data, sizeof_type * oldheader->capacity);
		memcpy(header->salts, oldheader->salts, sizeof(uint16_t) * oldheader->capacity);
		rjd_slotmap_free(oldmap);
	}

	return header->data;
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_utf8.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_UTF8_H 1

const char* rjd_utf8_bom_skip(const char* string); // expects a NULL-terminated string
struct rjd_result rjd_utf8_bom_write(char* buffer, size_t size);
const char* rjd_utf8_next(const char* string); // returns NULL if string is not UTF8-encoded

#if RJD_IMPL

const char* rjd_utf8_bom_skip(const char* string)
{
	const uint8_t* s = (const uint8_t*)string;
	if (s != NULL &&
		*(s + 0) == 0xEF &&
		*(s + 1) == 0xBB &&
		*(s + 2) == 0xBF)
	{
		return string + 3;
	}
	return string;
}

struct rjd_result rjd_utf8_bom_write(char* buffer, size_t size)
{
	if (size <= 3) {
		return RJD_RESULT("Buffer must be at least 3 characters long.");
	}

	*(buffer + 0) = 0xEF;
	*(buffer + 1) = 0xBB;
	*(buffer + 2) = 0xBF;

	return RJD_RESULT_OK();
}

const char* rjd_utf8_next(const char* string)
{
	if (string == NULL || *string == '\0') {
		return string;
	}

	uint8_t byte = (uint8_t)*string;

    if ((byte >> 7) == 0x00) {
        return string + 1;
    } else if ((byte >> 5) == 0x06) { // 0b110
        return string + 2;
    } else if ((byte >> 4) == 0x0E) { // 0b1110
        return string + 3;
    } else if ((byte >> 3) == 0x1E) { //0b11110
        return string + 4;
    }

	// if we're in the middle of a character, skip to the end of the current character
    bool is_mid_character = (byte >> 6) == 0x02; // 0b10
	if (is_mid_character) {
		while (is_mid_character) {
			++string;
			byte = *string;
			if (byte == '\0') {
				break;
			}
            is_mid_character = (byte >> 6) == 0x02; //0b10
		}
		return string;
	}

	return NULL; // invalid UTF8 string
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_path.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PATH_H 1

#ifndef RJD_PATH_BUFFER_LENGTH
	#define RJD_PATH_BUFFER_LENGTH 256
#endif

struct rjd_path
{
	uint32_t length;
	char str[RJD_PATH_BUFFER_LENGTH];
};

struct rjd_path_enumerator_state
{
	char impl[16];
};

struct rjd_path rjd_path_create(void);
struct rjd_path rjd_path_create_with(const char* path);
void rjd_path_append(struct rjd_path* path, const char* str);
void rjd_path_join(struct rjd_path* path1, const struct rjd_path* path2);
const char* rjd_path_get(struct rjd_path* path);
void rjd_path_clear(struct rjd_path* path);
const char* rjd_path_extension(const struct rjd_path* path);
const char* rjd_path_extension_str(const char* path);

struct rjd_path_enumerator_state rjd_path_enumerate_create(const char* path);
const char* rjd_path_enumerate_next(struct rjd_path_enumerator_state* state);
void rjd_path_enumerate_destroy(struct rjd_path_enumerator_state* state);

#if RJD_IMPL

#if RJD_PLATFORM_WINDOWS
	#define RJD_PATH_SLASH ('/')
#elif RJD_PLATFORM_OSX
	#define RJD_PATH_SLASH ('/')
#else
	#error "Unknown platform"
#endif

static uint32_t rjd_path_normalize_slashes(char* path, uint32_t length);

struct rjd_path rjd_path_create()
{
	struct rjd_path path = {0};
	return path;
}

struct rjd_path rjd_path_create_with(const char* initial_contents)
{
	struct rjd_path path;
	char* end = stpncpy(path.str, initial_contents, RJD_PATH_BUFFER_LENGTH - 1);
	*end = '\0';
	path.length = (uint32_t)(end - path.str);
	RJD_ASSERT(path.length <= RJD_PATH_BUFFER_LENGTH);

	path.length = rjd_path_normalize_slashes(path.str, path.length);
	return path;
}

void rjd_path_append(struct rjd_path* path, const char* str)
{
    const char slash = RJD_PATH_SLASH;
    
	uint32_t start = path->length;
	uint32_t max_length = RJD_PATH_BUFFER_LENGTH - 1;
	if (start > 0 && start < max_length && path->str[start - 1] != slash && str[0] != slash) {
		path->str[start] = slash;
		++start;
	}

	char* end = stpncpy(path->str + start, str, max_length - start);
    uint32_t length = (uint32_t)(end - path->str);

	path->length = rjd_path_normalize_slashes(path->str, length);
}

void rjd_path_join(struct rjd_path* path1, const struct rjd_path* path2)
{
	rjd_path_append(path1, path2->str);
}

const char* rjd_path_get(struct rjd_path* path)
{
	return path->str;
}

const char* rjd_path_extension(const struct rjd_path* path)
{
	return rjd_path_extension_str(path->str);
}

const char* rjd_path_extension_str(const char* path)
{
    if (!path) {
        return NULL;
    }

	const char* extension = strrchr(path, '.');
	if (!extension) {
		return NULL;
	}

	// If a path ends with a period, it doesn't have an extension
	if (extension[1] == '\0') {
		return NULL;
	}

	return extension;
}

void rjd_path_clear(struct rjd_path* path)
{
	RJD_ASSERT(path);
	path->str[0] = '\0';
}

// local helpers
static uint32_t rjd_path_normalize_slashes(char* path, uint32_t length)
{
    if (length == 0) {
        return length;
    }

    for (int32_t i = length - 1; i > 0 && path[i] == RJD_PATH_SLASH; --i) {
		path[i] = '\0';
        --length;
	}

	char* end = path + length;
	for (char* start = end - 1; start > path; --start)
	{
		while (*start != RJD_PATH_SLASH && start > path) {
			--start;
		}

		char* slot = start;
        while (slot > path && *(slot - 1) == RJD_PATH_SLASH) {
            --slot;
        }

        if (start - slot > 0) {
            uint32_t sublength = (uint32_t)(end - start);
			memmove(slot, start, sublength + 1);
            
            uint32_t trimmed_size = (uint32_t)(start - slot);
            end -= trimmed_size;
		}
		start = slot;
	}

    size_t newlength = end - path;
    RJD_ASSERT(newlength == strlen(path));
    return (uint32_t)(end - path);
}

#if RJD_PLATFORM_WINDOWS
#elif RJD_PLATFORM_OSX

#if !RJD_LANG_OBJC
	#error "rjd_path implementation on OSX uses Objective-C interfaces. You must #include this file in a .m file."
#endif

#import <Foundation/Foundation.h>

struct rjd_path_enumerator_state_osx
{
	NSDirectoryEnumerator<NSString*>* enumerator;
	NSString* next;
};

struct rjd_path_enumerator_state rjd_path_enumerate_create(const char* path)
{
	RJD_ASSERT(path);

	NSFileManager* manager = [NSFileManager defaultManager];
	NSString* startingPath = [NSString stringWithUTF8String:path];

	// NSFileManager:enumeratorAtPath is threadsafe
	NSDirectoryEnumerator<NSString*>* enumerator = [manager enumeratorAtPath:startingPath];
	[enumerator skipDescendants];

	struct rjd_path_enumerator_state state = {0};
	struct rjd_path_enumerator_state_osx* state_osx = (struct rjd_path_enumerator_state_osx*)&state;
	state_osx->enumerator = enumerator;
	state_osx->next = nil;

	return state;
}

const char* rjd_path_enumerate_next(struct rjd_path_enumerator_state* state)
{
	RJD_ASSERT(state);

	struct rjd_path_enumerator_state_osx* state_osx = (struct rjd_path_enumerator_state_osx*)state;
	state_osx->next = (NSString*) [state_osx->enumerator nextObject];
	
	return state_osx->next.UTF8String;
}

void rjd_path_enumerate_destroy(struct rjd_path_enumerator_state* state)
{
	RJD_ASSERT(state);

	struct rjd_path_enumerator_state_osx* state_osx = (struct rjd_path_enumerator_state_osx*)state;
	state_osx->enumerator = nil;
	state_osx->next = nil;
}

#endif // RJD_PLATFORM_OSX && RJD_LANG_OBJC
#endif // RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// rjd_stream.h
////////////////////////////////////////////////////////////////////////////////

#define RJD_STREAM_H 1

// rjd_istream API design based on Fabien Giesen's Buffer-Centric IO:
// https://fgiesen.wordpress.com/2011/11/21/buffer-centric-io/

struct rjd_istream;

typedef struct rjd_result rjd_istream_refill_func(struct rjd_istream* stream);
typedef void rjd_istream_close_func(struct rjd_istream* stream);

struct rjd_istream
{
	const uint8_t* start;
	const uint8_t* end;
	const uint8_t* cursor;
	void* userdata;
	struct rjd_result result;
	rjd_istream_refill_func* refill;
	rjd_istream_close_func* close;
};

// Pass this as buffer_size in rjd_istream_from_file to read the entire file into memory
enum
{
	RJD_ISTREAM_FILE_BUFFER_SIZE_ALL = 0,
};

enum rjd_ostream_type
{
	RJD_OSTREAM_TYPE_MEMORY,
	RJD_OSTREAM_TYPE_FILE,
};

struct rjd_ostream_memory
{
	uint8_t* buffer;
	uint32_t size;
	uint32_t cursor;
};

struct rjd_ostream_file
{
	FILE* file;
};

struct rjd_ostream
{
	enum rjd_ostream_type type;
	union {
		struct rjd_ostream_memory memory;
		struct rjd_ostream_file file;
	} state;
};

enum rjd_ostream_mode
{
	RJD_OSTREAM_MODE_REPLACE,
	RJD_OSTREAM_MODE_APPEND,
};

struct rjd_mem_allocator;

struct rjd_istream rjd_istream_from_zeroes(void);
struct rjd_istream rjd_istream_from_memory(const void* buffer, uint32_t size);
struct rjd_istream rjd_istream_from_file(const char* filepath, struct rjd_mem_allocator* allocator, uint32_t buffer_size);
struct rjd_result rjd_istream_read(struct rjd_istream* stream, void* buffer, uint32_t size); 
void rjd_istream_close(struct rjd_istream* stream);

struct rjd_ostream rjd_ostream_from_memory(void* buffer, uint32_t size);
struct rjd_ostream rjd_ostream_from_file(const char* filepath, enum rjd_ostream_mode);
struct rjd_result rjd_ostream_write(struct rjd_ostream* stream, const void* buffer, uint32_t size);
void rjd_ostream_close(struct rjd_ostream* stream);

#if RJD_IMPL

static struct rjd_result rjd_istream_fail(struct rjd_istream* stream, const char* reason);
static struct rjd_result rjd_istream_refill_zeroes(struct rjd_istream* stream);
static struct rjd_result rjd_istream_refill_memory(struct rjd_istream* stream);
static struct rjd_result rjd_istream_refill_file(struct rjd_istream* stream);
static void rjd_istream_close_file(struct rjd_istream* stream);

struct rjd_istream rjd_istream_from_zeroes()
{
	struct rjd_istream stream = 
	{
		.start = NULL,
		.end = NULL,
		.cursor = NULL,
		.userdata = NULL,
		.result = RJD_RESULT_OK(),
		.refill = rjd_istream_refill_zeroes,
		.close = NULL,
	};
	stream.refill(&stream);
	return stream;
}

struct rjd_istream rjd_istream_from_memory(const void* buffer, uint32_t size)
{
	const uint8_t* cbuffer = buffer;

	struct rjd_istream stream =
	{
		.start = cbuffer,
		.end = cbuffer + size,
		.cursor = cbuffer,
		.userdata = NULL,
		.result = RJD_RESULT_OK(),
		.refill = rjd_istream_refill_memory,
		.close = NULL,
	};
	return stream;
}

struct rjd_istream rjd_istream_from_file(const char* filepath, struct rjd_mem_allocator* allocator, uint32_t buffer_size)
{
	RJD_ASSERT(filepath);
	RJD_ASSERT(allocator);

	uint8_t* buffer = NULL;
	struct rjd_result result = RJD_RESULT_OK();
	FILE* file = fopen(filepath, "rb");

	if (file) {
		if (buffer_size == RJD_ISTREAM_FILE_BUFFER_SIZE_ALL) {
			result = RJD_RESULT("Failed to get file length");
			if (fseek(file, 0, SEEK_END) == 0) {
				long int length = ftell(file);
				if (length >= 0) {
					if (fseek(file, 0, SEEK_SET) == 0) {
						buffer_size = (uint32_t)length;
						result = RJD_RESULT_OK();
					}
				}
			}
		}
	} else {
		result = RJD_RESULT("Failed to open file");
	}

	if (rjd_result_isok(result)) {
		buffer = rjd_mem_alloc_array(uint8_t, buffer_size, allocator);
	}

	struct rjd_istream stream =
	{
		.start = buffer,
		.end = buffer + buffer_size,
		.cursor = buffer,
		.userdata = file,
		.refill = rjd_istream_refill_file,
		.close = rjd_istream_close_file,
	};
	stream.result = stream.refill(&stream);
	return stream;
}

struct rjd_result rjd_istream_read(struct rjd_istream* stream, void* buffer, uint32_t size)
{
	RJD_ASSERT(stream);
	RJD_ASSERT(buffer);
	RJD_ASSERT(size > 0);

    uint8_t* offset_buffer = buffer;
	uint32_t bytes_remaining = size;
	while (bytes_remaining > 0) {
		if (stream->cursor == stream->end) {
			stream->result = stream->refill(stream);
		}
        RJD_ASSERT(stream->end >= stream->cursor)
		ptrdiff_t buffersize = stream->end - stream->cursor;
		uint32_t readsize = rjd_math_minu32((uint32_t)buffersize, bytes_remaining);

		memcpy(offset_buffer, stream->cursor, readsize);
        
        offset_buffer += readsize;
		bytes_remaining -= readsize;
		stream->cursor += readsize;
	}

	return stream->result;
}

void rjd_istream_close(struct rjd_istream* stream)
{
	RJD_ASSERT(stream);

	if (stream->close) {
		stream->close(stream);
	}
}

struct rjd_ostream rjd_ostream_from_memory(void* buffer, uint32_t size)
{
	struct rjd_ostream stream = 
	{
		.type = RJD_OSTREAM_TYPE_MEMORY,
		.state = {
			.memory = { buffer, size, 0 },
		},
	};
	return stream;
}

struct rjd_ostream rjd_ostream_from_file(const char* filepath, enum rjd_ostream_mode mode)
{
	const char* writemode = NULL;
	switch (mode)
	{
		case RJD_OSTREAM_MODE_REPLACE: writemode = "wb"; break;
		case RJD_OSTREAM_MODE_APPEND:  writemode = "ab"; break;
	}
	RJD_ASSERT(writemode);
	FILE* file = fopen(filepath, writemode);

	struct rjd_ostream stream =
	{
		.type = RJD_OSTREAM_TYPE_FILE,
		.state = {
			.file = { file },
		},
	};
	return stream;
}

struct rjd_result rjd_ostream_write(struct rjd_ostream* stream, const void* buffer, uint32_t size)
{
	if (stream->type == RJD_OSTREAM_TYPE_MEMORY) {
		struct rjd_ostream_memory* state = &stream->state.memory;
		RJD_ASSERT(state->size >= state->cursor);

		const uint32_t bytes_remaining = state->size - state->cursor;
		if (size > bytes_remaining) {
			return RJD_RESULT("attempted to write more data than the buffer can hold");
		}

		const uint8_t* cbuffer = buffer;
		RJD_ASSERTMSG(!(cbuffer >= state->buffer && cbuffer < state->buffer + state->size), 
					"source and destination buffers must not overlap");

		memcpy(state->buffer + state->cursor, buffer, size);
		state->cursor += size;
	} else if (stream->type == RJD_OSTREAM_TYPE_FILE) {
		struct rjd_ostream_file* state = &stream->state.file;
		if (state->file == NULL) {
			return RJD_RESULT("failed to open file for writing");
		}
		
		size_t bytes_written = fwrite(buffer, 1, size, state->file);
		if (bytes_written != size) {
			return RJD_RESULT("failed to write all data to file");
		}
	}

	return RJD_RESULT_OK();
}

void rjd_ostream_close(struct rjd_ostream* stream)
{
	if (stream->type == RJD_OSTREAM_TYPE_MEMORY) {
		stream->state.memory.buffer = NULL;
	} else if (stream->type == RJD_OSTREAM_TYPE_FILE) {
		fclose(stream->state.file.file);
	}
}

////////////////////////////////////////////////////////////////////////////////
// static helpers

static struct rjd_result rjd_istream_fail(struct rjd_istream* stream, const char* reason)
{
	stream->result = RJD_RESULT(reason);
	stream->refill = rjd_istream_refill_zeroes;
	return stream->refill(stream);
}

static struct rjd_result rjd_istream_refill_zeroes(struct rjd_istream* stream)
{
	static uint8_t zeroes[128] = {0};

	stream->start = zeroes;
	stream->end = zeroes + sizeof(zeroes);
	stream->cursor = stream->start;
	return stream->result;
}

static struct rjd_result rjd_istream_refill_memory(struct rjd_istream* stream)
{
	return rjd_istream_fail(stream, "reached end of memory buffer");
}

static struct rjd_result rjd_istream_refill_file(struct rjd_istream* stream)
{
	FILE* file = (FILE*)stream->userdata;

	 // cast to non-const since we know the file buffer is ok to write to
	void* writable_buffer = (void*)stream->start;
	ptrdiff_t bytes_wanted = stream->end - stream->start;
	int32_t bytes_read = (int32_t)fread(writable_buffer, 1, bytes_wanted, file);

    RJD_ASSERT(bytes_read <= bytes_wanted);
    
	if (bytes_read < bytes_wanted) {
		if (feof(file)) {
			if (bytes_read == 0) {
				rjd_istream_close_file(stream);
				rjd_istream_fail(stream, "end of file reached, no more data available");
			} else {
				stream->end = stream->start + bytes_read;
                stream->cursor = stream->start;
                stream->result = RJD_RESULT_OK();
			}
		} else {
			rjd_istream_close_file(stream);
			rjd_istream_fail(stream, "error reading file contents into memory");
		}
	} else {
        if (feof(file)) {
            rjd_istream_fail(stream, "end of file reached, no more data available");
        } else {
            stream->cursor = stream->start;
        }
    }

	return stream->result;
}

static void rjd_istream_close_file(struct rjd_istream* stream)
{
	rjd_mem_free(stream->start);
	FILE* file = (FILE*)stream->userdata;
	if (file) {
		fclose(file);
	}

	stream->userdata = NULL;
	stream->refill = rjd_istream_refill_zeroes;
	stream->close = NULL;

	stream->refill(stream);
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_binrw.h
////////////////////////////////////////////////////////////////////////////////

#define RJD_BINRW_H 1

struct rjd_istream;
struct rjd_ostream;

struct rjd_binrw_state
{
	struct rjd_istream* istream;
	struct rjd_ostream* ostream;
};

static inline struct rjd_result rjd_binrw_read_int8(struct rjd_istream* stream, int8_t* value);
static inline struct rjd_result rjd_binrw_read_int16(struct rjd_istream* stream, int16_t* value);
static inline struct rjd_result rjd_binrw_read_int32(struct rjd_istream* stream, int32_t* value);
static inline struct rjd_result rjd_binrw_read_int64(struct rjd_istream* stream, int64_t* value);
static inline struct rjd_result rjd_binrw_read_uint8(struct rjd_istream* stream, uint8_t* value);
static inline struct rjd_result rjd_binrw_read_uint16(struct rjd_istream* stream, uint16_t* value);
static inline struct rjd_result rjd_binrw_read_uint32(struct rjd_istream* stream, uint32_t* value);
static inline struct rjd_result rjd_binrw_read_uint64(struct rjd_istream* stream, uint64_t* value);

static inline struct rjd_result rjd_binrw_write_int8(struct rjd_ostream* stream, int8_t value);
static inline struct rjd_result rjd_binrw_write_int16(struct rjd_ostream* stream, int16_t value);
static inline struct rjd_result rjd_binrw_write_int32(struct rjd_ostream* stream, int32_t value);
static inline struct rjd_result rjd_binrw_write_int64(struct rjd_ostream* stream, int64_t value);
static inline struct rjd_result rjd_binrw_write_uint8(struct rjd_ostream* stream, uint8_t value);
static inline struct rjd_result rjd_binrw_write_uint16(struct rjd_ostream* stream, uint16_t value);
static inline struct rjd_result rjd_binrw_write_uint32(struct rjd_ostream* stream, uint32_t value);
static inline struct rjd_result rjd_binrw_write_uint64(struct rjd_ostream* stream, uint64_t value);

static inline struct rjd_result rjd_binrw_readwrite_int8(struct rjd_binrw_state* state, int8_t* value);
static inline struct rjd_result rjd_binrw_readwrite_int16(struct rjd_binrw_state* state, int16_t* value);
static inline struct rjd_result rjd_binrw_readwrite_int32(struct rjd_binrw_state* state, int32_t* value);
static inline struct rjd_result rjd_binrw_readwrite_int64(struct rjd_binrw_state* state, int64_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint8(struct rjd_binrw_state* state, uint8_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint16(struct rjd_binrw_state* state, uint16_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint32(struct rjd_binrw_state* state, uint32_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint64(struct rjd_binrw_state* state, uint64_t* value);

////////////////////////////////////////////////////////////////////////////////
// implementation

#define RJD_BINRW_DEFINE_READ_IMPL(type, name)										\
	static inline struct rjd_result name(struct rjd_istream* stream, type* value) {	\
		RJD_ASSERT(stream && value);												\
		return rjd_istream_read(stream, value, sizeof(*value));						\
	}

#define RJD_BINRW_DEFINE_WRITE_IMPL(type, name)										\
	static inline struct rjd_result name(struct rjd_ostream* stream, type value) {	\
		RJD_ASSERT(stream);															\
		return rjd_ostream_write(stream, &value, sizeof(value));					\
	}

#define RJD_BINRW_DEFINE_READWRITE_IMPL(type, type2, name)								\
	static inline struct rjd_result name(struct rjd_binrw_state* state, type* value) {	\
		RJD_ASSERT(state && value && (state->istream || state->ostream));				\
		if (state->istream) {															\
			return rjd_binrw_read_ ## type2(state->istream, value);						\
		} else {																		\
			return rjd_binrw_write_ ## type2(state->ostream, *value);					\
		}																				\
	}

RJD_BINRW_DEFINE_READ_IMPL(int8_t, rjd_binrw_read_int8)
RJD_BINRW_DEFINE_READ_IMPL(int16_t, rjd_binrw_read_int16)
RJD_BINRW_DEFINE_READ_IMPL(int32_t, rjd_binrw_read_int32)
RJD_BINRW_DEFINE_READ_IMPL(int64_t, rjd_binrw_read_int64)
RJD_BINRW_DEFINE_READ_IMPL(uint8_t, rjd_binrw_read_uint8)
RJD_BINRW_DEFINE_READ_IMPL(uint16_t, rjd_binrw_read_uint16)
RJD_BINRW_DEFINE_READ_IMPL(uint32_t, rjd_binrw_read_uint32)
RJD_BINRW_DEFINE_READ_IMPL(uint64_t, rjd_binrw_read_uint64)

RJD_BINRW_DEFINE_WRITE_IMPL(int8_t, rjd_binrw_write_int8)
RJD_BINRW_DEFINE_WRITE_IMPL(int16_t, rjd_binrw_write_int16)
RJD_BINRW_DEFINE_WRITE_IMPL(int32_t, rjd_binrw_write_int32)
RJD_BINRW_DEFINE_WRITE_IMPL(int64_t, rjd_binrw_write_int64)
RJD_BINRW_DEFINE_WRITE_IMPL(uint8_t, rjd_binrw_write_uint8)
RJD_BINRW_DEFINE_WRITE_IMPL(uint16_t, rjd_binrw_write_uint16)
RJD_BINRW_DEFINE_WRITE_IMPL(uint32_t, rjd_binrw_write_uint32)
RJD_BINRW_DEFINE_WRITE_IMPL(uint64_t, rjd_binrw_write_uint64)

RJD_BINRW_DEFINE_READWRITE_IMPL(int8_t, int8, rjd_binrw_readwrite_int8)
RJD_BINRW_DEFINE_READWRITE_IMPL(int16_t, int16, rjd_binrw_readwrite_int16)
RJD_BINRW_DEFINE_READWRITE_IMPL(int32_t, int32, rjd_binrw_readwrite_int32)
RJD_BINRW_DEFINE_READWRITE_IMPL(int64_t, int64, rjd_binrw_readwrite_int64)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint8_t, uint8, rjd_binrw_readwrite_uint8)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint16_t, uint16, rjd_binrw_readwrite_uint16)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint32_t, uint32, rjd_binrw_readwrite_uint32)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint64_t, uint64, rjd_binrw_readwrite_uint64)


////////////////////////////////////////////////////////////////////////////////
// rjd_strhash.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_STRHASH_H 1

struct rjd_strhash
{
	struct rjd_hash64 hash;
	struct rjd_strref* debug_string;
};

void rjd_strhash_global_init(struct rjd_mem_allocator* debug_allocator, uint32_t initial_capacity);
void rjd_strhash_global_destroy(void);

struct rjd_strhash rjd_strhash_init(const char* str);
bool rjd_strhash_isequal(struct rjd_strhash a, struct rjd_strhash b);
int rjd_strhash_compare(const struct rjd_strhash* a, const struct rjd_strhash* b);

#define RJD_STRHASH(string) (rjd_strhash_init(string))

#if RJD_IMPL

struct rjd_strpool* g_strhash_strpool;

void rjd_strhash_global_init(struct rjd_mem_allocator* debug_allocator, uint32_t initial_capacity)
{
	if (initial_capacity == 0) {
		initial_capacity = 128;
	}

	g_strhash_strpool = rjd_mem_alloc(struct rjd_strpool, debug_allocator);
	*g_strhash_strpool = rjd_strpool_init(debug_allocator, initial_capacity);
}

void rjd_strhash_global_destroy(void)
{
	rjd_strpool_free(g_strhash_strpool);
	rjd_mem_free(g_strhash_strpool);
	g_strhash_strpool = NULL;
}

struct rjd_strhash rjd_strhash_init(const char* str)
{
    struct rjd_hash64 hash = rjd_hash64_str(str);
    struct rjd_strref* debug_string = NULL;
    if (g_strhash_strpool && hash.value != 0)
    {
        // TODO make threadsafe
        debug_string = rjd_strpool_add(g_strhash_strpool, str);
    }

	struct rjd_strhash strhash = {
		.debug_string = debug_string,
		.hash = hash,
	};
	return strhash;
}

bool rjd_strhash_isequal(struct rjd_strhash a, struct rjd_strhash b)
{
	return a.hash.value == b.hash.value;
}

int rjd_strhash_compare(const struct rjd_strhash* a, const struct rjd_strhash* b)
{
	return a->hash.value < b->hash.value;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_resource_types.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESOURCE_TYPES_H 1

struct rjd_resource_id
{
	struct rjd_strhash hash;
};

struct rjd_resource_type_id
{
	struct rjd_strhash hash;
};

struct rjd_resource_handle
{
	struct rjd_slot slot;
};

static inline struct rjd_resource_id rjd_resource_id_from_str(const char* str);
static inline struct rjd_resource_id rjd_resource_id_none(void);
static inline bool rjd_resource_id_equals(struct rjd_resource_id a, struct rjd_resource_id b);
static inline bool rjd_resource_id_isvalid(struct rjd_resource_id id);

static inline struct rjd_resource_type_id rjd_resource_type_id_from_str(const char* str);
static inline struct rjd_resource_type_id rjd_resource_type_id_none(void);
static inline bool rjd_resource_type_id_equals(struct rjd_resource_type_id a, struct rjd_resource_type_id b);
static inline bool rjd_resource_type_id_isvalid(struct rjd_resource_type_id id);

static inline struct rjd_resource_handle rjd_resource_handle_none(void);
static inline bool rjd_resource_handle_equals(struct rjd_resource_handle a, struct rjd_resource_handle b);
static inline bool rjd_resource_handle_isvalid(struct rjd_resource_handle handle);

////////////////////////////////////////////////////////////////////////////////
// static inline implementation

static inline struct rjd_resource_id rjd_resource_id_from_str(const char* str)
{
	struct rjd_resource_id id = {
		.hash = rjd_strhash_init(str),
	};
	return id;
}

static inline struct rjd_resource_id rjd_resource_id_none(void)
{
	return rjd_resource_id_from_str(NULL);
}

static inline bool rjd_resource_id_equals(struct rjd_resource_id a, struct rjd_resource_id b)
{
	return a.hash.hash.value == b.hash.hash.value;
}

static inline bool rjd_resource_id_isvalid(struct rjd_resource_id id)
{
	return id.hash.hash.value != 0;
}

static inline struct rjd_resource_type_id rjd_resource_type_id_from_str(const char* str)
{
	struct rjd_resource_type_id id = {
		.hash = rjd_strhash_init(str),
	};
	return id;
}

static inline struct rjd_resource_type_id rjd_resource_type_id_none(void)
{
	return rjd_resource_type_id_from_str(NULL);
}

static inline bool rjd_resource_type_id_equals(struct rjd_resource_type_id a, struct rjd_resource_type_id b)
{
	return a.hash.hash.value == b.hash.hash.value;
}

static inline bool rjd_resource_type_id_isvalid(struct rjd_resource_type_id id)
{
	return id.hash.hash.value != 0;
}

static inline struct rjd_resource_handle rjd_resource_handle_none(void)
{
	struct rjd_resource_handle handle;
	handle.slot.index = 0;
	handle.slot.salt = 0;
	return handle;
}

static inline bool rjd_resource_handle_equals(struct rjd_resource_handle a, struct rjd_resource_handle b)
{
	return a.slot.index == b.slot.index &&
			a.slot.salt == b.slot.salt;
}

static inline bool rjd_resource_handle_isvalid(struct rjd_resource_handle handle)
{
	return rjd_slot_isvalid(handle.slot);
}


////////////////////////////////////////////////////////////////////////////////
// rjd_resource_loader.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESOURCE_LOADER_H 1

struct rjd_resource_loader;

typedef void rjd_resource_loader_destroy_func(struct rjd_resource_loader* loader);
typedef struct rjd_result rjd_resource_loader_get_type_func(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out);
typedef struct rjd_result rjd_resource_loader_load_func(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out);

struct rjd_resource_loader
{
	void* impl;
	rjd_resource_loader_destroy_func* destroy_func;
	rjd_resource_loader_get_type_func* get_type_func;
	rjd_resource_loader_load_func* load_func;
};

enum rjd_resource_loader_type
{
	RJD_RESOURCE_LOADER_TYPE_FILESYSTEM, // recursively crawls a root directory to find all resource files
	//RJD_RESOURCE_LOADER_TYPE_REMOTE, // requests manifest from a given http endpoint
	//RJD_RESOURCE_LOADER_TYPE_PACK, // reads manifest embedded inside given pack files
};

struct rjd_resource_extension_to_type_id
{
	struct rjd_resource_type_id type;
	const char* extension;
};

struct rjd_resource_loader_desc
{
	enum rjd_resource_loader_type type;
	struct rjd_mem_allocator* allocator;
	union
	{
		struct {
			const char* root;
			const struct rjd_resource_extension_to_type_id* type_mappings;
			uint32_t type_mappings_count;
			uint32_t manifest_capacity;
		} filesystem;
	};
};

struct rjd_result rjd_resource_loader_create(struct rjd_resource_loader* out, struct rjd_resource_loader_desc desc);
static inline void rjd_resource_loader_destroy(struct rjd_resource_loader* loader);
static inline struct rjd_result rjd_resource_loader_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out);
static inline struct rjd_result rjd_resource_loader_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out);

////////////////////////////////////////////////////////////////////////////////
// Inline implementation

static inline void rjd_resource_loader_destroy(struct rjd_resource_loader* loader)
{
	RJD_ASSERT(loader);
	RJD_ASSERT(loader->destroy_func);

	loader->destroy_func(loader);
}

static inline struct rjd_result rjd_resource_loader_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out)
{
	RJD_ASSERT(loader);
	RJD_ASSERT(loader->get_type_func);

	return loader->get_type_func(loader, id, out);
}

static inline struct rjd_result rjd_resource_loader_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out)
{
	RJD_ASSERT(loader);
	RJD_ASSERT(loader->load_func);

	return loader->load_func(loader, id, allocator, out);
}

#if RJD_IMPL

struct rjd_resource_manifest_entry_filesystem
{
	struct rjd_resource_id id;
	struct rjd_resource_type_id type;
	struct rjd_strref* path;
};

// private types
struct rjd_resource_loader_filesystem
{
	enum rjd_resource_loader_type debug_sentinel;
	struct rjd_strpool strpool;
	struct rjd_resource_extension_to_type_id* type_mappings;
	struct rjd_strref* root;
	struct rjd_resource_manifest_entry_filesystem* manifest_entries; // TODO could be sorted by resource id
};

// static helpers

static struct rjd_resource_loader_filesystem* rjd_resource_loader_to_filesystem_loader(struct rjd_resource_loader* loader);
static void rjd_resource_loader_filesystem_destroy(struct rjd_resource_loader* loader);
static struct rjd_result rjd_resource_loader_filesystem_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out);
static struct rjd_result rjd_resource_loader_filesystem_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out);

// public implementation

struct rjd_result rjd_resource_loader_create(struct rjd_resource_loader* out, struct rjd_resource_loader_desc desc)
{
	void* impl_any = NULL;

	if (desc.type == RJD_RESOURCE_LOADER_TYPE_FILESYSTEM)
	{
		uint32_t manifest_capacity = desc.filesystem.manifest_capacity == 0 ? 1024 : desc.filesystem.manifest_capacity;

		struct rjd_resource_loader_filesystem* impl = rjd_mem_alloc(struct rjd_resource_loader_filesystem, desc.allocator);
		impl->debug_sentinel = RJD_RESOURCE_LOADER_TYPE_FILESYSTEM;
		impl->strpool = rjd_strpool_init(desc.allocator, 64);
		impl->type_mappings = rjd_array_alloc(struct rjd_resource_extension_to_type_id, desc.filesystem.type_mappings_count, desc.allocator);
		impl->root = rjd_strpool_add(&impl->strpool, desc.filesystem.root);
		impl->manifest_entries = rjd_array_alloc(struct rjd_resource_manifest_entry_filesystem, manifest_capacity, desc.allocator);

		for (uint32_t i = 0; i < desc.filesystem.type_mappings_count; ++i)
		{
			rjd_array_push(impl->type_mappings, desc.filesystem.type_mappings[i]);
		}

		struct rjd_path_enumerator_state path_enumerator = rjd_path_enumerate_create(desc.filesystem.root);
		for (const char* path = rjd_path_enumerate_next(&path_enumerator); path != NULL; path = rjd_path_enumerate_next(&path_enumerator))
		{
			const char* extension = rjd_path_extension_str(path);
			if (extension)
			{
				struct rjd_resource_type_id type = {0};
				for (uint32_t i = 0; i < rjd_array_count(impl->type_mappings); ++i)
				{
					if (strcmp(impl->type_mappings[i].extension, extension) == 0) // TODO case-insensitive compare
					{
						type = impl->type_mappings[i].type;
					}
				}

				if (type.hash.hash.value != 0)
				{
					struct rjd_strref* pathref = rjd_strpool_add(&impl->strpool, path);
					struct rjd_resource_manifest_entry_filesystem entry = {
						.id = rjd_strhash_init(path),
						.type = type,
						.path = pathref,
					};
					rjd_array_push(impl->manifest_entries, entry);
				}
			}
		}

		rjd_path_enumerate_destroy(&path_enumerator);

		impl_any = impl;
	}
	else
	{
		return RJD_RESULT("unimplemented support for this type of loader");
	}

	struct rjd_resource_loader loader = {
		.impl = impl_any,
		.destroy_func = rjd_resource_loader_filesystem_destroy,
		.get_type_func = rjd_resource_loader_filesystem_get_type,
		.load_func = rjd_resource_loader_filesystem_load,
	};
	*out = loader;

	return RJD_RESULT_OK();
}

// private implementation

static struct rjd_resource_loader_filesystem* rjd_resource_loader_to_filesystem_loader(struct rjd_resource_loader* loader)
{
	RJD_ASSERT(loader);

	struct rjd_resource_loader_filesystem* impl = (struct rjd_resource_loader_filesystem*)loader->impl;
	RJD_ASSERT(impl->debug_sentinel == RJD_RESOURCE_LOADER_TYPE_FILESYSTEM);
	return impl;
}

static void rjd_resource_loader_filesystem_destroy(struct rjd_resource_loader* loader)
{
	struct rjd_resource_loader_filesystem* impl = rjd_resource_loader_to_filesystem_loader(loader);
	rjd_array_free(impl->manifest_entries);
	rjd_array_free(impl->type_mappings);
	rjd_strpool_free(&impl->strpool);
	rjd_mem_free(impl);
	memset(loader, 0, sizeof(*loader));
}

static struct rjd_result rjd_resource_loader_filesystem_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out)
{
	struct rjd_resource_loader_filesystem* impl = rjd_resource_loader_to_filesystem_loader(loader);
	for (uint32_t i = 0; i < rjd_array_count(impl->manifest_entries); ++i) {
		if (rjd_resource_id_equals(impl->manifest_entries[i].id, id)) {
			*out = impl->manifest_entries[i].type;
			return RJD_RESULT_OK();
		}
	}

	return RJD_RESULT("Resource id not found in loader manifest.");
}

static struct rjd_result rjd_resource_loader_filesystem_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out)
{
	struct rjd_resource_loader_filesystem* impl = rjd_resource_loader_to_filesystem_loader(loader);
	for (uint32_t i = 0; i < rjd_array_count(impl->manifest_entries); ++i) {
		if (rjd_resource_id_equals(impl->manifest_entries[i].id, id)) {
            const char* root = rjd_strref_str(impl->root);
            const char* relative_path = rjd_strref_str(impl->manifest_entries[i].path);
            
            struct rjd_path fullpath = rjd_path_create();
            rjd_path_append(&fullpath, root);
            rjd_path_append(&fullpath, relative_path);

			*out = rjd_istream_from_file(rjd_path_get(&fullpath), allocator, 1024 * 512);
			return out->result;
		}
	}

	return RJD_RESULT("Resource id not found in loader manifest.");
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_resource.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESOURCE_H 1

// TODO update all the RJD_LOGs to a resource channel
struct rjd_result;
struct rjd_resource_type;
struct rjd_resource;
struct rjd_resource_loader;
struct rjd_resource_load_begin_params;
struct rjd_resource_load_end_params;
struct rjd_resource_unload_params;
struct rjd_resource_load_dependency_params;
struct rjd_resource_get_dependency_params;

enum rjd_resource_status
{
	RJD_RESOURCE_STATUS_INVALID,
	RJD_RESOURCE_STATUS_LOAD_BEGIN,
	RJD_RESOURCE_STATUS_LOAD_RESOLVE,
	RJD_RESOURCE_STATUS_LOAD_END,
	RJD_RESOURCE_STATUS_FAILED,
	RJD_RESOURCE_STATUS_READY,
};

struct rjd_resource_dependency
{
    enum rjd_resource_status status;
    void* typed_resource_data;
};

// Loading takes place in 2 passes, where resources get a chance to declare any dependencies they want loaded before
// their load function gets called.
typedef struct rjd_result rjd_resource_load_begin_func(struct rjd_resource_load_begin_params* params);
typedef struct rjd_result rjd_resource_load_end_func(struct rjd_resource_load_end_params* params);
typedef void rjd_resource_unload_func(struct rjd_resource_unload_params* params);
typedef struct rjd_result rjd_resource_add_dependency_func(struct rjd_resource_load_dependency_params* params, struct rjd_resource_id dependency, struct rjd_resource_handle* child);
typedef struct rjd_resource_dependency rjd_resource_get_dependency_func(struct rjd_resource_get_dependency_params* params, struct rjd_resource_handle handle);

struct rjd_resource_load_begin_params
{
	struct rjd_istream stream_data;
	uint32_t filesize;
	void* typed_resource_data;
	void* userdata;
	struct rjd_mem_allocator* allocator;
	struct rjd_mem_allocator* scratch_allocator;

	// for loading dependent resources
	rjd_resource_add_dependency_func* load_dependency_func;
	struct rjd_resource_load_dependency_params* dependency_params;
};

struct rjd_resource_load_end_params
{
	void* typed_resource_data;
	void* userdata;
	struct rjd_mem_allocator* allocator;
	struct rjd_mem_allocator* scratch_allocator;

	struct rjd_resource_get_dependency_params* get_dependency_params;
	rjd_resource_get_dependency_func* get_dependency_func;
};

struct rjd_resource_unload_params
{
	void* typed_resource_data;
	void* userdata;

	struct rjd_resource_get_dependency_params* get_dependency_params;
	rjd_resource_get_dependency_func* get_dependency_func;
};

struct rjd_resource_type
{
	struct rjd_resource_type_id id;
	struct rjd_mem_allocator* optional_allocator;
	void* userdata;
	rjd_resource_load_begin_func* load_begin_func;
	rjd_resource_load_end_func* optional_load_end_func;
	rjd_resource_unload_func* optional_unload_func;
	uint32_t in_memory_size;
};

struct rjd_resource_lib_desc
{
	struct rjd_mem_allocator* allocator;
	struct rjd_resource_loader* loader;

	struct rjd_resource_type* types;
	uint32_t count_types;
	uint32_t initial_capacity_types;
	uint32_t initial_capacity_resources;
	uint32_t initial_capacity_buffers;
};

struct rjd_resource_lib
{
	struct rjd_mem_allocator* allocator;
	struct rjd_resource_loader* loader;
	struct rjd_resource_type* registered_types; // should only be accessed from one thread, TODO enforce
	struct rjd_resource* resources; // TODO make threadsafe

	// TODO make these threadsafe queues
	struct {
		struct rjd_resource_handle* begin;
		struct rjd_resource_handle* resolving_dependencies;
		struct rjd_resource_handle* end;
	} load_stage_queues;

	struct rjd_resource_handle* unload_queue;
};

struct rjd_resource_id rjd_resource_id_from_path(const char* path);

void rjd_resource_lib_create(struct rjd_resource_lib* lib, struct rjd_resource_lib_desc desc);
struct rjd_result rjd_resource_lib_destroy(struct rjd_resource_lib* lib);
struct rjd_result rjd_resource_lib_register_type(struct rjd_resource_lib* lib, struct rjd_resource_type type);
// TODO have the system return fallback handles for resources that failed to load
//struct rjd_result rjd_resource_lib_register_fallback(struct rjd_resource_lib* lib, struct rjd_resource_type type, struct rjd_resource_handle fallback);
void rjd_resource_lib_pump(struct rjd_resource_lib* lib, struct rjd_mem_allocator* scratch_allocator);
void rjd_resource_lib_wait(struct rjd_resource_lib* lib, struct rjd_resource_handle* resources, size_t count);
void rjd_resource_lib_waitall(struct rjd_resource_lib* lib);

struct rjd_result rjd_resource_load(struct rjd_resource_lib* lib, struct rjd_resource_id id, struct rjd_resource_handle* out);
enum rjd_resource_status rjd_resource_lib_status(struct rjd_resource_lib* lib, struct rjd_resource_handle handle);
bool rjd_resource_is_loading(struct rjd_resource_lib* lib, struct rjd_resource_handle handle);
void* rjd_resource_get(struct rjd_resource_lib* lib, struct rjd_resource_handle id);
void rjd_resource_unload(struct rjd_resource_lib* lib, struct rjd_resource_handle handle);

#if RJD_IMPL

// NOTE: We explicitly don't have refcounting in this system. Clients can build their own refcount on top of this if they want.
struct rjd_resource
{
	struct rjd_resource_id id;
	void* typed_resource_data;
	struct rjd_resource_handle* dependencies;
	enum rjd_resource_status status;
	uint32_t refcount; // TODO atomic
	uint32_t registry_index;
};

struct rjd_resource_load_dependency_params
{
	struct rjd_resource_lib* lib;
	struct rjd_resource_handle parent;
};

static struct rjd_result rjd_resource_add_dependency(struct rjd_resource_load_dependency_params* params, struct rjd_resource_id id, struct rjd_resource_handle* child);
static struct rjd_resource_dependency rjd_resource_get_dependency(struct rjd_resource_get_dependency_params* params, struct rjd_resource_handle handle);

void rjd_resource_lib_create(struct rjd_resource_lib* lib, struct rjd_resource_lib_desc desc)
{
	if (desc.initial_capacity_types == 0) {
		desc.initial_capacity_types = 32;
	}

	if (desc.initial_capacity_resources == 0) {
		desc.initial_capacity_resources = 256;
	}

	if (desc.initial_capacity_buffers == 0) {
		desc.initial_capacity_buffers = 64;
	}

	RJD_ASSERTMSG(desc.loader, "You must create a loader with rjd_resource_loader_create() and set it in rjd_resource_lib_desc");

	lib->allocator = desc.allocator;
	lib->loader = desc.loader;
	lib->registered_types = rjd_array_alloc(struct rjd_resource_type, desc.initial_capacity_types, desc.allocator);
	lib->resources = rjd_slotmap_alloc(struct rjd_resource, desc.initial_capacity_resources, desc.allocator);
	lib->load_stage_queues.begin = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
	lib->load_stage_queues.resolving_dependencies = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
	lib->load_stage_queues.end = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
	lib->unload_queue = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
}

struct rjd_result rjd_resource_lib_destroy(struct rjd_resource_lib* lib)
{
	RJD_ASSERT(lib);

	if (rjd_slotmap_count(lib->resources) > 0) {
		return RJD_RESULT("You must unload all resources before destroying the lib");
	}

	rjd_array_free(lib->unload_queue);
	rjd_array_free(lib->load_stage_queues.end);
	rjd_array_free(lib->load_stage_queues.resolving_dependencies);
	rjd_array_free(lib->load_stage_queues.begin);
	rjd_slotmap_free(lib->resources);
	rjd_array_free(lib->registered_types);
	rjd_resource_loader_destroy(lib->loader);

	return RJD_RESULT_OK();
}

struct rjd_result rjd_resource_lib_register_type(struct rjd_resource_lib* lib, struct rjd_resource_type type)
{
	RJD_ASSERT(lib);
	RJD_ASSERT(type.load_begin_func);
	RJD_ASSERT(type.in_memory_size > 0);

	for (uint32_t i = 0; i < rjd_array_count(lib->registered_types); ++i)
	{
		if (rjd_strhash_isequal(lib->registered_types[i].id.hash, type.id.hash))
		{
			return RJD_RESULT("Resource type has already been registered.");
		}
	}

	rjd_array_push(lib->registered_types, type);

	return RJD_RESULT_OK();
}

void rjd_resource_lib_pump(struct rjd_resource_lib* lib, struct rjd_mem_allocator* scratch_allocator)
{
	RJD_ASSERT(lib);

	if (!rjd_array_empty(lib->load_stage_queues.end)) {
		struct rjd_resource_handle handle = rjd_array_pop(lib->load_stage_queues.end);
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
		RJD_ASSERT(resource);
		RJD_ASSERT(resource->status == RJD_RESOURCE_STATUS_LOAD_END);
	
		struct rjd_result result = RJD_RESULT_OK();
		const struct rjd_resource_type* type = lib->registered_types + resource->registry_index;
		if (type->optional_load_end_func) {
			struct rjd_resource_load_end_params params = {
				.typed_resource_data = resource->typed_resource_data,
				.userdata = type->userdata,
				.allocator = lib->allocator,
				.scratch_allocator = scratch_allocator,
				.get_dependency_params = (struct rjd_resource_get_dependency_params*)lib,
				.get_dependency_func = rjd_resource_get_dependency,
			};
			result = type->optional_load_end_func(&params);
		}
	
		if (rjd_result_isok(result)) {
			resource->status = RJD_RESOURCE_STATUS_READY;
			//RJD_LOG("Loaded resource '%s'", resource->filepath);
		} else {
			resource->status = RJD_RESOURCE_STATUS_FAILED;
			//RJD_LOG("Failed ending load for resource '%s'", resource->filepath);
		}
	}

	if (!rjd_array_empty(lib->load_stage_queues.resolving_dependencies)) {
		struct rjd_resource_handle handle = rjd_array_last(lib->load_stage_queues.resolving_dependencies);
		struct rjd_resource* res = rjd_slotmap_get(lib->resources, handle.slot);
		RJD_ASSERT(res);

		bool all_loaded = true;
		for (uint32_t i = 0; i < rjd_array_count(res->dependencies); ++i)
		{
			struct rjd_resource_handle handle = res->dependencies[i];
			struct rjd_resource* dependency = rjd_slotmap_get(lib->resources, handle.slot);
			RJD_ASSERT(dependency);
            // failures to load dependencies don't automatically fail resources; we leave it up to
            // the resource to decide what to do in the end stage
            // TODO use the "backup resource" as a replacement?
			if (dependency->status != RJD_RESOURCE_STATUS_READY && dependency->status != RJD_RESOURCE_STATUS_FAILED) {
				all_loaded = false;
				break;
			}
		}

		if (all_loaded) {
			struct rjd_resource_handle handle = rjd_array_pop(lib->load_stage_queues.resolving_dependencies);
            res->status = RJD_RESOURCE_STATUS_LOAD_END;
			rjd_array_push(lib->load_stage_queues.end, handle);
		}
	}

	if (!rjd_array_empty(lib->load_stage_queues.begin)) {
		struct rjd_resource_handle handle = rjd_array_pop(lib->load_stage_queues.begin);
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
		RJD_ASSERT(resource);
		RJD_ASSERT(resource->status == RJD_RESOURCE_STATUS_LOAD_BEGIN);
	
		struct rjd_istream stream = {0};
		struct rjd_result result = rjd_resource_loader_load(lib->loader, resource->id, scratch_allocator, &stream);
		if (rjd_result_isok(result))
		{
	        struct rjd_resource_type* type = rjd_array_get(lib->registered_types, resource->registry_index);
	        struct rjd_mem_allocator* resource_allocator = type->optional_allocator ? type->optional_allocator : lib->allocator;
	        
	        resource->typed_resource_data = rjd_mem_alloc_array(uint8_t, type->in_memory_size, resource_allocator);
	        memset(resource->typed_resource_data, 0, type->in_memory_size);
	        
	        struct rjd_result result = RJD_RESULT_OK();
			if (type->load_begin_func)
			{
				struct rjd_resource_load_dependency_params dependency_params = {
					.lib = lib,
					.parent = handle,
				};
	
				struct rjd_resource_load_begin_params load_params = {
					.stream_data = stream,
					.typed_resource_data = resource->typed_resource_data,
					.userdata = type->userdata,
					.allocator = resource_allocator,
					.scratch_allocator = scratch_allocator,
					.load_dependency_func = &rjd_resource_add_dependency,
					.dependency_params = &dependency_params,
				};
	
				result = type->load_begin_func(&load_params);
			}
	
	        if (rjd_result_isok(result)) {
	            resource->status = RJD_RESOURCE_STATUS_LOAD_RESOLVE;
	            rjd_array_push(lib->load_stage_queues.resolving_dependencies, handle);
	        } else {
	            //RJD_LOG("Failed beginning load for resource '%s': %s", resource->filepath, result.error);
	            resource->status = RJD_RESOURCE_STATUS_FAILED;
	        }
	
			rjd_istream_close(&stream);
		}
		else
		{
			//RJD_LOG("Failed loading resource '%s': %s", resource_id.hash.debug_string, result.error);
			resource->status = RJD_RESOURCE_STATUS_FAILED;
		}
	}

	if (!rjd_array_empty(lib->unload_queue)) {
		struct rjd_resource_handle handle = rjd_array_pop(lib->unload_queue);
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);

		// The resource could have been already freed if it was inserted into the unload queue more than once
		if (resource)
		{
			struct rjd_resource_type* type = rjd_array_get(lib->registered_types, resource->registry_index);
			if (type->optional_unload_func) {
				struct rjd_resource_unload_params params = {
					.typed_resource_data = resource->typed_resource_data,
					.userdata = type->userdata,
					.get_dependency_params = (struct rjd_resource_get_dependency_params*)lib,
					.get_dependency_func = rjd_resource_get_dependency,
				};
				type->optional_unload_func(&params);
			}
            rjd_mem_free(resource->typed_resource_data);
            rjd_array_free(resource->dependencies);
			rjd_slotmap_erase(lib->resources, handle.slot);
		}
	}

	// TODO get change notifications from loader to insert resources for reload
	// NOTE make sure to preserve the original resource until the reload is complete!
}

void rjd_resource_lib_wait(struct rjd_resource_lib* lib, struct rjd_resource_handle* resources, size_t count)
{
	const size_t K_SCRATCH_SIZE = RJD_MB * 4;
	void* scratch_buffer = rjd_mem_alloc_array_noclear(char, K_SCRATCH_SIZE, lib->allocator);
	struct rjd_mem_allocator scratch_allocator = rjd_mem_allocator_init_linear(scratch_buffer, K_SCRATCH_SIZE);

	for (uint32_t i = 0; i < count; ++i)
	{
		while (rjd_resource_is_loading(lib, resources[i])) {
			rjd_resource_lib_pump(lib, &scratch_allocator);
			rjd_mem_allocator_reset(&scratch_allocator);
		}
	}

	rjd_mem_free(scratch_buffer);
}

void rjd_resource_lib_waitall(struct rjd_resource_lib* lib)
{
	RJD_ASSERT(lib);

	const size_t K_SCRATCH_SIZE = RJD_MB * 4;
	void* scratch_buffer = rjd_mem_alloc_array_noclear(char, K_SCRATCH_SIZE, lib->allocator);
	struct rjd_mem_allocator scratch_allocator = rjd_mem_allocator_init_linear(scratch_buffer, K_SCRATCH_SIZE);

	while (!rjd_array_empty(lib->load_stage_queues.begin) ||
			!rjd_array_empty(lib->load_stage_queues.resolving_dependencies) ||
			!rjd_array_empty(lib->load_stage_queues.end) ||
            !rjd_array_empty(lib->unload_queue))
	{
		rjd_resource_lib_pump(lib, &scratch_allocator);
		rjd_mem_allocator_reset(&scratch_allocator);
	}

	rjd_mem_free(scratch_buffer);
}

struct rjd_result rjd_resource_load(struct rjd_resource_lib* lib, struct rjd_resource_id id, struct rjd_resource_handle* out)
{
	RJD_ASSERT(lib);
	RJD_ASSERT(out);

	// exists already
	for (struct rjd_slot s = rjd_slotmap_next(lib->resources, NULL); rjd_slot_isvalid(s); s = rjd_slotmap_next(lib->resources, &s))
	{
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, s);
		if (rjd_resource_id_equals(resource->id, id)) {
			++resource->refcount;
			out->slot = s;
			return RJD_RESULT_OK();
		}
	}

	// cancel unload
	for (uint32_t i = 0; i < rjd_array_count(lib->unload_queue); ++i)
	{
		struct rjd_resource_handle handle = lib->unload_queue[i];
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
		if (rjd_resource_id_equals(resource->id, id)) {
			rjd_array_erase_unordered(lib->resources, i);
			++resource->refcount;
			*out = handle;
			return RJD_RESULT_OK();
		}
	}

	// kickoff the load
	struct rjd_resource_type_id type = {0};
	struct rjd_result result = rjd_resource_loader_get_type(lib->loader, id, &type);
	if (rjd_result_isok(result))
	{
		int32_t registry_index = RJD_ARRAY_NOT_FOUND;
		for (uint32_t i = 0; i < rjd_array_count(lib->registered_types); ++i) {
			if (rjd_resource_type_id_equals(lib->registered_types[i].id, type)) {
				registry_index = (int32_t)i;
				break;
			}
		}

		if (registry_index == RJD_ARRAY_NOT_FOUND) {
			return RJD_RESULT("No resource type was found for the given type id. Did you forget to register it?");
		} else {
			struct rjd_resource resource = {
				.id = id,
				.status = RJD_RESOURCE_STATUS_LOAD_BEGIN,
				.registry_index = registry_index,
				.dependencies = NULL,
				.typed_resource_data = NULL,
				.refcount = 1,
			};

			rjd_slotmap_insert(lib->resources, resource, &out->slot);

			rjd_array_push(lib->load_stage_queues.begin, *out);

			result = RJD_RESULT_OK();
		}
	}

	return result;
}

enum rjd_resource_status rjd_resource_lib_status(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	RJD_ASSERT(lib);

    if (rjd_slot_isvalid(handle.slot))
    {
        if (rjd_slotmap_contains(lib->resources, handle.slot)) {
            struct rjd_resource* res = rjd_slotmap_get(lib->resources, handle.slot);
            if (res) {
                return res->status;
            }
        }
    }
	return RJD_RESOURCE_STATUS_INVALID;
}

bool rjd_resource_is_loading(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	enum rjd_resource_status status = rjd_resource_lib_status(lib, handle);
	return status == RJD_RESOURCE_STATUS_LOAD_BEGIN ||
			status == RJD_RESOURCE_STATUS_LOAD_RESOLVE ||
			status == RJD_RESOURCE_STATUS_LOAD_END;
}

void* rjd_resource_get(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	RJD_ASSERT(lib);

	struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
	if (resource && resource->status == RJD_RESOURCE_STATUS_READY) {
		return resource->typed_resource_data;
	}
	return NULL;
}

void rjd_resource_unload(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	RJD_ASSERT(lib);

	struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
	if (resource) {
		--resource->refcount;
		if (resource->refcount == 0) {
			rjd_array_push(lib->unload_queue, handle);
			for (uint32_t i = 0; i < rjd_array_count(resource->dependencies); ++i) {
				rjd_resource_unload(lib, resource->dependencies[i]);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// private implementation

static struct rjd_result rjd_resource_add_dependency(struct rjd_resource_load_dependency_params* params, struct rjd_resource_id id, struct rjd_resource_handle* child)
{
	RJD_ASSERT(params);

	struct rjd_resource* parent = rjd_slotmap_get(params->lib->resources, params->parent.slot);
	RJD_ASSERT(parent);

	struct rjd_result result = rjd_resource_load(params->lib, id, child);
	if (rjd_result_isok(result)) {
        if (parent->dependencies == NULL) {
            parent->dependencies = rjd_array_alloc(struct rjd_resource_handle, 8, params->lib->allocator);
        }
		rjd_array_push(parent->dependencies, *child);
	}

	return result;
}

static struct rjd_resource_dependency rjd_resource_get_dependency(struct rjd_resource_get_dependency_params* params, struct rjd_resource_handle handle)
{
	struct rjd_resource_lib* lib = (struct rjd_resource_lib*)params;
    enum rjd_resource_status status = rjd_resource_lib_status(lib, handle);
	void* typed_resource_data = rjd_resource_get(lib, handle);
    
    struct rjd_resource_dependency dependency = {
        .status = status,
        .typed_resource_data = typed_resource_data,
    };
    return dependency;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_gfx.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <stdint.h>

#define RJD_GFX_H 1

// interface dependencies:
// * rjd_result

// impl dependencies:
// * rjd_mem
// * rjd_math

// Supported RJG_GFX_BACKEND_* values:
// RJD_GFX_BACKEND_METAL (osx only)

#ifndef RJD_GFX_BACKEND_METAL
	#define RJD_GFX_BACKEND_METAL 0
#endif

#if !RJD_GFX_BACKEND_METAL
	#error	"You must #define one of the RJD_GFX_BACKEND_* macros to 1 before including this file. "
			"See the above comment for a list of supported values."
#endif

#if RJD_GFX_BACKEND_METAL
	#if RJD_PLATFORM_OSX
	    // Workaround .c files not being able to read objective-c forward declarations
	    #if RJD_LANG_OBJC
	        @class MTKView;
	        RJD_STATIC_ASSERT(sizeof(void*) == sizeof(MTKView*));
	    #else
	        typedef void MTKView;
	    #endif
	#else
		#error "Metal is only supported on OSX"
	#endif
#endif

struct rjd_mem_allocator;

struct rjd_gfx_viewport // TODO figure out if this should have a start x,y pair
{
	uint32_t width;
	uint32_t height;
};

////////////////////////////////////////////////////////////////////////////////
// render data

enum rjd_gfx_camera_mode
{
	RJD_GFX_CAMERA_MODE_ORTHOGRAPHIC,
	//RJD_GFX_CAMERA_MODE_PERSPECTIVE, // TODO
	RJD_GFX_CAMERA_MODE_COUNT,
};

struct rjd_gfx_camera
{
	enum rjd_gfx_camera_mode mode;
	rjd_math_float3 pos;
};

struct rjd_gfx_quad_uv
{
	union
	{
		struct
		{
			struct {
				rjd_math_float2 righttop;
				rjd_math_float2 lefttop;
				rjd_math_float2 leftbot;
			} tri1;

			struct {
				rjd_math_float2 leftbot;
				rjd_math_float2 rightbot;
				rjd_math_float2 righttop;
			} tri2;
		};
		rjd_math_float2 v[6];
	};
};

////////////////////////////////////////////////////////////////////////////////
// render configuration

enum rjd_gfx_stencilmode
{
	RJD_GFX_STENCILMODE_DISABLED,
	RJD_GFX_STENCILMODE_TEST,
	RJD_GFX_STENCILMODE_WRITE,
	RJD_GFX_STENCILMODE_COUNT,
};

//struct rjd_gfx_render_config
//{
//	struct rjd_gfx_viewport window_size; // TODO upgrade this into a render view (render target w/ size & offset)?
//	enum rjd_gfx_stencilmode stencil_mode;
//	int use_buffer_color: 1;
//	int use_buffer_depth: 1;
//};
//
//struct rjd_gfx_render_geo2d
//{
//	struct rjd_math_float16* transforms;
//	union rjd_gfx_quad_uv* uvs;
//	rjd_math_float4* tints;
//	uint32_t count;
//};

////////////////////////////////////////////////////////////////////////////////
// resources

enum rjd_gfx_format
{
	RJD_GFX_FORMAT_COLOR_U8_RGBA,
	RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM,
	RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB,
    RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32,
	RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8,
	RJD_GFX_FORMAT_COUNT,
};

// all values correspond to the entry in the enum rjd_gfx_format
struct rjd_gfx_format_value
{
	enum rjd_gfx_format type;
	union
	{
		uint8_t color_u8_rgba[4];
		union { 
			uint32_t value; 
			struct { 
				uint32_t depth:24; 
				uint32_t stencil:8; 
			} parts; 
		} depthstencil_u32_d24_s8;
        float depthstencil_f32_d32;
	};
};

enum rjd_gfx_texture_access
{
	RJD_GFX_TEXTURE_ACCESS_CPU_NONE_GPU_READWRITE,
	RJD_GFX_TEXTURE_ACCESS_CPU_WRITE_GPU_READWRITE,
	RJD_GFX_TEXTURE_ACCESS_COUNT,
};

enum rjd_gfx_texture_usage
{
	RJD_GFX_TEXTURE_USAGE_DEFAULT,
	RJD_GFX_TEXTURE_USAGE_RENDERTARGET,
    RJD_GFX_TEXTURE_USAGE_COUNT,
};

struct rjd_gfx_texture_desc
{
	void* data;
    uint32_t data_length;
	uint32_t pixels_width;
	uint32_t pixels_height;
	enum rjd_gfx_format format;
	enum rjd_gfx_texture_access access;
	enum rjd_gfx_texture_usage usage;
	const char* debug_label;
};

struct rjd_gfx_texture
{
	struct rjd_slot handle;
};

//enum rjd_gfx_shader_input_buffer_type_flags
//{
//	RJD_GFX_SHADER_INPUT_USAGE_VERTEX = 0x1,
//	RJD_GFX_SHADER_INPUT_USAGE_FRAGMENT = 0x2,
//};

// TODO determine if this is a good idea or not
//struct rjd_gfx_shader_input_slot
//{
//	const char* name;
//	uint32_t index;
//	enum rjd_gfx_shader_input_buffer_type_flags type_flags;
//};

// TODO provide a precompiled path as well, e.g. bool is_compiled
struct rjd_gfx_shader_desc
{
	const void* data;
	//struct rjd_gfx_shader_input_slot* slots;

	uint32_t count_data;
	//uint32_t count_slots;
};

struct rjd_gfx_shader
{
	struct rjd_slot handle;
};

enum rjd_gfx_vertex_format_type
{
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT1,
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT2,
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT3,
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT4,
	RJD_GFX_VERTEX_FORMAT_TYPE_COUNT,
};

enum rjd_gfx_vertex_format_step
{
	RJD_GFX_VERTEX_FORMAT_STEP_VERTEX,
	RJD_GFX_VERTEX_FORMAT_STEP_INSTANCE,
	RJD_GFX_VERTEX_FORMAT_STEP_CONSTANT,
};

struct rjd_gfx_vertex_format_attribute
{
	enum rjd_gfx_vertex_format_type type;
	enum rjd_gfx_vertex_format_step step;
	uint32_t attribute_index;
	uint32_t buffer_index;
	uint32_t stride;
    uint32_t step_rate;
	uint32_t offset;
};

enum rjd_gfx_depth_compare
{
	RJD_GFX_DEPTH_COMPARE_DISABLED,
	RJD_GFX_DEPTH_COMPARE_ALWAYS_FAIL,
	RJD_GFX_DEPTH_COMPARE_ALWAYS_SUCCEED,
	RJD_GFX_DEPTH_COMPARE_LESS,
	RJD_GFX_DEPTH_COMPARE_LESSEQUAL,
	RJD_GFX_DEPTH_COMPARE_GREATER,
	RJD_GFX_DEPTH_COMPARE_GREATEREQUAL,
	RJD_GFX_DEPTH_COMPARE_EQUAL,
	RJD_GFX_DEPTH_COMPARE_NOTEQUAL,
};

struct rjd_gfx_pipeline_state_desc
{
	const char* debug_name;
	struct rjd_gfx_shader shader;
	struct rjd_gfx_texture render_target; // specify RJD_GFX_TEXTURE_BACKBUFFER to use the backbuffer
	struct rjd_gfx_texture depthstencil_target; // specify RJD_GFX_TEXTURE_BACKBUFFER to use the backbuffer
	struct rjd_gfx_vertex_format_attribute* vertex_attributes;
	uint32_t count_vertex_attributes;
	enum rjd_gfx_depth_compare depth_compare;
	// TODO stencil config
};

struct rjd_gfx_pipeline_state
{
	struct rjd_slot handle;
};

enum rjd_gfx_primitive_type
{
	RJD_GFX_PRIMITIVE_TYPE_TRIANGLES,
};

enum rjd_gfx_index_type
{
	RJD_GFX_INDEX_TYPE_UINT32,
	RJD_GFX_INDEX_TYPE_UINT16,
};

enum rjd_gfx_mesh_buffer_type
{
	RJD_GFX_MESH_BUFFER_TYPE_UNIFORMS,
	RJD_GFX_MESH_BUFFER_TYPE_VERTEX,
};

enum rjd_gfx_mesh_buffer_usage_flags
{
	RJD_GFX_MESH_BUFFER_USAGE_VERTEX = 0x1,
	RJD_GFX_MESH_BUFFER_USAGE_FRAGMENT = 0x2,
};

union rjd_gfx_mesh_buffer_common_desc
{
	struct {
		uint32_t capacity;
	} uniforms;

	struct {
		const void* data;
		uint32_t length;
	} vertex;
};

// TODO vertex_buffer isn't a great name, since it can also be inputs to fragment shaders. Maybe just mesh_shader_buffer?
struct rjd_gfx_mesh_vertex_buffer_desc
{
	enum rjd_gfx_mesh_buffer_type type;
	union rjd_gfx_mesh_buffer_common_desc common;
	enum rjd_gfx_mesh_buffer_usage_flags usage_flags;
	uint32_t buffer_index; // TODO maybe this should be name and index? buffer_slot? shader_input_slot?
};

//struct rjd_gfx_mesh_index_buffer_desc
//{
//	union rjd_gfx_mesh_buffer_desc buffer_desc;
//	enum rjd_gfx_index_type type;
//};
// TODO implement the other 2 descs later
struct rjd_gfx_mesh_vertexed_desc
{
	enum rjd_gfx_primitive_type primitive;
	struct rjd_gfx_mesh_vertex_buffer_desc* buffers;
	uint32_t count_buffers;
	uint32_t count_vertices;
};

//struct rjd_gfx_mesh_indexed_desc
//{
//	enum rjd_gfx_mesh_type type;
//	enum rjd_gfx_primitive_type primitive;
//	struct rjd_gfx_mesh_vertex_buffer_desc* buffers;
//	union rjd_gfx_mesh_index_buffer_desc* buffers;
//	uint32_t count_vertex_buffers;
//	uint32_t count_index_buffers;
//};

//struct rjd_gfx_mesh_instanced_desc
//{
//	enum rjd_gfx_mesh_type type;
//	enum rjd_gfx_primitive_type primitive;
//	struct rjd_gfx_mesh_vertex_buffer_desc* buffers;
//	uint32_t count_vertex_buffers;
//	uint32_t instance_count;
//};

struct rjd_gfx_mesh
{
	struct rjd_slot handle;
};

////////////////////////////////////////////////////////////////////////////////
// render commands

enum rjd_gfx_winding_order
{
	RJD_GFX_WINDING_ORDER_CLOCKWISE,
	RJD_GFX_WINDING_ORDER_COUNTERCLOCKWISE,
};

enum rjd_gfx_cull
{
	RJD_GFX_CULL_NONE,
	RJD_GFX_CULL_BACK,
	RJD_GFX_CULL_FRONT,
};

struct rjd_gfx_pass_begin_desc
{
	struct rjd_gfx_texture render_target; // specify RJD_GFX_TEXTURE_BACKBUFFER to use the backbuffer
	struct rjd_gfx_format_value clear_color;
	struct rjd_gfx_format_value clear_depthstencil;
	const char* debug_label;
};

struct rjd_gfx_pass_draw_desc
{
	const struct rjd_gfx_viewport* viewport;
	const struct rjd_gfx_pipeline_state* pipeline_state;
	const struct rjd_gfx_mesh* meshes;
	const struct rjd_gfx_texture* textures;
	const uint32_t* texture_indices; // parallel array with textures
	uint32_t count_meshes;
	uint32_t count_textures;
	enum rjd_gfx_cull cull_mode;
	enum rjd_gfx_winding_order winding_order;

	const char* debug_label;
};

struct rjd_gfx_command_buffer
{
	struct rjd_slot handle;
};

////////////////////////////////////////////////////////////////////////////////
// gfx context

struct rjd_gfx_context_desc
{
	enum rjd_gfx_format backbuffer_color_format;
	enum rjd_gfx_format backbuffer_depth_format;
	struct rjd_mem_allocator* allocator;
	uint32_t msaa_samples;

	// TODO forward declare HWND somehow
	#if RJD_PLATFORM_WINDOWS
		struct {
			HWND window_handle;
		} win32;
	#elif RJD_PLATFORM_OSX
		struct {
			MTKView* view;
		} osx;
	#endif
};

struct rjd_gfx_context
{
	char pimpl[128];
};

////////////////////////////////////////////////////////////////////////////////
// interface

// backend
static inline int32_t rjd_gfx_backend_ismetal(void);

// camera
struct rjd_gfx_camera rjd_gfx_camera_init(enum rjd_gfx_camera_mode mode);
rjd_math_mat4 rjd_gfx_camera_lookat_ortho_righthanded(const struct rjd_gfx_camera* camera);
//rjd_math_mat4 rjd_gfx_camera_lookat_ortho_lefthanded(const struct rjd_gfx_camera* camera); // TODO

// context
// NOTE: all functions that deal with a context are not threadsafe for simplicity. If you are making a multithreaded
// renderer, you must have a strategy for synchronizing resource creation and drawing with the context.
struct rjd_result rjd_gfx_context_create(struct rjd_gfx_context* out, struct rjd_gfx_context_desc desc);
void rjd_gfx_context_destroy(struct rjd_gfx_context* context);

bool rjd_gfx_msaa_is_count_supported(const struct rjd_gfx_context* context, uint32_t count); // count is usually: 1,2,4, or 8
void rjd_gfx_msaa_set_count(struct rjd_gfx_context* context, uint32_t count);
bool rjd_gfx_vsync_try_enable(struct rjd_gfx_context* context);
struct rjd_result rjd_gfx_wait_for_frame_begin(struct rjd_gfx_context* context);
struct rjd_result rjd_gfx_present(struct rjd_gfx_context* context);

// commands
struct rjd_result rjd_gfx_command_buffer_create(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* out);
struct rjd_result rjd_gfx_command_pass_begin(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_begin_desc* command);
struct rjd_result rjd_gfx_command_pass_draw(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_draw_desc* command);
struct rjd_result rjd_gfx_command_buffer_commit(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer);

// resources
struct rjd_result rjd_gfx_texture_create(struct rjd_gfx_context* context, struct rjd_gfx_texture* out, struct rjd_gfx_texture_desc desc);
void rjd_gfx_texture_destroy(struct rjd_gfx_context* context, struct rjd_gfx_texture* texture);
struct rjd_result rjd_gfx_shader_create(struct rjd_gfx_context* context, struct rjd_gfx_shader* out, struct rjd_gfx_shader_desc desc);
void rjd_gfx_shader_destroy(struct rjd_gfx_context* context, struct rjd_gfx_shader* shader);
struct rjd_result rjd_gfx_pipeline_state_create(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* out, struct rjd_gfx_pipeline_state_desc desc);
void rjd_gfx_pipeline_state_destroy(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* pipeline_state);
struct rjd_result rjd_gfx_mesh_create_vertexed(struct rjd_gfx_context* context, struct rjd_gfx_mesh* out, struct rjd_gfx_mesh_vertexed_desc desc, struct rjd_mem_allocator* allocator);
//struct rjd_result rjd_gfx_mesh_create_indexed(struct rjd_gfx_context* context, struct rjd_gfx_mesh* out, struct rjd_gfx_mesh_indexed_desc desc);
struct rjd_result rjd_gfx_mesh_modify(struct rjd_gfx_context* context, struct rjd_gfx_mesh* mesh, uint32_t buffer_index, uint32_t offset, void* data, uint32_t length);
void rjd_gfx_mesh_destroy(struct rjd_gfx_context* context, struct rjd_gfx_mesh* mesh);

// format
struct rjd_gfx_format_value rjd_gfx_format_value_from_u32(enum rjd_gfx_format, uint32_t value);
uint32_t rjd_gfx_format_bytesize(enum rjd_gfx_format format);
bool rjd_gfx_format_iscolor(enum rjd_gfx_format format);
bool rjd_gfx_format_isdepthstencil(enum rjd_gfx_format format);
bool rjd_gfx_format_isdepth(enum rjd_gfx_format format);
bool rjd_gfx_format_isstencil(enum rjd_gfx_format format);

static inline struct rjd_gfx_format_value rjd_gfx_format_make_color_u8_rgba(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha);
static inline struct rjd_gfx_format_value rjd_gfx_format_make_depthstencil_f32_d32(float depth);

// constants
const extern struct rjd_gfx_texture RJD_GFX_TEXTURE_BACKBUFFER;

////////////////////////////////////////////////////////////////////////////////
// inline implementations

static inline int32_t rjd_gfx_backend_ismetal(void)
{
	return RJD_GFX_BACKEND_METAL;
}

static inline struct rjd_gfx_format_value rjd_gfx_format_make_color_u8_rgba(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha)
{
	struct rjd_gfx_format_value value;
	value.type = RJD_GFX_FORMAT_COLOR_U8_RGBA;
	value.color_u8_rgba[0] = red;
	value.color_u8_rgba[1] = green;
	value.color_u8_rgba[2] = blue;
	value.color_u8_rgba[3] = alpha;
    return value;
}

static inline struct rjd_gfx_format_value rjd_gfx_format_make_depthstencil_f32_d32(float depth)
{
	struct rjd_gfx_format_value value = {
		.type = RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32,
		.depthstencil_f32_d32 = depth,
	};
	return value;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#if RJD_IMPL

const static struct rjd_logchannel logchannel_default = {
	.enabled = true,
	.name = "rjd_gfx default",
};

const static struct rjd_logchannel logchannel_error = {
	.enabled = true,
	.name = "rjd_gfx error",
};

#define RJD_GFX_LOG(...) RJD_LOG_CHANNEL(&logchannel_default, RJD_LOG_VERBOSITY_LOW, __VA_ARGS__)
#define RJD_GFX_LOG_ERROR(...) RJD_LOG_CHANNEL(&logchannel_error, RJD_LOG_VERBOSITY_LOW, __VA_ARGS__)

////////////////////////////////////////////////////////////////////////////////
// platform-independent camera

struct rjd_gfx_camera rjd_gfx_camera_init(enum rjd_gfx_camera_mode mode)
{
	struct rjd_gfx_camera cam = { .pos = rjd_math_float3_xyz(0,0,0), .mode = mode };
	return cam;
}

rjd_math_mat4 rjd_gfx_camera_lookat_ortho_righthanded(const struct rjd_gfx_camera* camera)
{
	RJD_ASSERT(camera);

	float x = floorf(camera->pos.x);
	float y = floorf(camera->pos.y);
	float z = floorf(camera->pos.z);

	rjd_math_vec3 pos = rjd_math_vec3_xyz(x,y,z);

	const rjd_math_vec3 look = rjd_math_vec3_xyz(x,y,z - 1.0f);
	const rjd_math_vec3 up = rjd_math_vec3_xyz(0.0f, 1.0f, 0.0f);
	return rjd_math_mat4_lookat_righthanded(pos, look, up);
}

////////////////////////////////////////////////////////////////////////////////
// platform-independent format

uint32_t rjd_gfx_format_bytesize(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return sizeof(char[4]);
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return sizeof(char[4]);
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return sizeof(char[4]);
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return sizeof(float);
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return sizeof(uint32_t);
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return 0;
}

bool rjd_gfx_format_iscolor(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return true;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return true;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return true;
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return false;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return false;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return false;
}

bool rjd_gfx_format_isdepthstencil(enum rjd_gfx_format format)
{
	bool is_depth = rjd_gfx_format_isdepth(format);
	bool is_stencil = rjd_gfx_format_isstencil(format);
	return is_depth || is_stencil;
}

bool rjd_gfx_format_isdepth(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return false;
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return true;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return true;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return false;

}

bool rjd_gfx_format_isstencil(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return false;
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return false;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return true;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return false;
}

////////////////////////////////////////////////////////////////////////////////
// gfx implementation is in API-specific headers
// TODO merge these headers into this file

#if RJD_GFX_BACKEND_METAL
	#if RJD_PLATFORM_OSX
		#include "rjd_gfx_metal.h"
	#else
		#error "Metal backend is only supported on OSX."
	#endif
#else
	#error "Unknown RJD_GFX_BACKEND. Ensure you are #defining to a known rjd_gfx_backend value.
#endif

#endif // RJD_IMPL

