#pragma once

////////////////////////////////////////////////////////////////////////////////
// autogenerated rjd.h
////////////////////////////////////////////////////////////////////////////////

#if RJD_IMPL
	#include <stdint.h>
	#include <stddef.h>
	#include <stdlib.h>
	#include <stdbool.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <string.h>
#endif // RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// rjd_platform.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PLATFORM 1

// Platforms
#ifdef _WIN32
	#define RJD_PLATFORM_WINDOWS 1
#endif

#if __APPLE__ && __MACH__
	#define RJD_PLATFORM_OSX 1
#endif

// Compilers
#ifdef _MSC_VER
	#define RJD_COMPILER_MSVC 1
#elif __clang__
	#define RJD_COMPILER_CLANG 1
#elif __GNUC__
	#define RJD_COMPILER_GCC 1
#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_debug.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_DEBUG 1

// DEPENDENCIES:
// stdio.h
// stdbool.h
// stdarg.h
// stdint.h

enum rjd_log_verbosity
{
	RJD_LOG_VERBOSITY_LOW,
	RJD_LOG_VERBOSITY_MED,
	RJD_LOG_VERBOSITY_HIGH,
};

struct rjd_logchannel
{
	enum rjd_log_verbosity verbosity;
	bool enabled;
	const char* name;
	void (*hook)(const char* formatted, size_t length);
};

#if RJD_ENABLE_LOGGING
	#define RJD_LOG_CHANNEL(channel, verbosity, ...) rjd_log_impl(__FILE__, __LINE__, channel, verbosity, __VA_ARGS__)
	#define RJD_LOG(...) RJD_LOG_CHANNEL(g_rjd_global_logchannel, RJD_LOG_VERBOSITY_MED, __VA_ARGS__)
#else
	#define RJD_LOG_CHANNEL(channel, ...)
	#define RJD_LOG(...)
#endif

#define RJD_NAMEGEN2(a, b) a##b
#define RJD_NAMEGEN(a, b) RJD_NAMEGEN2(a, b)
#define RJD_STATIC_ASSERT(condition) typedef char RJD_NAMEGEN(rjd_staticassert_failure_, __COUNTER__)[(condition) ? 1 : -1]

#if RJD_ENABLE_ASSERT
	#define RJD_FORCECRASH() ((*(volatile int*)0) = 0xDEADDEAD)
	#define RJD_ASSERT(condition) RJD_ASSERTMSG(condition, #condition)
	#define RJD_ASSERTMSG(condition, ...) if (!(condition)) { RJD_LOG(__VA_ARGS__); RJD_FORCECRASH(); }
	#define RJD_ASSERTFAIL(...) { RJD_LOG(__VA_ARGS__); RJD_FORCECRASH(); }
#else
	#define RJD_FORCECRASH() ((*(int*)0) = 0xDEADDEAD)
	#define RJD_ASSERT(condition, ...) 
	#define RJD_ASSERTMSG(condition, ...) 
	#define RJD_ASSERTFAIL(...)
#endif

#define RJD_UNUSED_PARAM(param) ((void)param)

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...);
void rjd_log_resetglobal(void);

#if RJD_ENABLE_SHORTNAMES
	#define STATIC_ASSERT RJD_STATIC_ASSERT
	#define ASSERT RJD_ASSERT
	#define ASSERTMSG RJD_ASSERTMSG
	#define ASSERTFAIL RJD_ASSERTFAIL

	#define LOG_CHANNEL RJD_LOG_CHANNEL
	#define LOG RJD_LOG
	#define log_resetglobal rjd_log_resetglobal

	#define UNUSED_PARAM RJD_UNUSED_PARAM
#endif

extern const struct rjd_logchannel* g_rjd_global_logchannel;

#ifdef RJD_IMPL

const struct rjd_logchannel rjd_global_logchannel = {
	.verbosity = RJD_LOG_VERBOSITY_MED,
	.enabled = true,
	.name = "Default Global",
};
const struct rjd_logchannel* g_rjd_global_logchannel = &rjd_global_logchannel;

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...)
{
	if (!channel || !channel->enabled) {
		return;
	}

	if (verbosity > channel->verbosity) {
		return;
	}

	va_list args;
	va_start(args, format);

	char rawMessage[4096];

	int written = vsnprintf(rawMessage, sizeof(rawMessage), format, args);
	va_end(args);

	if (written < 0)
	{
		printf("Failed to format message.\n");
		RJD_FORCECRASH();
	}

	static const char* formattedLog = "%s(%u): %s\n";
	static const uint32_t logLength = sizeof("%s(%u): %s\n");
	
	char formatted[4096];

	if (sizeof(formatted) <= logLength + written)
	{
		printf("Static buffer not large enough.\n");
		RJD_FORCECRASH();
	}

	const int size = sprintf(formatted, formattedLog, file, line, rawMessage);

	if (channel->hook) {
		channel->hook(formatted, size);
	} else {
		//OutputDebugString(formatted);
		fwrite(formatted, 1, size, stdout);
		fflush(stdout);
	}
}

void rjd_log_resetglobal()
{
	g_rjd_global_logchannel = &rjd_global_logchannel;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_alloc.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ALLOC 1

// DEPENDENCIES: 
// stdlib.h (malloc/free)
// rjd_debug.h

// TODO realloc
typedef void* (*rjd_func_alloc)(size_t size);
typedef void* (*rjd_func_alloc_scoped)(size_t size, void* allocator);

typedef void (*rjd_func_free)(void* memory);
typedef void (*rjd_func_free_scoped)(void* memory, void* heap);

struct rjd_alloc_context
{
	rjd_func_alloc alloc_global;
	rjd_func_free free_global;
	
	rjd_func_alloc_scoped alloc_scoped;
	rjd_func_free_scoped free_scoped;
	void* scope;
};

struct rjd_linearheap
{
	void* base;
	void* next;
	size_t size;
};

struct rjd_alloc_context rjd_alloc_initdefault(void);
struct rjd_alloc_context rjd_alloc_initglobal(rjd_func_alloc a, rjd_func_free f);
struct rjd_alloc_context rjd_alloc_initscoped(rjd_func_alloc_scoped a, rjd_func_free_scoped f, void* allocator);
struct rjd_alloc_context rjd_alloc_initlinearheap(void* mem, size_t heapsize);
void* rjd_malloc_impl(size_t size, struct rjd_alloc_context* context);
void rjd_free(void* mem, struct rjd_alloc_context* context);

#define rjd_malloc(type, context) ((type*)rjd_malloc_impl(sizeof(type), context))
#define rjd_malloc_array(type, count, context) ((type*)rjd_malloc_impl(sizeof(type) * count, context))

#if RJD_ENABLE_SHORTNAMES
	#define alloc_initdefault    rjd_alloc_initdefault
	#define alloc_initglobal     rjd_alloc_initglobal
	#define alloc_initscoped     rjd_alloc_initscoped
	#define alloc_initlinearheap rjd_alloc_initlinearheap
	#define rmalloc rjd_malloc
	#define rmalloc_array rjd_malloc_array
	#define rfree rjd_free
#endif

#ifdef RJD_IMPL

// detail functions
static struct rjd_linearheap rjd_linearheap_init(void* mem, size_t size);
static void* rjd_linearheap_malloc(size_t size, void* heap);
static void rjd_free_scoped_noop(void* mem, void* heap);

struct rjd_alloc_context rjd_alloc_initglobal(rjd_func_alloc a, rjd_func_free f)
{
	struct rjd_alloc_context context = { a, f, NULL, NULL, NULL };
	return context;
}

struct rjd_alloc_context rjd_alloc_initscoped(rjd_func_alloc_scoped a, rjd_func_free_scoped f, void* heap)
{
	struct rjd_alloc_context context = { NULL, NULL, a, f, heap };
	return context;
}

struct rjd_alloc_context rjd_alloc_initdefault()
{
	return rjd_alloc_initglobal(malloc, free);
}

struct rjd_alloc_context rjd_alloc_initlinearheap(void* mem, size_t heapsize)
{
	char* bytes = (char*)mem;
	const size_t structsize = sizeof(struct rjd_linearheap);
	struct rjd_linearheap* heap = (struct rjd_linearheap*)bytes + heapsize - structsize;
	*heap = rjd_linearheap_init(mem, heapsize - structsize);

	return rjd_alloc_initscoped(rjd_linearheap_malloc, rjd_free_scoped_noop, heap);
}

void* rjd_malloc_impl(size_t size, struct rjd_alloc_context* context)
{
	if (context->alloc_global) {
		return context->alloc_global(size);
	}
	return context->alloc_scoped(size, context->scope);
}

void rjd_free(void* mem, struct rjd_alloc_context* context)
{
	if (context->free_global) {
		context->free_global(mem);
	} else {
		context->free_scoped(mem, context->scope);
	}
}

static struct rjd_linearheap rjd_linearheap_init(void* mem, size_t size)
{
	struct rjd_linearheap heap = { mem, mem, size };
	return heap;
}

static void* rjd_linearheap_malloc(size_t size, void* userheap)
{
	size_t align_diff = size % 8;
	if (align_diff != 0) {
		size += align_diff;
	}

	struct rjd_linearheap* heap = (struct rjd_linearheap*)userheap;
	
	if ((char*)heap->next + size <= (char*)heap->base + heap->size) 
	{
		void* mem = (char*)heap->next;
		heap->next = (char*)heap->next + size;

		return mem;
	}

	return NULL;
}

static void rjd_free_scoped_noop(void* mem, void* heap)
{
	RJD_UNUSED_PARAM(mem);
	RJD_UNUSED_PARAM(heap);
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_rng.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RNG 1

struct rjd_rng
{
	uint64_t seed;
	uint64_t state;
};

struct rjd_rng rjd_rng_init(uint64_t seed);
uint64_t rjd_rng_next(struct rjd_rng* rng);
double rjd_rng_float(struct rjd_rng* rng);
int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive);

#if RJD_ENABLE_SHORTNAMES
	#define rng_init	rjd_rng_init
	#define rng_next	rjd_rng_next
	#define rng_float	rjd_rng_float
	#define rng_range32 rjd_rng_range32
#endif

#if RJD_IMPL

struct rjd_rng rjd_rng_init(uint64_t seed)
{
	struct rjd_rng rng = { seed, seed };
	return rng;
}

uint64_t rjd_rng_next(struct rjd_rng* rng)
{
	rng->state ^= rng->state << 15;
	rng->state ^= rng->state >> 3;
	rng->state ^= rng->state << 52;
	return rng->state;
}

double rjd_rng_float(struct rjd_rng* rng)
{
	uint64_t next = rjd_rng_next(rng) % 1000001ull;
	return (double)next / 1000000.0;
}

int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive)
{
	if (max_exclusive < min_inclusive) {
		return max_exclusive;
	}

	int32_t range = max_exclusive - min_inclusive;
	if (range == 0) {
		return min_inclusive;
	}

	uint64_t next = rjd_rng_next(rng);
	return min_inclusive + (next % range);
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_array.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ARRAY 1

// DEPENDENCIES
// rjd_alloc.h
// rjd_debug.h
// string.h

struct rjd_alloc_context;

#if RJD_COMPILER_MSVC
	#define rjd_countof(buf) _countof(buf)
#elif RJD_COMPILER_CLANG || RJD_COMPILER_GCC
	#define RJD_SAME_TYPE(a, b) (__builtin_types_compatible_p(__typeof__(a), __typeof__(b)))
	#define RJD_STATIC_ZERO(a) (sizeof(int[(a)?1:-1]) * 0)
	#define RJD_MUST_BE_ARRAY(a) (RJD_STATIC_ZERO(!RJD_SAME_TYPE((a), &(*a))))

	#define rjd_countof(buf) (sizeof(buf) / sizeof(*(buf)) + RJD_MUST_BE_ARRAY(buf))
#else
	#define rjd_countof(buf) ( (sizeof(buf) / sizeof(*(buf))) / ((size_t)(!sizeof(buf) % sizeof(0[buf]))) )
#endif

#define rjd_array_alloc(type, capacity, alloc_context)	((type*)(rjd_array_alloc_impl((capacity), (alloc_context), sizeof(type))))
#define rjd_array_free(buf)								rjd_array_free_impl(buf)
#define rjd_array_capacity(buf) 						((const uint32_t)(*rjd_array_capacity_impl(buf)))
#define rjd_array_count(buf) 							((const uint32_t)(*rjd_array_count_impl(buf)))
#define rjd_array_clear(buf)							(*rjd_array_count_impl(buf) = 0)
#define rjd_array_resize(buf, size) 					buf = rjd_array_resize_impl((buf), size, sizeof(*(buf)))
#define rjd_array_erase(buf, index) 					rjd_array_erase_impl((buf), index, sizeof(*(buf)))
#define rjd_array_erase_unordered(buf, index) 			rjd_array_erase_unordered_impl((buf), index, sizeof(*(buf)))
#define rjd_array_empty(buf) 							(rjd_array_count(buf) == 0)
#define rjd_array_full(buf) 							(rjd_array_count(buf) == rjd_array_capacity(buf))
#define rjd_array_push(buf, value) 						((buf) = rjd_array_grow_impl((buf), sizeof(*buf)), (buf)[rjd_array_count(buf) - 1] = value)
#define rjd_array_pop(buf)		 						(--*rjd_array_count_impl(buf), *(buf + rjd_array_count(buf)))

#define rjd_array_sum_pred(acc, element) (acc + element)

#define rjd_array_first(buf, _default)		(((buf) && rjd_array_count(buf) > 0) ? ((buf)[0]) : (_default))
#define rjd_array_last(buf, _default)		(((buf) && rjd_array_count(buf) > 0) ? ((buf)[rjd_array_count(buf) - 1]) : (_default))
#define rjd_array_contains(buf, value)		rjd_array_contains_impl((buf), &(value), sizeof(*buf), sizeof(value))
#define rjd_array_filter(buf, pred)			for(int _i = (int)rjd_array_count(buf) - 1; _i >= 0; --_i) { if (!(pred((buf)[_i]))) { rjd_array_erase((buf), _i); } }
#define rjd_array_map(in, out, pred)		rjd_array_resize((out), rjd_array_count(in)), for (size_t _i = 0; _i < rjd_array_count(in); ++_i) { out[_i] = pred(in[_i]); }
#define rjd_array_reduce(buf, acc, pred)	for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) { (acc) = pred(acc, ((buf)[_i])); }
#define rjd_array_sum(buf, acc)				for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) { (acc) = rjd_array_sum_pred((acc), ((buf)[_i])); }

#if RJD_RNG
	#define rjd_array_sample(buf, rng)		((buf)[rjd_rng_range32(rng, 0, rjd_array_count(buf))])
	#define rjd_array_shuffle(buf, rng)		rjd_array_shuffle_impl(buf, rng, sizeof(*buf))
#endif

#if RJD_ENABLE_SHORTNAMES
	#define countof					rjd_countof

	#define arr_alloc    			rjd_array_alloc
	#define arr_free    			rjd_array_free
	#define arr_capacity 			rjd_array_capacity
	#define arr_count    			rjd_array_count
	#define arr_clear				rjd_array_clear
	#define arr_resize   			rjd_array_resize
	#define arr_erase    			rjd_array_erase
	#define arr_erase_unordered		rjd_array_erase_unordered
	#define arr_empty    			rjd_array_empty
	#define arr_full     			rjd_array_full
	#define arr_push     			rjd_array_push
	#define arr_pop      			rjd_array_pop

	#define arr_first				rjd_array_first
	#define arr_last				rjd_array_last
	#define arr_contains			rjd_array_contains
	#define arr_filter				rjd_array_filter
	#define arr_map					rjd_array_map
	#define	arr_reduce				rjd_array_reduce
	#define arr_sum					rjd_array_sum

	#define arr_sample				rjd_array_sample
	#define arr_shuffle				rjd_array_shuffle
#endif

struct rjd_rng;

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_alloc_context* context, size_t sizeof_type);
void rjd_array_free_impl(void* buffer);
uint32_t* rjd_array_capacity_impl(void* buffer);
uint32_t* rjd_array_count_impl(void* buffer);
void* rjd_array_resize_impl(void* buffer, uint32_t newsize, size_t sizeof_type);
void rjd_array_erase_impl(void* buffer, uint32_t index, size_t sizeof_type);
void rjd_array_erase_unordered_impl(void* buffer, uint32_t index, size_t sizeof_type);
void* rjd_array_grow_impl(void* buffer, size_t sizeof_type);
bool rjd_array_contains_impl(void* buffer, void* value, size_t sizeof_type, size_t sizeof_value);
void rjd_array_shuffle_impl(void* buffer, struct rjd_rng* rng, size_t sizeof_type);

#if RJD_IMPL

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_alloc_context* context, size_t sizeof_type)
{
	RJD_ASSERT(capacity > 0);
	RJD_ASSERT(context);
	RJD_ASSERT(sizeof_type > 0);

	size_t rawsize = sizeof(struct rjd_alloc_context*) + (sizeof(uint32_t) * 2) + (sizeof_type * capacity);
	char* raw = (char*)rjd_malloc_impl(rawsize, context);

	struct rjd_alloc_context** contextCache = (struct rjd_alloc_context**)raw;
	*contextCache = context;
	uint32_t* pcapacity = (uint32_t*)(raw + sizeof(struct rjd_alloc_context*));
	uint32_t* pcount = (uint32_t*)(raw + sizeof(struct rjd_alloc_context*) + sizeof(uint32_t));
	char* buf = (char*)(raw + sizeof(struct rjd_alloc_context*) + sizeof(uint32_t) + sizeof(uint32_t));

	memset(buf, 0, sizeof_type * capacity);

	*pcapacity = capacity;
	*pcount = 0;

	return buf;
}

static struct rjd_alloc_context* rjd_array_getcontext_impl(void* buffer)
{
	RJD_ASSERT(buffer);

	char* raw = buffer;
	size_t headersize = sizeof(struct rjd_alloc_context*) + sizeof(uint32_t) + sizeof(uint32_t);
	struct rjd_alloc_context** context = (struct rjd_alloc_context**)(raw - headersize);
	return *context;
}

void rjd_array_free_impl(void* buffer)
{
	if (!buffer) {
		return;
	}

	struct rjd_alloc_context* context = rjd_array_getcontext_impl(buffer);

	char* raw = buffer;
	size_t headersize = sizeof(struct rjd_alloc_context*) + sizeof(uint32_t) + sizeof(uint32_t);

	rjd_free(raw - headersize, context);
}

uint32_t* rjd_array_capacity_impl(void* buffer)
{
	RJD_ASSERT(buffer);

	char* raw = buffer;
	return (uint32_t*)(raw - sizeof(uint32_t) - sizeof(uint32_t));
}

uint32_t* rjd_array_count_impl(void* buffer)
{
	RJD_ASSERT(buffer);

	char* raw = buffer;
	return (uint32_t*)(raw - sizeof(uint32_t));
}

void* rjd_array_resize_impl(void* buffer, uint32_t newsize, size_t sizeof_type)
{
	RJD_ASSERT(buffer);
	RJD_ASSERT(sizeof_type > 0);

	uint32_t newcapacity = newsize > 0 ? newsize : 1;

	uint32_t* count = rjd_array_count_impl(buffer);
	uint32_t* capacity = rjd_array_capacity_impl(buffer);

	if (*capacity < newcapacity) {
		struct rjd_alloc_context* context = rjd_array_getcontext_impl(buffer);
		void* newbuf = rjd_array_alloc_impl(newcapacity, context, sizeof_type);

		uint32_t oldcount = *count;
		memcpy(newbuf, buffer, oldcount * sizeof_type);
		count = rjd_array_count_impl(newbuf);

		rjd_array_free(buffer);
		buffer = newbuf;
	}

	*count = newsize;
	return buffer;
}

void rjd_array_erase_impl(void* buffer, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(buffer);
	RJD_ASSERT(index < rjd_array_count(buffer));
	RJD_ASSERT(sizeof_type > 0);

	char* raw = buffer;
	size_t toshift = rjd_array_count(buffer) - index - 1;
	if (toshift > 0) {
		memmove(raw + index * sizeof_type, raw + (index + 1) * sizeof_type, toshift * sizeof_type);
	}
	--*rjd_array_count_impl(buffer);
}

void rjd_array_erase_unordered_impl(void* buffer, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(buffer);
	RJD_ASSERT(index < rjd_array_count(buffer));
	RJD_ASSERT(sizeof_type > 0);

	char* raw = buffer;

	uint32_t* count = rjd_array_count_impl(buffer);

	if (*count > 1) {
		char* erase = raw + index * sizeof_type;
		char* swap = raw + (*count - 1) * sizeof_type;
		memcpy(erase, swap, sizeof_type);
	}

	if (*count > 0) {
		--*rjd_array_count_impl(buffer);
	}
}

void* rjd_array_grow_impl(void* buffer, size_t sizeof_type) {
	RJD_ASSERT(buffer);
	RJD_ASSERT(sizeof_type > 0);

	uint32_t capacity = rjd_array_capacity(buffer);
	if (capacity == rjd_array_count(buffer)) {
		buffer = rjd_array_resize_impl(buffer, capacity * 2, sizeof_type);
	}

	*rjd_array_count_impl(buffer) += 1;
	return buffer;
}

bool rjd_array_contains_impl(void* buffer, void* value, size_t sizeof_type, size_t sizeof_value)
{
	RJD_ASSERT(sizeof_type == sizeof_value);

	char* raw = (char*)buffer;
	for (uint32_t i = 0; i < rjd_array_count(buffer); ++i) {
		if (!memcmp(raw + i * sizeof_type, value, sizeof_type)) {
			return true;
		}
	}
	return false;
}

#if RJD_RNG
	void rjd_array_shuffle_impl(void* buffer, struct rjd_rng* rng, size_t sizeof_type)
	{
		char tmp[512];
		RJD_ASSERTMSG(sizeof_type <= sizeof(tmp), 
			"tmp (%u bytes) must be greater than or equal to sizeof_type (%u bytes)", 
			(unsigned) sizeof(tmp), (unsigned) sizeof_type);

		char* raw = (char*)buffer;
		for (uint32_t i = 0; i < rjd_array_count(buffer); ++i) {
			uint32_t k = rjd_rng_range32(rng, 0, rjd_array_count(buffer));
			if (i == k) {
				continue;
			}

			char* a = raw + (i * sizeof_type);
			char* b = raw + (k * sizeof_type);

			memcpy(tmp, a, sizeof_type);
			memcpy(a, b, sizeof_type);
			memcpy(b, tmp, sizeof_type);
		}
	}
#endif // RJD_RNG

#endif //RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_profiler.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PROFILER 1

struct rjd_timer
{
	double timestamp;
};

struct rjd_timer rjd_timer_init(void);
void rjd_timer_reset(struct rjd_timer* timer);
double rjd_timer_elapsed(const struct rjd_timer* timer);
double rjd_timer_global(void);

#define RJD_PROFILE_SCOPE(name, scope) {									\
		struct rjd_timer _timer##name = rjd_timer_init(); 					\
		{scope}																\
		LOG("Elapsed %s: %.4fms", #name, rjd_timer_elapsed(&_timer##name));	\
	}

#if RJD_ENABLE_SHORTNAMES
	#define timer_init		rjd_timer_init
	#define timer_reset		rjd_timer_reset
	#define timer_elapsed	rjd_timer_elapsed
	#define timer_global	rjd_timer_global

	#define PROFILE_SCOPE	RJD_PROFILE_SCOPE
#endif

#if RJD_IMPL

struct rjd_timer rjd_timer_init(void)
{
	struct rjd_timer timer;
	rjd_timer_reset(&timer);
	return timer;
}

void rjd_timer_reset(struct rjd_timer* timer)
{
	timer->timestamp = rjd_timer_global();
}

double rjd_timer_elapsed(const struct rjd_timer* timer)
{
	return rjd_timer_global() - timer->timestamp;
}
#ifdef RJD_PLATFORM_WINDOWS
	#define WIN32_LEAN_AND_MEAN
	#define WIN32_EXTRA_LEANA
	#define NOMINMAX
	#include <windows.h>

	static double RJD_QPC_FREQUENCY = 0;
	
	double rjd_timer_global(void)
	{
		if (RJD_QPC_FREQUENCY == 0) {
			LARGE_INTEGER frequency = {.QuadPart = 1};
			if (!QueryPerformanceFrequency(&frequency))
			{
				LOG("Failed to get QueryPerformanceFrequency: %d", GetLastError());
			}
			RJD_QPC_FREQUENCY = (double)frequency.QuadPart;
		}

		LARGE_INTEGER time = { .QuadPart = 0 };
		if (!QueryPerformanceCounter(&time))
		{
			LOG("Failed to get QueryPerformanceCounter. Time will be incorrect. Error: %d", GetLastError());
		}

		return (time.QuadPart * 1000LL) / RJD_QPC_FREQUENCY;
	}
#endif //_WIN32

#if RJD_PLATFORM_OSX
	#include <mach/mach.h>
	#include <mach/mach_time.h>

	static mach_timebase_info_data_t RJD_MACH_TIMEBASE_INFO;
	double rjd_timer_global(void)
	{
		if (RJD_MACH_TIMEBASE_INFO.denom == 0) {
			int ok = mach_timebase_info(&RJD_MACH_TIMEBASE_INFO);
			if (ok != KERN_SUCCESS) {
				LOG("Failed to get mach timebase info: %d", ok);
			}
		}

		double time = (double)mach_absolute_time();
		return time * ((double)RJD_MACH_TIMEBASE_INFO.numer / ((double)RJD_MACH_TIMEBASE_INFO.denom)) / 1000000;
	}
#endif // 

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_cmd.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_CMD 1

// DEPENDENCIES
// rjd_assert.h
// rjd_array.h

struct rjd_alloc_context;

struct rjd_cmd_argv
{
	const char* shortname;
	const char* longname;
	const char* argname;
	const char* description;
};

struct rjd_cmd
{
	int argc;
	const char** argv;

	struct rjd_cmd_argv* opts;
	struct rjd_cmd_argv* reqs;

	struct rjd_alloc_context* allocator;
};

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_alloc_context* allocator);
void rjd_cmd_free(struct rjd_cmd* cmd);
void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description);
void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description);
bool rjd_cmd_ok(const struct rjd_cmd* cmd);
void rjd_cmd_usage(const struct rjd_cmd* cmd);
void rjd_cmd_help(const struct rjd_cmd* cmd);

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* shortname, int _default);
unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* shortname, unsigned _default);
double rjd_cmd_float(const struct rjd_cmd* cmd, const char* shortname, double _default);
bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* shortname);
const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* shortname);

#if RJD_ENABLE_SHORTNAMES
	#define cmd_init	rjd_cmd_init
	#define cmd_free	rjd_cmd_free
	#define cmd_add_opt	rjd_cmd_add_opt
	#define cmd_add_req	rjd_cmd_add_req
	#define cmd_ok		rjd_cmd_ok
	#define cmd_usage	rjd_cmd_usage
	#define cmd_help	rjd_cmd_help

	#define cmd_int		rjd_cmd_int
	#define cmd_uint	rjd_cmd_uint
	#define cmd_float	rjd_cmd_float
	#define cmd_bool	rjd_cmd_bool
	#define cmd_str		rjd_cmd_str
#endif

#if RJD_IMPL

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_alloc_context* allocator)
{
	struct rjd_cmd cmd = {argc, argv, NULL, NULL, allocator};
	cmd.opts = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);
	cmd.reqs = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);

	rjd_cmd_add_opt(&cmd, "-h", "--help", NULL, "Prints help");
	return cmd;
}

void rjd_cmd_free(struct rjd_cmd* cmd)
{
	rjd_array_free(cmd->opts);
	rjd_array_free(cmd->reqs);
}

void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(shortname);
	RJD_ASSERT(longname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv opt = { shortname, longname, argname, description };
	rjd_array_push(cmd->opts, opt);
}

void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(argname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv req = { NULL, NULL, argname, description };
	rjd_array_push(cmd->reqs, req);
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv);
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd);
static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname);

bool rjd_cmd_ok(const struct rjd_cmd* cmd)
{
	RJD_ASSERT(cmd);

	int count = rjd_array_count(cmd->reqs);
	if (cmd->argc - 1 < count) {
		return false;
	}

	const int firstreq = rjd_cmd_firstreq(cmd);

	for (int i = 1; i < firstreq; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);

		if (!opt) {
			return false;
		}

		if (opt->argname) {
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				// since we're expecting an argument, this shouldn't match any other options
				if (rjd_cmd_matchopt(cmd, cmd->argv[i+1])) {
					return false;
				}
			} else {
				const char* eq = strstr(cmd->argv[i], "=");
				if (!eq) {
					return false;
				}
				const char* arg = eq + 1;
				if (*arg == 0) {
					return false;
				}
			}
			++i;
		}
	}
	
	return (cmd->argc - 1 - firstreq) == (int) rjd_array_count(cmd->reqs);
}

void rjd_cmd_usage(const struct rjd_cmd* cmd)
{
	// TODO rjd_stringbuilder

	size_t offset = 0;

	char optString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		offset += snprintf(optString + offset, sizeof(optString) - offset, "%s", cmd->opts[i].shortname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(optString + offset, sizeof(optString) - offset, " ");
		}
	}
	optString[offset] = 0;

	offset = 0;

	char reqString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		offset += snprintf(reqString + offset, sizeof(reqString) - offset, "%s", cmd->reqs[i].argname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(reqString + offset, sizeof(reqString) - offset, " ");
		}
	}
	reqString[offset] = 0;

	printf("Usage: %s [%s] %s\n", cmd->argv[0], optString, reqString);
}

void rjd_cmd_help(const struct rjd_cmd* cmd) 
{
	rjd_cmd_usage(cmd);

	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		printf("%s\n\t%s\n", cmd->reqs[i].argname, cmd->reqs[i].description);
	}

	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const struct rjd_cmd_argv* arg = cmd->opts + i;
		if (arg->argname) {
			printf("%s %s, %s=%s\n\t%s\n", arg->shortname, arg->argname, arg->longname, arg->argname, arg->description);
		} else {
			printf("%s, %s\n\t%s\n", arg->shortname, arg->longname, arg->description);
		}
	}
}

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* name, int _default)
{
	return (int)rjd_cmd_float(cmd, name, _default);
}

unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* name, unsigned _default)
{
	double v = rjd_cmd_float(cmd, name, _default);
	if (v < 0) {
		return _default;
	}
	return (unsigned)v;
}

double rjd_cmd_float(const struct rjd_cmd* cmd, const char* name, double _default)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return _default;
	}

	char* end = NULL;
	double v = strtod(str, &end);
	if (v == 0 && end != NULL) {
		return _default;
	}
	return v;
}

bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* name)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return false;
	}

	if (!strcmp(str, "true")) {
		return true;
	} else if (!strcmp(str, "false")) {
		return false;
	}

	const struct rjd_cmd_argv* opt = rjd_cmd_getopt(cmd, name);
	return opt && !strcmp(opt->shortname, name);
}

const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* name)
{
	const char* opt = rjd_cmd_findopt(cmd, name);
	if (opt) {
		return opt;
	}

	const char* req = rjd_cmd_findreq(cmd, name);
	if (req) {
		return req;
	}

	return NULL;
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv)
{
	if (!argv) {
		return NULL;
	}

	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const char* shortname = cmd->opts[i].shortname;
		const char* longname = cmd->opts[i].longname;
		if (!strcmp(shortname, argv)) {
			return cmd->opts + i;
		}
		if (strstr(argv, longname) == argv) {
			return cmd->opts + i;
		}
	}

	return NULL;
}
	
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd)
{
	int index = 0;
	for (int i = 1; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt) {
			// skip the argument (assuming the format is ok)
			if (!strcmp(cmd->argv[i], opt->shortname) && opt->argname) {
				++i;
			}
			index = i;
		} else {
			break;
		}
	}

	return index + 1;
}

static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		if (!strcmp(cmd->opts[i].shortname, shortname)) {
			return cmd->opts + i;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (int i = 0; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt && !strcmp(opt->shortname, shortname)) {
			if (!opt->argname) {
				return cmd->argv[i];
			}
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				return cmd->argv[i + 1];
			}
			const char* eq = strstr(cmd->argv[i], "=");
			if (eq) {
				return eq + 1;
			}
			break;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname) 
{
	int reqindex = -1;
	for (int i = 0; i < (int)rjd_array_count(cmd->reqs); ++i) {
		if (!strcmp(cmd->reqs[i].argname, argname)) {
			reqindex = i;
			break;
		}
	}

	if (reqindex == -1) {
		return NULL;
	}

	int optindex = rjd_cmd_firstreq(cmd) - 1; // -1 to get to first opt index

	int argvindex = optindex + reqindex + 1; // +1 to skip exe arg
	RJD_ASSERT(argvindex < cmd->argc);

	return cmd->argv[argvindex];
}

#endif


